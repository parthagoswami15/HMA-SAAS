
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Specialty
 * 
 */
export type Specialty = $Result.DefaultSelection<Prisma.$SpecialtyPayload>
/**
 * Model Staff
 * 
 */
export type Staff = $Result.DefaultSelection<Prisma.$StaffPayload>
/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model Prescription
 * 
 */
export type Prescription = $Result.DefaultSelection<Prisma.$PrescriptionPayload>
/**
 * Model PrescriptionItem
 * 
 */
export type PrescriptionItem = $Result.DefaultSelection<Prisma.$PrescriptionItemPayload>
/**
 * Model MedicalRecord
 * 
 */
export type MedicalRecord = $Result.DefaultSelection<Prisma.$MedicalRecordPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceItem
 * 
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model LabTest
 * 
 */
export type LabTest = $Result.DefaultSelection<Prisma.$LabTestPayload>
/**
 * Model LabOrder
 * 
 */
export type LabOrder = $Result.DefaultSelection<Prisma.$LabOrderPayload>
/**
 * Model LabOrderTest
 * 
 */
export type LabOrderTest = $Result.DefaultSelection<Prisma.$LabOrderTestPayload>
/**
 * Model Medication
 * 
 */
export type Medication = $Result.DefaultSelection<Prisma.$MedicationPayload>
/**
 * Model PharmacyOrder
 * 
 */
export type PharmacyOrder = $Result.DefaultSelection<Prisma.$PharmacyOrderPayload>
/**
 * Model PharmacyOrderItem
 * 
 */
export type PharmacyOrderItem = $Result.DefaultSelection<Prisma.$PharmacyOrderItemPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Modality
 * 
 */
export type Modality = $Result.DefaultSelection<Prisma.$ModalityPayload>
/**
 * Model Study
 * 
 */
export type Study = $Result.DefaultSelection<Prisma.$StudyPayload>
/**
 * Model Series
 * 
 */
export type Series = $Result.DefaultSelection<Prisma.$SeriesPayload>
/**
 * Model Image
 * 
 */
export type Image = $Result.DefaultSelection<Prisma.$ImagePayload>
/**
 * Model RadReport
 * 
 */
export type RadReport = $Result.DefaultSelection<Prisma.$RadReportPayload>
/**
 * Model RadiationDose
 * 
 */
export type RadiationDose = $Result.DefaultSelection<Prisma.$RadiationDosePayload>
/**
 * Model ReportTemplate
 * 
 */
export type ReportTemplate = $Result.DefaultSelection<Prisma.$ReportTemplatePayload>
/**
 * Model TelemedicineConsultation
 * 
 */
export type TelemedicineConsultation = $Result.DefaultSelection<Prisma.$TelemedicineConsultationPayload>
/**
 * Model VideoRoom
 * 
 */
export type VideoRoom = $Result.DefaultSelection<Prisma.$VideoRoomPayload>
/**
 * Model VideoParticipant
 * 
 */
export type VideoParticipant = $Result.DefaultSelection<Prisma.$VideoParticipantPayload>
/**
 * Model VideoRecording
 * 
 */
export type VideoRecording = $Result.DefaultSelection<Prisma.$VideoRecordingPayload>
/**
 * Model VideoMessage
 * 
 */
export type VideoMessage = $Result.DefaultSelection<Prisma.$VideoMessagePayload>
/**
 * Model RadiologyOrder
 * 
 */
export type RadiologyOrder = $Result.DefaultSelection<Prisma.$RadiologyOrderPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  DOCTOR: 'DOCTOR',
  NURSE: 'NURSE',
  LAB_TECHNICIAN: 'LAB_TECHNICIAN',
  RADIOLOGIST: 'RADIOLOGIST',
  PHARMACIST: 'PHARMACIST',
  RECEPTIONIST: 'RECEPTIONIST',
  ACCOUNTANT: 'ACCOUNTANT',
  PATIENT: 'PATIENT',
  USER: 'USER',
  HOSPITAL_ADMIN: 'HOSPITAL_ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const TenantType: {
  HOSPITAL: 'HOSPITAL',
  CLINIC: 'CLINIC',
  LAB: 'LAB',
  PHARMACY: 'PHARMACY',
  CHAMBER: 'CHAMBER',
  MULTI_SPECIALTY: 'MULTI_SPECIALTY'
};

export type TenantType = (typeof TenantType)[keyof typeof TenantType]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER',
  UNKNOWN: 'UNKNOWN'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const MaritalStatus: {
  SINGLE: 'SINGLE',
  MARRIED: 'MARRIED',
  DIVORCED: 'DIVORCED',
  WIDOWED: 'WIDOWED',
  SEPARATED: 'SEPARATED',
  DOMESTIC_PARTNERSHIP: 'DOMESTIC_PARTNERSHIP',
  UNKNOWN: 'UNKNOWN'
};

export type MaritalStatus = (typeof MaritalStatus)[keyof typeof MaritalStatus]


export const BloodType: {
  A_POSITIVE: 'A_POSITIVE',
  A_NEGATIVE: 'A_NEGATIVE',
  B_POSITIVE: 'B_POSITIVE',
  B_NEGATIVE: 'B_NEGATIVE',
  AB_POSITIVE: 'AB_POSITIVE',
  AB_NEGATIVE: 'AB_NEGATIVE',
  O_POSITIVE: 'O_POSITIVE',
  O_NEGATIVE: 'O_NEGATIVE',
  UNKNOWN: 'UNKNOWN'
};

export type BloodType = (typeof BloodType)[keyof typeof BloodType]


export const LabOrderStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  REJECTED: 'REJECTED'
};

export type LabOrderStatus = (typeof LabOrderStatus)[keyof typeof LabOrderStatus]


export const LabTestStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  REJECTED: 'REJECTED'
};

export type LabTestStatus = (typeof LabTestStatus)[keyof typeof LabTestStatus]


export const RegistrationType: {
  WALK_IN: 'WALK_IN',
  ONLINE: 'ONLINE',
  TRANSFER: 'TRANSFER',
  OTHER: 'OTHER'
};

export type RegistrationType = (typeof RegistrationType)[keyof typeof RegistrationType]


export const InsuranceType: {
  PRIVATE_INSURANCE: 'PRIVATE_INSURANCE',
  GOVERNMENT_INSURANCE: 'GOVERNMENT_INSURANCE',
  CORPORATE_INSURANCE: 'CORPORATE_INSURANCE',
  FAMILY_INSURANCE: 'FAMILY_INSURANCE',
  INDIVIDUAL_INSURANCE: 'INDIVIDUAL_INSURANCE',
  MEDICARE: 'MEDICARE',
  MEDICAID: 'MEDICAID',
  OTHER: 'OTHER'
};

export type InsuranceType = (typeof InsuranceType)[keyof typeof InsuranceType]


export const AppointmentStatus: {
  SCHEDULED: 'SCHEDULED',
  ARRIVED: 'ARRIVED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  NO_SHOW: 'NO_SHOW',
  RESCHEDULED: 'RESCHEDULED'
};

export type AppointmentStatus = (typeof AppointmentStatus)[keyof typeof AppointmentStatus]


export const PrescriptionStatus: {
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type PrescriptionStatus = (typeof PrescriptionStatus)[keyof typeof PrescriptionStatus]


export const InvoiceStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  PAID: 'PAID',
  PARTIALLY_PAID: 'PARTIALLY_PAID',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const PaymentMethod: {
  CASH: 'CASH',
  CREDIT_CARD: 'CREDIT_CARD',
  DEBIT_CARD: 'DEBIT_CARD',
  UPI: 'UPI',
  NET_BANKING: 'NET_BANKING',
  CHEQUE: 'CHEQUE',
  BANK_TRANSFER: 'BANK_TRANSFER',
  WALLET: 'WALLET',
  OTHER: 'OTHER'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED',
  CANCELLED: 'CANCELLED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const PharmacyOrderStatus: {
  PENDING: 'PENDING',
  DISPENSED: 'DISPENSED',
  PARTIALLY_DISPENSED: 'PARTIALLY_DISPENSED',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED'
};

export type PharmacyOrderStatus = (typeof PharmacyOrderStatus)[keyof typeof PharmacyOrderStatus]


export const PharmacyItemStatus: {
  PENDING: 'PENDING',
  DISPENSED: 'DISPENSED',
  OUT_OF_STOCK: 'OUT_OF_STOCK',
  CANCELLED: 'CANCELLED'
};

export type PharmacyItemStatus = (typeof PharmacyItemStatus)[keyof typeof PharmacyItemStatus]


export const StudyStatus: {
  SCHEDULED: 'SCHEDULED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  DELETED: 'DELETED'
};

export type StudyStatus = (typeof StudyStatus)[keyof typeof StudyStatus]


export const ReportStatus: {
  DRAFT: 'DRAFT',
  PRELIMINARY: 'PRELIMINARY',
  FINAL: 'FINAL',
  AMENDED: 'AMENDED',
  CANCELLED: 'CANCELLED'
};

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]


export const Priority: {
  STAT: 'STAT',
  HIGH: 'HIGH',
  ROUTINE: 'ROUTINE',
  LOW: 'LOW'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const TelemedicineStatus: {
  SCHEDULED: 'SCHEDULED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  NO_SHOW: 'NO_SHOW',
  RESCHEDULED: 'RESCHEDULED'
};

export type TelemedicineStatus = (typeof TelemedicineStatus)[keyof typeof TelemedicineStatus]


export const ConsultationType: {
  VIDEO: 'VIDEO',
  AUDIO: 'AUDIO',
  CHAT: 'CHAT',
  MIXED: 'MIXED'
};

export type ConsultationType = (typeof ConsultationType)[keyof typeof ConsultationType]


export const VideoRoomStatus: {
  WAITING: 'WAITING',
  ACTIVE: 'ACTIVE',
  ENDED: 'ENDED',
  CANCELLED: 'CANCELLED'
};

export type VideoRoomStatus = (typeof VideoRoomStatus)[keyof typeof VideoRoomStatus]


export const ParticipantType: {
  DOCTOR: 'DOCTOR',
  PATIENT: 'PATIENT',
  OBSERVER: 'OBSERVER',
  SUPPORT: 'SUPPORT'
};

export type ParticipantType = (typeof ParticipantType)[keyof typeof ParticipantType]


export const RecordingStatus: {
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type RecordingStatus = (typeof RecordingStatus)[keyof typeof RecordingStatus]


export const MessageType: {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  FILE: 'FILE',
  SYSTEM: 'SYSTEM'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]


export const RadiologyOrderStatus: {
  ORDERED: 'ORDERED',
  SCHEDULED: 'SCHEDULED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type RadiologyOrderStatus = (typeof RadiologyOrderStatus)[keyof typeof RadiologyOrderStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type TenantType = $Enums.TenantType

export const TenantType: typeof $Enums.TenantType

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type MaritalStatus = $Enums.MaritalStatus

export const MaritalStatus: typeof $Enums.MaritalStatus

export type BloodType = $Enums.BloodType

export const BloodType: typeof $Enums.BloodType

export type LabOrderStatus = $Enums.LabOrderStatus

export const LabOrderStatus: typeof $Enums.LabOrderStatus

export type LabTestStatus = $Enums.LabTestStatus

export const LabTestStatus: typeof $Enums.LabTestStatus

export type RegistrationType = $Enums.RegistrationType

export const RegistrationType: typeof $Enums.RegistrationType

export type InsuranceType = $Enums.InsuranceType

export const InsuranceType: typeof $Enums.InsuranceType

export type AppointmentStatus = $Enums.AppointmentStatus

export const AppointmentStatus: typeof $Enums.AppointmentStatus

export type PrescriptionStatus = $Enums.PrescriptionStatus

export const PrescriptionStatus: typeof $Enums.PrescriptionStatus

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type PharmacyOrderStatus = $Enums.PharmacyOrderStatus

export const PharmacyOrderStatus: typeof $Enums.PharmacyOrderStatus

export type PharmacyItemStatus = $Enums.PharmacyItemStatus

export const PharmacyItemStatus: typeof $Enums.PharmacyItemStatus

export type StudyStatus = $Enums.StudyStatus

export const StudyStatus: typeof $Enums.StudyStatus

export type ReportStatus = $Enums.ReportStatus

export const ReportStatus: typeof $Enums.ReportStatus

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type TelemedicineStatus = $Enums.TelemedicineStatus

export const TelemedicineStatus: typeof $Enums.TelemedicineStatus

export type ConsultationType = $Enums.ConsultationType

export const ConsultationType: typeof $Enums.ConsultationType

export type VideoRoomStatus = $Enums.VideoRoomStatus

export const VideoRoomStatus: typeof $Enums.VideoRoomStatus

export type ParticipantType = $Enums.ParticipantType

export const ParticipantType: typeof $Enums.ParticipantType

export type RecordingStatus = $Enums.RecordingStatus

export const RecordingStatus: typeof $Enums.RecordingStatus

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

export type RadiologyOrderStatus = $Enums.RadiologyOrderStatus

export const RadiologyOrderStatus: typeof $Enums.RadiologyOrderStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Departments
 * const departments = await prisma.department.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Departments
   * const departments = await prisma.department.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.specialty`: Exposes CRUD operations for the **Specialty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Specialties
    * const specialties = await prisma.specialty.findMany()
    * ```
    */
  get specialty(): Prisma.SpecialtyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.staff`: Exposes CRUD operations for the **Staff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Staff
    * const staff = await prisma.staff.findMany()
    * ```
    */
  get staff(): Prisma.StaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prescription`: Exposes CRUD operations for the **Prescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prescriptions
    * const prescriptions = await prisma.prescription.findMany()
    * ```
    */
  get prescription(): Prisma.PrescriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prescriptionItem`: Exposes CRUD operations for the **PrescriptionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrescriptionItems
    * const prescriptionItems = await prisma.prescriptionItem.findMany()
    * ```
    */
  get prescriptionItem(): Prisma.PrescriptionItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicalRecord`: Exposes CRUD operations for the **MedicalRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalRecords
    * const medicalRecords = await prisma.medicalRecord.findMany()
    * ```
    */
  get medicalRecord(): Prisma.MedicalRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labTest`: Exposes CRUD operations for the **LabTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabTests
    * const labTests = await prisma.labTest.findMany()
    * ```
    */
  get labTest(): Prisma.LabTestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labOrder`: Exposes CRUD operations for the **LabOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabOrders
    * const labOrders = await prisma.labOrder.findMany()
    * ```
    */
  get labOrder(): Prisma.LabOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labOrderTest`: Exposes CRUD operations for the **LabOrderTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabOrderTests
    * const labOrderTests = await prisma.labOrderTest.findMany()
    * ```
    */
  get labOrderTest(): Prisma.LabOrderTestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medication`: Exposes CRUD operations for the **Medication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medications
    * const medications = await prisma.medication.findMany()
    * ```
    */
  get medication(): Prisma.MedicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pharmacyOrder`: Exposes CRUD operations for the **PharmacyOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PharmacyOrders
    * const pharmacyOrders = await prisma.pharmacyOrder.findMany()
    * ```
    */
  get pharmacyOrder(): Prisma.PharmacyOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pharmacyOrderItem`: Exposes CRUD operations for the **PharmacyOrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PharmacyOrderItems
    * const pharmacyOrderItems = await prisma.pharmacyOrderItem.findMany()
    * ```
    */
  get pharmacyOrderItem(): Prisma.PharmacyOrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modality`: Exposes CRUD operations for the **Modality** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modalities
    * const modalities = await prisma.modality.findMany()
    * ```
    */
  get modality(): Prisma.ModalityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.study`: Exposes CRUD operations for the **Study** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Studies
    * const studies = await prisma.study.findMany()
    * ```
    */
  get study(): Prisma.StudyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.series`: Exposes CRUD operations for the **Series** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Series
    * const series = await prisma.series.findMany()
    * ```
    */
  get series(): Prisma.SeriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.image`: Exposes CRUD operations for the **Image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.image.findMany()
    * ```
    */
  get image(): Prisma.ImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.radReport`: Exposes CRUD operations for the **RadReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RadReports
    * const radReports = await prisma.radReport.findMany()
    * ```
    */
  get radReport(): Prisma.RadReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.radiationDose`: Exposes CRUD operations for the **RadiationDose** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RadiationDoses
    * const radiationDoses = await prisma.radiationDose.findMany()
    * ```
    */
  get radiationDose(): Prisma.RadiationDoseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportTemplate`: Exposes CRUD operations for the **ReportTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportTemplates
    * const reportTemplates = await prisma.reportTemplate.findMany()
    * ```
    */
  get reportTemplate(): Prisma.ReportTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.telemedicineConsultation`: Exposes CRUD operations for the **TelemedicineConsultation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TelemedicineConsultations
    * const telemedicineConsultations = await prisma.telemedicineConsultation.findMany()
    * ```
    */
  get telemedicineConsultation(): Prisma.TelemedicineConsultationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videoRoom`: Exposes CRUD operations for the **VideoRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoRooms
    * const videoRooms = await prisma.videoRoom.findMany()
    * ```
    */
  get videoRoom(): Prisma.VideoRoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videoParticipant`: Exposes CRUD operations for the **VideoParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoParticipants
    * const videoParticipants = await prisma.videoParticipant.findMany()
    * ```
    */
  get videoParticipant(): Prisma.VideoParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videoRecording`: Exposes CRUD operations for the **VideoRecording** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoRecordings
    * const videoRecordings = await prisma.videoRecording.findMany()
    * ```
    */
  get videoRecording(): Prisma.VideoRecordingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.videoMessage`: Exposes CRUD operations for the **VideoMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VideoMessages
    * const videoMessages = await prisma.videoMessage.findMany()
    * ```
    */
  get videoMessage(): Prisma.VideoMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.radiologyOrder`: Exposes CRUD operations for the **RadiologyOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RadiologyOrders
    * const radiologyOrders = await prisma.radiologyOrder.findMany()
    * ```
    */
  get radiologyOrder(): Prisma.RadiologyOrderDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Department: 'Department',
    Specialty: 'Specialty',
    Staff: 'Staff',
    Tenant: 'Tenant',
    User: 'User',
    RefreshToken: 'RefreshToken',
    Patient: 'Patient',
    Appointment: 'Appointment',
    Prescription: 'Prescription',
    PrescriptionItem: 'PrescriptionItem',
    MedicalRecord: 'MedicalRecord',
    Invoice: 'Invoice',
    InvoiceItem: 'InvoiceItem',
    Payment: 'Payment',
    LabTest: 'LabTest',
    LabOrder: 'LabOrder',
    LabOrderTest: 'LabOrderTest',
    Medication: 'Medication',
    PharmacyOrder: 'PharmacyOrder',
    PharmacyOrderItem: 'PharmacyOrderItem',
    AuditLog: 'AuditLog',
    Modality: 'Modality',
    Study: 'Study',
    Series: 'Series',
    Image: 'Image',
    RadReport: 'RadReport',
    RadiationDose: 'RadiationDose',
    ReportTemplate: 'ReportTemplate',
    TelemedicineConsultation: 'TelemedicineConsultation',
    VideoRoom: 'VideoRoom',
    VideoParticipant: 'VideoParticipant',
    VideoRecording: 'VideoRecording',
    VideoMessage: 'VideoMessage',
    RadiologyOrder: 'RadiologyOrder'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "department" | "specialty" | "staff" | "tenant" | "user" | "refreshToken" | "patient" | "appointment" | "prescription" | "prescriptionItem" | "medicalRecord" | "invoice" | "invoiceItem" | "payment" | "labTest" | "labOrder" | "labOrderTest" | "medication" | "pharmacyOrder" | "pharmacyOrderItem" | "auditLog" | "modality" | "study" | "series" | "image" | "radReport" | "radiationDose" | "reportTemplate" | "telemedicineConsultation" | "videoRoom" | "videoParticipant" | "videoRecording" | "videoMessage" | "radiologyOrder"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Specialty: {
        payload: Prisma.$SpecialtyPayload<ExtArgs>
        fields: Prisma.SpecialtyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpecialtyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpecialtyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          findFirst: {
            args: Prisma.SpecialtyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpecialtyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          findMany: {
            args: Prisma.SpecialtyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>[]
          }
          create: {
            args: Prisma.SpecialtyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          createMany: {
            args: Prisma.SpecialtyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpecialtyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>[]
          }
          delete: {
            args: Prisma.SpecialtyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          update: {
            args: Prisma.SpecialtyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          deleteMany: {
            args: Prisma.SpecialtyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpecialtyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpecialtyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>[]
          }
          upsert: {
            args: Prisma.SpecialtyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpecialtyPayload>
          }
          aggregate: {
            args: Prisma.SpecialtyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpecialty>
          }
          groupBy: {
            args: Prisma.SpecialtyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpecialtyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpecialtyCountArgs<ExtArgs>
            result: $Utils.Optional<SpecialtyCountAggregateOutputType> | number
          }
        }
      }
      Staff: {
        payload: Prisma.$StaffPayload<ExtArgs>
        fields: Prisma.StaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          findFirst: {
            args: Prisma.StaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          findMany: {
            args: Prisma.StaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          create: {
            args: Prisma.StaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          createMany: {
            args: Prisma.StaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          delete: {
            args: Prisma.StaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          update: {
            args: Prisma.StaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          deleteMany: {
            args: Prisma.StaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          upsert: {
            args: Prisma.StaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          aggregate: {
            args: Prisma.StaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaff>
          }
          groupBy: {
            args: Prisma.StaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffCountArgs<ExtArgs>
            result: $Utils.Optional<StaffCountAggregateOutputType> | number
          }
        }
      }
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      Prescription: {
        payload: Prisma.$PrescriptionPayload<ExtArgs>
        fields: Prisma.PrescriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findFirst: {
            args: Prisma.PrescriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findMany: {
            args: Prisma.PrescriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          create: {
            args: Prisma.PrescriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          createMany: {
            args: Prisma.PrescriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrescriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          delete: {
            args: Prisma.PrescriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          update: {
            args: Prisma.PrescriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrescriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          upsert: {
            args: Prisma.PrescriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescription>
          }
          groupBy: {
            args: Prisma.PrescriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionCountAggregateOutputType> | number
          }
        }
      }
      PrescriptionItem: {
        payload: Prisma.$PrescriptionItemPayload<ExtArgs>
        fields: Prisma.PrescriptionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          findFirst: {
            args: Prisma.PrescriptionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          findMany: {
            args: Prisma.PrescriptionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>[]
          }
          create: {
            args: Prisma.PrescriptionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          createMany: {
            args: Prisma.PrescriptionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrescriptionItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>[]
          }
          delete: {
            args: Prisma.PrescriptionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          update: {
            args: Prisma.PrescriptionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrescriptionItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>[]
          }
          upsert: {
            args: Prisma.PrescriptionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescriptionItem>
          }
          groupBy: {
            args: Prisma.PrescriptionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionItemCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionItemCountAggregateOutputType> | number
          }
        }
      }
      MedicalRecord: {
        payload: Prisma.$MedicalRecordPayload<ExtArgs>
        fields: Prisma.MedicalRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          findFirst: {
            args: Prisma.MedicalRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          findMany: {
            args: Prisma.MedicalRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>[]
          }
          create: {
            args: Prisma.MedicalRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          createMany: {
            args: Prisma.MedicalRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicalRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>[]
          }
          delete: {
            args: Prisma.MedicalRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          update: {
            args: Prisma.MedicalRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          deleteMany: {
            args: Prisma.MedicalRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicalRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>[]
          }
          upsert: {
            args: Prisma.MedicalRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalRecordPayload>
          }
          aggregate: {
            args: Prisma.MedicalRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalRecord>
          }
          groupBy: {
            args: Prisma.MedicalRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicalRecordCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalRecordCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>
        fields: Prisma.InvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      LabTest: {
        payload: Prisma.$LabTestPayload<ExtArgs>
        fields: Prisma.LabTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>
          }
          findFirst: {
            args: Prisma.LabTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>
          }
          findMany: {
            args: Prisma.LabTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>[]
          }
          create: {
            args: Prisma.LabTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>
          }
          createMany: {
            args: Prisma.LabTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>[]
          }
          delete: {
            args: Prisma.LabTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>
          }
          update: {
            args: Prisma.LabTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>
          }
          deleteMany: {
            args: Prisma.LabTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabTestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>[]
          }
          upsert: {
            args: Prisma.LabTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>
          }
          aggregate: {
            args: Prisma.LabTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabTest>
          }
          groupBy: {
            args: Prisma.LabTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabTestCountArgs<ExtArgs>
            result: $Utils.Optional<LabTestCountAggregateOutputType> | number
          }
        }
      }
      LabOrder: {
        payload: Prisma.$LabOrderPayload<ExtArgs>
        fields: Prisma.LabOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload>
          }
          findFirst: {
            args: Prisma.LabOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload>
          }
          findMany: {
            args: Prisma.LabOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload>[]
          }
          create: {
            args: Prisma.LabOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload>
          }
          createMany: {
            args: Prisma.LabOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload>[]
          }
          delete: {
            args: Prisma.LabOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload>
          }
          update: {
            args: Prisma.LabOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload>
          }
          deleteMany: {
            args: Prisma.LabOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload>[]
          }
          upsert: {
            args: Prisma.LabOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderPayload>
          }
          aggregate: {
            args: Prisma.LabOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabOrder>
          }
          groupBy: {
            args: Prisma.LabOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabOrderCountArgs<ExtArgs>
            result: $Utils.Optional<LabOrderCountAggregateOutputType> | number
          }
        }
      }
      LabOrderTest: {
        payload: Prisma.$LabOrderTestPayload<ExtArgs>
        fields: Prisma.LabOrderTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabOrderTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabOrderTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload>
          }
          findFirst: {
            args: Prisma.LabOrderTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabOrderTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload>
          }
          findMany: {
            args: Prisma.LabOrderTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload>[]
          }
          create: {
            args: Prisma.LabOrderTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload>
          }
          createMany: {
            args: Prisma.LabOrderTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabOrderTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload>[]
          }
          delete: {
            args: Prisma.LabOrderTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload>
          }
          update: {
            args: Prisma.LabOrderTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload>
          }
          deleteMany: {
            args: Prisma.LabOrderTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabOrderTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabOrderTestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload>[]
          }
          upsert: {
            args: Prisma.LabOrderTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabOrderTestPayload>
          }
          aggregate: {
            args: Prisma.LabOrderTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabOrderTest>
          }
          groupBy: {
            args: Prisma.LabOrderTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabOrderTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabOrderTestCountArgs<ExtArgs>
            result: $Utils.Optional<LabOrderTestCountAggregateOutputType> | number
          }
        }
      }
      Medication: {
        payload: Prisma.$MedicationPayload<ExtArgs>
        fields: Prisma.MedicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          findFirst: {
            args: Prisma.MedicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          findMany: {
            args: Prisma.MedicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>[]
          }
          create: {
            args: Prisma.MedicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          createMany: {
            args: Prisma.MedicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>[]
          }
          delete: {
            args: Prisma.MedicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          update: {
            args: Prisma.MedicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          deleteMany: {
            args: Prisma.MedicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>[]
          }
          upsert: {
            args: Prisma.MedicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          aggregate: {
            args: Prisma.MedicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedication>
          }
          groupBy: {
            args: Prisma.MedicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicationCountArgs<ExtArgs>
            result: $Utils.Optional<MedicationCountAggregateOutputType> | number
          }
        }
      }
      PharmacyOrder: {
        payload: Prisma.$PharmacyOrderPayload<ExtArgs>
        fields: Prisma.PharmacyOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PharmacyOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PharmacyOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderPayload>
          }
          findFirst: {
            args: Prisma.PharmacyOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PharmacyOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderPayload>
          }
          findMany: {
            args: Prisma.PharmacyOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderPayload>[]
          }
          create: {
            args: Prisma.PharmacyOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderPayload>
          }
          createMany: {
            args: Prisma.PharmacyOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PharmacyOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderPayload>[]
          }
          delete: {
            args: Prisma.PharmacyOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderPayload>
          }
          update: {
            args: Prisma.PharmacyOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderPayload>
          }
          deleteMany: {
            args: Prisma.PharmacyOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PharmacyOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PharmacyOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderPayload>[]
          }
          upsert: {
            args: Prisma.PharmacyOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderPayload>
          }
          aggregate: {
            args: Prisma.PharmacyOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePharmacyOrder>
          }
          groupBy: {
            args: Prisma.PharmacyOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PharmacyOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PharmacyOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PharmacyOrderCountAggregateOutputType> | number
          }
        }
      }
      PharmacyOrderItem: {
        payload: Prisma.$PharmacyOrderItemPayload<ExtArgs>
        fields: Prisma.PharmacyOrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PharmacyOrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PharmacyOrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderItemPayload>
          }
          findFirst: {
            args: Prisma.PharmacyOrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PharmacyOrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderItemPayload>
          }
          findMany: {
            args: Prisma.PharmacyOrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderItemPayload>[]
          }
          create: {
            args: Prisma.PharmacyOrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderItemPayload>
          }
          createMany: {
            args: Prisma.PharmacyOrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PharmacyOrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderItemPayload>[]
          }
          delete: {
            args: Prisma.PharmacyOrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderItemPayload>
          }
          update: {
            args: Prisma.PharmacyOrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderItemPayload>
          }
          deleteMany: {
            args: Prisma.PharmacyOrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PharmacyOrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PharmacyOrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderItemPayload>[]
          }
          upsert: {
            args: Prisma.PharmacyOrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacyOrderItemPayload>
          }
          aggregate: {
            args: Prisma.PharmacyOrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePharmacyOrderItem>
          }
          groupBy: {
            args: Prisma.PharmacyOrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PharmacyOrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PharmacyOrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<PharmacyOrderItemCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Modality: {
        payload: Prisma.$ModalityPayload<ExtArgs>
        fields: Prisma.ModalityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModalityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModalityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModalityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModalityPayload>
          }
          findFirst: {
            args: Prisma.ModalityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModalityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModalityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModalityPayload>
          }
          findMany: {
            args: Prisma.ModalityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModalityPayload>[]
          }
          create: {
            args: Prisma.ModalityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModalityPayload>
          }
          createMany: {
            args: Prisma.ModalityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModalityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModalityPayload>[]
          }
          delete: {
            args: Prisma.ModalityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModalityPayload>
          }
          update: {
            args: Prisma.ModalityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModalityPayload>
          }
          deleteMany: {
            args: Prisma.ModalityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModalityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModalityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModalityPayload>[]
          }
          upsert: {
            args: Prisma.ModalityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModalityPayload>
          }
          aggregate: {
            args: Prisma.ModalityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModality>
          }
          groupBy: {
            args: Prisma.ModalityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModalityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModalityCountArgs<ExtArgs>
            result: $Utils.Optional<ModalityCountAggregateOutputType> | number
          }
        }
      }
      Study: {
        payload: Prisma.$StudyPayload<ExtArgs>
        fields: Prisma.StudyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload>
          }
          findFirst: {
            args: Prisma.StudyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload>
          }
          findMany: {
            args: Prisma.StudyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload>[]
          }
          create: {
            args: Prisma.StudyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload>
          }
          createMany: {
            args: Prisma.StudyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload>[]
          }
          delete: {
            args: Prisma.StudyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload>
          }
          update: {
            args: Prisma.StudyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload>
          }
          deleteMany: {
            args: Prisma.StudyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload>[]
          }
          upsert: {
            args: Prisma.StudyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyPayload>
          }
          aggregate: {
            args: Prisma.StudyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudy>
          }
          groupBy: {
            args: Prisma.StudyGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudyGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudyCountArgs<ExtArgs>
            result: $Utils.Optional<StudyCountAggregateOutputType> | number
          }
        }
      }
      Series: {
        payload: Prisma.$SeriesPayload<ExtArgs>
        fields: Prisma.SeriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          findFirst: {
            args: Prisma.SeriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          findMany: {
            args: Prisma.SeriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>[]
          }
          create: {
            args: Prisma.SeriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          createMany: {
            args: Prisma.SeriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>[]
          }
          delete: {
            args: Prisma.SeriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          update: {
            args: Prisma.SeriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          deleteMany: {
            args: Prisma.SeriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>[]
          }
          upsert: {
            args: Prisma.SeriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          aggregate: {
            args: Prisma.SeriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeries>
          }
          groupBy: {
            args: Prisma.SeriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeriesCountArgs<ExtArgs>
            result: $Utils.Optional<SeriesCountAggregateOutputType> | number
          }
        }
      }
      Image: {
        payload: Prisma.$ImagePayload<ExtArgs>
        fields: Prisma.ImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findFirst: {
            args: Prisma.ImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findMany: {
            args: Prisma.ImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          create: {
            args: Prisma.ImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          createMany: {
            args: Prisma.ImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          delete: {
            args: Prisma.ImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          update: {
            args: Prisma.ImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          deleteMany: {
            args: Prisma.ImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          upsert: {
            args: Prisma.ImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          aggregate: {
            args: Prisma.ImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImage>
          }
          groupBy: {
            args: Prisma.ImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImageCountArgs<ExtArgs>
            result: $Utils.Optional<ImageCountAggregateOutputType> | number
          }
        }
      }
      RadReport: {
        payload: Prisma.$RadReportPayload<ExtArgs>
        fields: Prisma.RadReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RadReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RadReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadReportPayload>
          }
          findFirst: {
            args: Prisma.RadReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RadReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadReportPayload>
          }
          findMany: {
            args: Prisma.RadReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadReportPayload>[]
          }
          create: {
            args: Prisma.RadReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadReportPayload>
          }
          createMany: {
            args: Prisma.RadReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RadReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadReportPayload>[]
          }
          delete: {
            args: Prisma.RadReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadReportPayload>
          }
          update: {
            args: Prisma.RadReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadReportPayload>
          }
          deleteMany: {
            args: Prisma.RadReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RadReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RadReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadReportPayload>[]
          }
          upsert: {
            args: Prisma.RadReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadReportPayload>
          }
          aggregate: {
            args: Prisma.RadReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRadReport>
          }
          groupBy: {
            args: Prisma.RadReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<RadReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.RadReportCountArgs<ExtArgs>
            result: $Utils.Optional<RadReportCountAggregateOutputType> | number
          }
        }
      }
      RadiationDose: {
        payload: Prisma.$RadiationDosePayload<ExtArgs>
        fields: Prisma.RadiationDoseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RadiationDoseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiationDosePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RadiationDoseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiationDosePayload>
          }
          findFirst: {
            args: Prisma.RadiationDoseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiationDosePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RadiationDoseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiationDosePayload>
          }
          findMany: {
            args: Prisma.RadiationDoseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiationDosePayload>[]
          }
          create: {
            args: Prisma.RadiationDoseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiationDosePayload>
          }
          createMany: {
            args: Prisma.RadiationDoseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RadiationDoseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiationDosePayload>[]
          }
          delete: {
            args: Prisma.RadiationDoseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiationDosePayload>
          }
          update: {
            args: Prisma.RadiationDoseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiationDosePayload>
          }
          deleteMany: {
            args: Prisma.RadiationDoseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RadiationDoseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RadiationDoseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiationDosePayload>[]
          }
          upsert: {
            args: Prisma.RadiationDoseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiationDosePayload>
          }
          aggregate: {
            args: Prisma.RadiationDoseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRadiationDose>
          }
          groupBy: {
            args: Prisma.RadiationDoseGroupByArgs<ExtArgs>
            result: $Utils.Optional<RadiationDoseGroupByOutputType>[]
          }
          count: {
            args: Prisma.RadiationDoseCountArgs<ExtArgs>
            result: $Utils.Optional<RadiationDoseCountAggregateOutputType> | number
          }
        }
      }
      ReportTemplate: {
        payload: Prisma.$ReportTemplatePayload<ExtArgs>
        fields: Prisma.ReportTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          findFirst: {
            args: Prisma.ReportTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          findMany: {
            args: Prisma.ReportTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>[]
          }
          create: {
            args: Prisma.ReportTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          createMany: {
            args: Prisma.ReportTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>[]
          }
          delete: {
            args: Prisma.ReportTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          update: {
            args: Prisma.ReportTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ReportTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>[]
          }
          upsert: {
            args: Prisma.ReportTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          aggregate: {
            args: Prisma.ReportTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportTemplate>
          }
          groupBy: {
            args: Prisma.ReportTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ReportTemplateCountAggregateOutputType> | number
          }
        }
      }
      TelemedicineConsultation: {
        payload: Prisma.$TelemedicineConsultationPayload<ExtArgs>
        fields: Prisma.TelemedicineConsultationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TelemedicineConsultationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelemedicineConsultationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TelemedicineConsultationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelemedicineConsultationPayload>
          }
          findFirst: {
            args: Prisma.TelemedicineConsultationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelemedicineConsultationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TelemedicineConsultationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelemedicineConsultationPayload>
          }
          findMany: {
            args: Prisma.TelemedicineConsultationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelemedicineConsultationPayload>[]
          }
          create: {
            args: Prisma.TelemedicineConsultationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelemedicineConsultationPayload>
          }
          createMany: {
            args: Prisma.TelemedicineConsultationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TelemedicineConsultationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelemedicineConsultationPayload>[]
          }
          delete: {
            args: Prisma.TelemedicineConsultationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelemedicineConsultationPayload>
          }
          update: {
            args: Prisma.TelemedicineConsultationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelemedicineConsultationPayload>
          }
          deleteMany: {
            args: Prisma.TelemedicineConsultationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TelemedicineConsultationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TelemedicineConsultationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelemedicineConsultationPayload>[]
          }
          upsert: {
            args: Prisma.TelemedicineConsultationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelemedicineConsultationPayload>
          }
          aggregate: {
            args: Prisma.TelemedicineConsultationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTelemedicineConsultation>
          }
          groupBy: {
            args: Prisma.TelemedicineConsultationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TelemedicineConsultationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TelemedicineConsultationCountArgs<ExtArgs>
            result: $Utils.Optional<TelemedicineConsultationCountAggregateOutputType> | number
          }
        }
      }
      VideoRoom: {
        payload: Prisma.$VideoRoomPayload<ExtArgs>
        fields: Prisma.VideoRoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoRoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoRoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRoomPayload>
          }
          findFirst: {
            args: Prisma.VideoRoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoRoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRoomPayload>
          }
          findMany: {
            args: Prisma.VideoRoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRoomPayload>[]
          }
          create: {
            args: Prisma.VideoRoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRoomPayload>
          }
          createMany: {
            args: Prisma.VideoRoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoRoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRoomPayload>[]
          }
          delete: {
            args: Prisma.VideoRoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRoomPayload>
          }
          update: {
            args: Prisma.VideoRoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRoomPayload>
          }
          deleteMany: {
            args: Prisma.VideoRoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoRoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VideoRoomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRoomPayload>[]
          }
          upsert: {
            args: Prisma.VideoRoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRoomPayload>
          }
          aggregate: {
            args: Prisma.VideoRoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoRoom>
          }
          groupBy: {
            args: Prisma.VideoRoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoRoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoRoomCountArgs<ExtArgs>
            result: $Utils.Optional<VideoRoomCountAggregateOutputType> | number
          }
        }
      }
      VideoParticipant: {
        payload: Prisma.$VideoParticipantPayload<ExtArgs>
        fields: Prisma.VideoParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoParticipantPayload>
          }
          findFirst: {
            args: Prisma.VideoParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoParticipantPayload>
          }
          findMany: {
            args: Prisma.VideoParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoParticipantPayload>[]
          }
          create: {
            args: Prisma.VideoParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoParticipantPayload>
          }
          createMany: {
            args: Prisma.VideoParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoParticipantPayload>[]
          }
          delete: {
            args: Prisma.VideoParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoParticipantPayload>
          }
          update: {
            args: Prisma.VideoParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoParticipantPayload>
          }
          deleteMany: {
            args: Prisma.VideoParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VideoParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoParticipantPayload>[]
          }
          upsert: {
            args: Prisma.VideoParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoParticipantPayload>
          }
          aggregate: {
            args: Prisma.VideoParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoParticipant>
          }
          groupBy: {
            args: Prisma.VideoParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<VideoParticipantCountAggregateOutputType> | number
          }
        }
      }
      VideoRecording: {
        payload: Prisma.$VideoRecordingPayload<ExtArgs>
        fields: Prisma.VideoRecordingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoRecordingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRecordingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoRecordingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRecordingPayload>
          }
          findFirst: {
            args: Prisma.VideoRecordingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRecordingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoRecordingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRecordingPayload>
          }
          findMany: {
            args: Prisma.VideoRecordingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRecordingPayload>[]
          }
          create: {
            args: Prisma.VideoRecordingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRecordingPayload>
          }
          createMany: {
            args: Prisma.VideoRecordingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoRecordingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRecordingPayload>[]
          }
          delete: {
            args: Prisma.VideoRecordingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRecordingPayload>
          }
          update: {
            args: Prisma.VideoRecordingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRecordingPayload>
          }
          deleteMany: {
            args: Prisma.VideoRecordingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoRecordingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VideoRecordingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRecordingPayload>[]
          }
          upsert: {
            args: Prisma.VideoRecordingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoRecordingPayload>
          }
          aggregate: {
            args: Prisma.VideoRecordingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoRecording>
          }
          groupBy: {
            args: Prisma.VideoRecordingGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoRecordingGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoRecordingCountArgs<ExtArgs>
            result: $Utils.Optional<VideoRecordingCountAggregateOutputType> | number
          }
        }
      }
      VideoMessage: {
        payload: Prisma.$VideoMessagePayload<ExtArgs>
        fields: Prisma.VideoMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMessagePayload>
          }
          findFirst: {
            args: Prisma.VideoMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMessagePayload>
          }
          findMany: {
            args: Prisma.VideoMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMessagePayload>[]
          }
          create: {
            args: Prisma.VideoMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMessagePayload>
          }
          createMany: {
            args: Prisma.VideoMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMessagePayload>[]
          }
          delete: {
            args: Prisma.VideoMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMessagePayload>
          }
          update: {
            args: Prisma.VideoMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMessagePayload>
          }
          deleteMany: {
            args: Prisma.VideoMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VideoMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMessagePayload>[]
          }
          upsert: {
            args: Prisma.VideoMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoMessagePayload>
          }
          aggregate: {
            args: Prisma.VideoMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideoMessage>
          }
          groupBy: {
            args: Prisma.VideoMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoMessageCountArgs<ExtArgs>
            result: $Utils.Optional<VideoMessageCountAggregateOutputType> | number
          }
        }
      }
      RadiologyOrder: {
        payload: Prisma.$RadiologyOrderPayload<ExtArgs>
        fields: Prisma.RadiologyOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RadiologyOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RadiologyOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyOrderPayload>
          }
          findFirst: {
            args: Prisma.RadiologyOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RadiologyOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyOrderPayload>
          }
          findMany: {
            args: Prisma.RadiologyOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyOrderPayload>[]
          }
          create: {
            args: Prisma.RadiologyOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyOrderPayload>
          }
          createMany: {
            args: Prisma.RadiologyOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RadiologyOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyOrderPayload>[]
          }
          delete: {
            args: Prisma.RadiologyOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyOrderPayload>
          }
          update: {
            args: Prisma.RadiologyOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyOrderPayload>
          }
          deleteMany: {
            args: Prisma.RadiologyOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RadiologyOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RadiologyOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyOrderPayload>[]
          }
          upsert: {
            args: Prisma.RadiologyOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RadiologyOrderPayload>
          }
          aggregate: {
            args: Prisma.RadiologyOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRadiologyOrder>
          }
          groupBy: {
            args: Prisma.RadiologyOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<RadiologyOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.RadiologyOrderCountArgs<ExtArgs>
            result: $Utils.Optional<RadiologyOrderCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    department?: DepartmentOmit
    specialty?: SpecialtyOmit
    staff?: StaffOmit
    tenant?: TenantOmit
    user?: UserOmit
    refreshToken?: RefreshTokenOmit
    patient?: PatientOmit
    appointment?: AppointmentOmit
    prescription?: PrescriptionOmit
    prescriptionItem?: PrescriptionItemOmit
    medicalRecord?: MedicalRecordOmit
    invoice?: InvoiceOmit
    invoiceItem?: InvoiceItemOmit
    payment?: PaymentOmit
    labTest?: LabTestOmit
    labOrder?: LabOrderOmit
    labOrderTest?: LabOrderTestOmit
    medication?: MedicationOmit
    pharmacyOrder?: PharmacyOrderOmit
    pharmacyOrderItem?: PharmacyOrderItemOmit
    auditLog?: AuditLogOmit
    modality?: ModalityOmit
    study?: StudyOmit
    series?: SeriesOmit
    image?: ImageOmit
    radReport?: RadReportOmit
    radiationDose?: RadiationDoseOmit
    reportTemplate?: ReportTemplateOmit
    telemedicineConsultation?: TelemedicineConsultationOmit
    videoRoom?: VideoRoomOmit
    videoParticipant?: VideoParticipantOmit
    videoRecording?: VideoRecordingOmit
    videoMessage?: VideoMessageOmit
    radiologyOrder?: RadiologyOrderOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    appointments: number
    staff: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | DepartmentCountOutputTypeCountAppointmentsArgs
    staff?: boolean | DepartmentCountOutputTypeCountStaffArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
  }


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    appointments: number
    auditLogs: number
    departments: number
    invoices: number
    invoiceItems: number
    labOrders: number
    labOrderTests: number
    labTests: number
    medicalRecords: number
    medications: number
    payments: number
    pharmacyOrders: number
    pharmacyOrderItems: number
    prescriptions: number
    prescriptionItems: number
    refreshTokens: number
    specialties: number
    staff: number
    users: number
    patients: number
    studies: number
    radReports: number
    reportTemplates: number
    telemedicineConsultations: number
    videoRooms: number
    videoParticipants: number
    videoRecordings: number
    videoMessages: number
    radiologyOrders: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | TenantCountOutputTypeCountAppointmentsArgs
    auditLogs?: boolean | TenantCountOutputTypeCountAuditLogsArgs
    departments?: boolean | TenantCountOutputTypeCountDepartmentsArgs
    invoices?: boolean | TenantCountOutputTypeCountInvoicesArgs
    invoiceItems?: boolean | TenantCountOutputTypeCountInvoiceItemsArgs
    labOrders?: boolean | TenantCountOutputTypeCountLabOrdersArgs
    labOrderTests?: boolean | TenantCountOutputTypeCountLabOrderTestsArgs
    labTests?: boolean | TenantCountOutputTypeCountLabTestsArgs
    medicalRecords?: boolean | TenantCountOutputTypeCountMedicalRecordsArgs
    medications?: boolean | TenantCountOutputTypeCountMedicationsArgs
    payments?: boolean | TenantCountOutputTypeCountPaymentsArgs
    pharmacyOrders?: boolean | TenantCountOutputTypeCountPharmacyOrdersArgs
    pharmacyOrderItems?: boolean | TenantCountOutputTypeCountPharmacyOrderItemsArgs
    prescriptions?: boolean | TenantCountOutputTypeCountPrescriptionsArgs
    prescriptionItems?: boolean | TenantCountOutputTypeCountPrescriptionItemsArgs
    refreshTokens?: boolean | TenantCountOutputTypeCountRefreshTokensArgs
    specialties?: boolean | TenantCountOutputTypeCountSpecialtiesArgs
    staff?: boolean | TenantCountOutputTypeCountStaffArgs
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    patients?: boolean | TenantCountOutputTypeCountPatientsArgs
    studies?: boolean | TenantCountOutputTypeCountStudiesArgs
    radReports?: boolean | TenantCountOutputTypeCountRadReportsArgs
    reportTemplates?: boolean | TenantCountOutputTypeCountReportTemplatesArgs
    telemedicineConsultations?: boolean | TenantCountOutputTypeCountTelemedicineConsultationsArgs
    videoRooms?: boolean | TenantCountOutputTypeCountVideoRoomsArgs
    videoParticipants?: boolean | TenantCountOutputTypeCountVideoParticipantsArgs
    videoRecordings?: boolean | TenantCountOutputTypeCountVideoRecordingsArgs
    videoMessages?: boolean | TenantCountOutputTypeCountVideoMessagesArgs
    radiologyOrders?: boolean | TenantCountOutputTypeCountRadiologyOrdersArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountLabOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountLabOrderTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderTestWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountLabTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabTestWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountMedicalRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalRecordWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountMedicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPharmacyOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PharmacyOrderWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPharmacyOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PharmacyOrderItemWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPrescriptionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionItemWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSpecialtiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialtyWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountStudiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountRadReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadReportWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountReportTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportTemplateWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTelemedicineConsultationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelemedicineConsultationWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountVideoRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoRoomWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountVideoParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoParticipantWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountVideoRecordingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoRecordingWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountVideoMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoMessageWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountRadiologyOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadiologyOrderWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    doctorAppointments: number
    doctorLabOrders: number
    doctorPrescriptions: number
    prescriptions: number
    doctorTelemedicine: number
    doctorRadiologyOrders: number
    refreshTokens: number
    auditLogs: number
    createdMedicalRecords: number
    updatedMedicalRecords: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctorAppointments?: boolean | UserCountOutputTypeCountDoctorAppointmentsArgs
    doctorLabOrders?: boolean | UserCountOutputTypeCountDoctorLabOrdersArgs
    doctorPrescriptions?: boolean | UserCountOutputTypeCountDoctorPrescriptionsArgs
    prescriptions?: boolean | UserCountOutputTypeCountPrescriptionsArgs
    doctorTelemedicine?: boolean | UserCountOutputTypeCountDoctorTelemedicineArgs
    doctorRadiologyOrders?: boolean | UserCountOutputTypeCountDoctorRadiologyOrdersArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    createdMedicalRecords?: boolean | UserCountOutputTypeCountCreatedMedicalRecordsArgs
    updatedMedicalRecords?: boolean | UserCountOutputTypeCountUpdatedMedicalRecordsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDoctorAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDoctorLabOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDoctorPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PharmacyOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDoctorTelemedicineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelemedicineConsultationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDoctorRadiologyOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadiologyOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedMedicalRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedMedicalRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalRecordWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    appointments: number
    invoices: number
    labOrders: number
    medicalRecords: number
    pharmacyOrders: number
    prescriptions: number
    prescriptionItems: number
    studies: number
    telemedicineConsultations: number
    radiologyOrders: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | PatientCountOutputTypeCountAppointmentsArgs
    invoices?: boolean | PatientCountOutputTypeCountInvoicesArgs
    labOrders?: boolean | PatientCountOutputTypeCountLabOrdersArgs
    medicalRecords?: boolean | PatientCountOutputTypeCountMedicalRecordsArgs
    pharmacyOrders?: boolean | PatientCountOutputTypeCountPharmacyOrdersArgs
    prescriptions?: boolean | PatientCountOutputTypeCountPrescriptionsArgs
    prescriptionItems?: boolean | PatientCountOutputTypeCountPrescriptionItemsArgs
    studies?: boolean | PatientCountOutputTypeCountStudiesArgs
    telemedicineConsultations?: boolean | PatientCountOutputTypeCountTelemedicineConsultationsArgs
    radiologyOrders?: boolean | PatientCountOutputTypeCountRadiologyOrdersArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountLabOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountMedicalRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalRecordWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountPharmacyOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PharmacyOrderWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountPrescriptionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionItemWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountStudiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountTelemedicineConsultationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelemedicineConsultationWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountRadiologyOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadiologyOrderWhereInput
  }


  /**
   * Count Type PrescriptionCountOutputType
   */

  export type PrescriptionCountOutputType = {
    prescriptionItems: number
  }

  export type PrescriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescriptionItems?: boolean | PrescriptionCountOutputTypeCountPrescriptionItemsArgs
  }

  // Custom InputTypes
  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCountOutputType
     */
    select?: PrescriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeCountPrescriptionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionItemWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    invoiceItems: number
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoiceItems?: boolean | InvoiceCountOutputTypeCountInvoiceItemsArgs
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type LabTestCountOutputType
   */

  export type LabTestCountOutputType = {
    labOrders: number
  }

  export type LabTestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labOrders?: boolean | LabTestCountOutputTypeCountLabOrdersArgs
  }

  // Custom InputTypes
  /**
   * LabTestCountOutputType without action
   */
  export type LabTestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTestCountOutputType
     */
    select?: LabTestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabTestCountOutputType without action
   */
  export type LabTestCountOutputTypeCountLabOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderTestWhereInput
  }


  /**
   * Count Type LabOrderCountOutputType
   */

  export type LabOrderCountOutputType = {
    tests: number
  }

  export type LabOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tests?: boolean | LabOrderCountOutputTypeCountTestsArgs
  }

  // Custom InputTypes
  /**
   * LabOrderCountOutputType without action
   */
  export type LabOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderCountOutputType
     */
    select?: LabOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabOrderCountOutputType without action
   */
  export type LabOrderCountOutputTypeCountTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderTestWhereInput
  }


  /**
   * Count Type MedicationCountOutputType
   */

  export type MedicationCountOutputType = {
    pharmacyOrderItems: number
    prescriptionItems: number
  }

  export type MedicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pharmacyOrderItems?: boolean | MedicationCountOutputTypeCountPharmacyOrderItemsArgs
    prescriptionItems?: boolean | MedicationCountOutputTypeCountPrescriptionItemsArgs
  }

  // Custom InputTypes
  /**
   * MedicationCountOutputType without action
   */
  export type MedicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationCountOutputType
     */
    select?: MedicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicationCountOutputType without action
   */
  export type MedicationCountOutputTypeCountPharmacyOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PharmacyOrderItemWhereInput
  }

  /**
   * MedicationCountOutputType without action
   */
  export type MedicationCountOutputTypeCountPrescriptionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionItemWhereInput
  }


  /**
   * Count Type PharmacyOrderCountOutputType
   */

  export type PharmacyOrderCountOutputType = {
    items: number
  }

  export type PharmacyOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PharmacyOrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PharmacyOrderCountOutputType without action
   */
  export type PharmacyOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrderCountOutputType
     */
    select?: PharmacyOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PharmacyOrderCountOutputType without action
   */
  export type PharmacyOrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PharmacyOrderItemWhereInput
  }


  /**
   * Count Type ModalityCountOutputType
   */

  export type ModalityCountOutputType = {
    studies: number
    radiologyOrders: number
  }

  export type ModalityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studies?: boolean | ModalityCountOutputTypeCountStudiesArgs
    radiologyOrders?: boolean | ModalityCountOutputTypeCountRadiologyOrdersArgs
  }

  // Custom InputTypes
  /**
   * ModalityCountOutputType without action
   */
  export type ModalityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModalityCountOutputType
     */
    select?: ModalityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModalityCountOutputType without action
   */
  export type ModalityCountOutputTypeCountStudiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyWhereInput
  }

  /**
   * ModalityCountOutputType without action
   */
  export type ModalityCountOutputTypeCountRadiologyOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadiologyOrderWhereInput
  }


  /**
   * Count Type StudyCountOutputType
   */

  export type StudyCountOutputType = {
    series: number
    radReports: number
    radiationDoses: number
    radiologyOrders: number
  }

  export type StudyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | StudyCountOutputTypeCountSeriesArgs
    radReports?: boolean | StudyCountOutputTypeCountRadReportsArgs
    radiationDoses?: boolean | StudyCountOutputTypeCountRadiationDosesArgs
    radiologyOrders?: boolean | StudyCountOutputTypeCountRadiologyOrdersArgs
  }

  // Custom InputTypes
  /**
   * StudyCountOutputType without action
   */
  export type StudyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyCountOutputType
     */
    select?: StudyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudyCountOutputType without action
   */
  export type StudyCountOutputTypeCountSeriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeriesWhereInput
  }

  /**
   * StudyCountOutputType without action
   */
  export type StudyCountOutputTypeCountRadReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadReportWhereInput
  }

  /**
   * StudyCountOutputType without action
   */
  export type StudyCountOutputTypeCountRadiationDosesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadiationDoseWhereInput
  }

  /**
   * StudyCountOutputType without action
   */
  export type StudyCountOutputTypeCountRadiologyOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadiologyOrderWhereInput
  }


  /**
   * Count Type SeriesCountOutputType
   */

  export type SeriesCountOutputType = {
    images: number
  }

  export type SeriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | SeriesCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * SeriesCountOutputType without action
   */
  export type SeriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesCountOutputType
     */
    select?: SeriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeriesCountOutputType without action
   */
  export type SeriesCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
  }


  /**
   * Count Type ReportTemplateCountOutputType
   */

  export type ReportTemplateCountOutputType = {
    radReports: number
  }

  export type ReportTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    radReports?: boolean | ReportTemplateCountOutputTypeCountRadReportsArgs
  }

  // Custom InputTypes
  /**
   * ReportTemplateCountOutputType without action
   */
  export type ReportTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplateCountOutputType
     */
    select?: ReportTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReportTemplateCountOutputType without action
   */
  export type ReportTemplateCountOutputTypeCountRadReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadReportWhereInput
  }


  /**
   * Count Type TelemedicineConsultationCountOutputType
   */

  export type TelemedicineConsultationCountOutputType = {
    labOrders: number
    radiologyOrders: number
  }

  export type TelemedicineConsultationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labOrders?: boolean | TelemedicineConsultationCountOutputTypeCountLabOrdersArgs
    radiologyOrders?: boolean | TelemedicineConsultationCountOutputTypeCountRadiologyOrdersArgs
  }

  // Custom InputTypes
  /**
   * TelemedicineConsultationCountOutputType without action
   */
  export type TelemedicineConsultationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelemedicineConsultationCountOutputType
     */
    select?: TelemedicineConsultationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TelemedicineConsultationCountOutputType without action
   */
  export type TelemedicineConsultationCountOutputTypeCountLabOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderWhereInput
  }

  /**
   * TelemedicineConsultationCountOutputType without action
   */
  export type TelemedicineConsultationCountOutputTypeCountRadiologyOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadiologyOrderWhereInput
  }


  /**
   * Count Type VideoRoomCountOutputType
   */

  export type VideoRoomCountOutputType = {
    participants: number
    recordings: number
  }

  export type VideoRoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | VideoRoomCountOutputTypeCountParticipantsArgs
    recordings?: boolean | VideoRoomCountOutputTypeCountRecordingsArgs
  }

  // Custom InputTypes
  /**
   * VideoRoomCountOutputType without action
   */
  export type VideoRoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoomCountOutputType
     */
    select?: VideoRoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VideoRoomCountOutputType without action
   */
  export type VideoRoomCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoParticipantWhereInput
  }

  /**
   * VideoRoomCountOutputType without action
   */
  export type VideoRoomCountOutputTypeCountRecordingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoRecordingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    isActive: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    name: string
    code: string | null
    description: string | null
    isActive: boolean
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appointments?: boolean | Department$appointmentsArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    staff?: boolean | Department$staffArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "description" | "isActive" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | Department$appointmentsArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    staff?: boolean | Department$staffArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs>
      staff: Prisma.$StaffPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string | null
      description: string | null
      isActive: boolean
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends Department$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Department$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    staff<T extends Department$staffArgs<ExtArgs> = {}>(args?: Subset<T, Department$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly code: FieldRef<"Department", 'String'>
    readonly description: FieldRef<"Department", 'String'>
    readonly isActive: FieldRef<"Department", 'Boolean'>
    readonly tenantId: FieldRef<"Department", 'String'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.appointments
   */
  export type Department$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Department.staff
   */
  export type Department$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    cursor?: StaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Specialty
   */

  export type AggregateSpecialty = {
    _count: SpecialtyCountAggregateOutputType | null
    _min: SpecialtyMinAggregateOutputType | null
    _max: SpecialtyMaxAggregateOutputType | null
  }

  export type SpecialtyMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpecialtyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpecialtyCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    isActive: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SpecialtyMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpecialtyMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpecialtyCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SpecialtyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Specialty to aggregate.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Specialties
    **/
    _count?: true | SpecialtyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecialtyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecialtyMaxAggregateInputType
  }

  export type GetSpecialtyAggregateType<T extends SpecialtyAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecialty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecialty[P]>
      : GetScalarType<T[P], AggregateSpecialty[P]>
  }




  export type SpecialtyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpecialtyWhereInput
    orderBy?: SpecialtyOrderByWithAggregationInput | SpecialtyOrderByWithAggregationInput[]
    by: SpecialtyScalarFieldEnum[] | SpecialtyScalarFieldEnum
    having?: SpecialtyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecialtyCountAggregateInputType | true
    _min?: SpecialtyMinAggregateInputType
    _max?: SpecialtyMaxAggregateInputType
  }

  export type SpecialtyGroupByOutputType = {
    id: string
    name: string
    code: string | null
    description: string | null
    isActive: boolean
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: SpecialtyCountAggregateOutputType | null
    _min: SpecialtyMinAggregateOutputType | null
    _max: SpecialtyMaxAggregateOutputType | null
  }

  type GetSpecialtyGroupByPayload<T extends SpecialtyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpecialtyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecialtyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecialtyGroupByOutputType[P]>
            : GetScalarType<T[P], SpecialtyGroupByOutputType[P]>
        }
      >
    >


  export type SpecialtySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specialty"]>

  export type SpecialtySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specialty"]>

  export type SpecialtySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["specialty"]>

  export type SpecialtySelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SpecialtyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "description" | "isActive" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["specialty"]>
  export type SpecialtyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type SpecialtyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type SpecialtyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $SpecialtyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Specialty"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string | null
      description: string | null
      isActive: boolean
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["specialty"]>
    composites: {}
  }

  type SpecialtyGetPayload<S extends boolean | null | undefined | SpecialtyDefaultArgs> = $Result.GetResult<Prisma.$SpecialtyPayload, S>

  type SpecialtyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpecialtyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpecialtyCountAggregateInputType | true
    }

  export interface SpecialtyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Specialty'], meta: { name: 'Specialty' } }
    /**
     * Find zero or one Specialty that matches the filter.
     * @param {SpecialtyFindUniqueArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpecialtyFindUniqueArgs>(args: SelectSubset<T, SpecialtyFindUniqueArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Specialty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpecialtyFindUniqueOrThrowArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpecialtyFindUniqueOrThrowArgs>(args: SelectSubset<T, SpecialtyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Specialty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyFindFirstArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpecialtyFindFirstArgs>(args?: SelectSubset<T, SpecialtyFindFirstArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Specialty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyFindFirstOrThrowArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpecialtyFindFirstOrThrowArgs>(args?: SelectSubset<T, SpecialtyFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Specialties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Specialties
     * const specialties = await prisma.specialty.findMany()
     * 
     * // Get first 10 Specialties
     * const specialties = await prisma.specialty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specialtyWithIdOnly = await prisma.specialty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpecialtyFindManyArgs>(args?: SelectSubset<T, SpecialtyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Specialty.
     * @param {SpecialtyCreateArgs} args - Arguments to create a Specialty.
     * @example
     * // Create one Specialty
     * const Specialty = await prisma.specialty.create({
     *   data: {
     *     // ... data to create a Specialty
     *   }
     * })
     * 
     */
    create<T extends SpecialtyCreateArgs>(args: SelectSubset<T, SpecialtyCreateArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Specialties.
     * @param {SpecialtyCreateManyArgs} args - Arguments to create many Specialties.
     * @example
     * // Create many Specialties
     * const specialty = await prisma.specialty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpecialtyCreateManyArgs>(args?: SelectSubset<T, SpecialtyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Specialties and returns the data saved in the database.
     * @param {SpecialtyCreateManyAndReturnArgs} args - Arguments to create many Specialties.
     * @example
     * // Create many Specialties
     * const specialty = await prisma.specialty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Specialties and only return the `id`
     * const specialtyWithIdOnly = await prisma.specialty.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpecialtyCreateManyAndReturnArgs>(args?: SelectSubset<T, SpecialtyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Specialty.
     * @param {SpecialtyDeleteArgs} args - Arguments to delete one Specialty.
     * @example
     * // Delete one Specialty
     * const Specialty = await prisma.specialty.delete({
     *   where: {
     *     // ... filter to delete one Specialty
     *   }
     * })
     * 
     */
    delete<T extends SpecialtyDeleteArgs>(args: SelectSubset<T, SpecialtyDeleteArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Specialty.
     * @param {SpecialtyUpdateArgs} args - Arguments to update one Specialty.
     * @example
     * // Update one Specialty
     * const specialty = await prisma.specialty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpecialtyUpdateArgs>(args: SelectSubset<T, SpecialtyUpdateArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Specialties.
     * @param {SpecialtyDeleteManyArgs} args - Arguments to filter Specialties to delete.
     * @example
     * // Delete a few Specialties
     * const { count } = await prisma.specialty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpecialtyDeleteManyArgs>(args?: SelectSubset<T, SpecialtyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Specialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Specialties
     * const specialty = await prisma.specialty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpecialtyUpdateManyArgs>(args: SelectSubset<T, SpecialtyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Specialties and returns the data updated in the database.
     * @param {SpecialtyUpdateManyAndReturnArgs} args - Arguments to update many Specialties.
     * @example
     * // Update many Specialties
     * const specialty = await prisma.specialty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Specialties and only return the `id`
     * const specialtyWithIdOnly = await prisma.specialty.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpecialtyUpdateManyAndReturnArgs>(args: SelectSubset<T, SpecialtyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Specialty.
     * @param {SpecialtyUpsertArgs} args - Arguments to update or create a Specialty.
     * @example
     * // Update or create a Specialty
     * const specialty = await prisma.specialty.upsert({
     *   create: {
     *     // ... data to create a Specialty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Specialty we want to update
     *   }
     * })
     */
    upsert<T extends SpecialtyUpsertArgs>(args: SelectSubset<T, SpecialtyUpsertArgs<ExtArgs>>): Prisma__SpecialtyClient<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Specialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyCountArgs} args - Arguments to filter Specialties to count.
     * @example
     * // Count the number of Specialties
     * const count = await prisma.specialty.count({
     *   where: {
     *     // ... the filter for the Specialties we want to count
     *   }
     * })
    **/
    count<T extends SpecialtyCountArgs>(
      args?: Subset<T, SpecialtyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecialtyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Specialty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecialtyAggregateArgs>(args: Subset<T, SpecialtyAggregateArgs>): Prisma.PrismaPromise<GetSpecialtyAggregateType<T>>

    /**
     * Group by Specialty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecialtyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecialtyGroupByArgs['orderBy'] }
        : { orderBy?: SpecialtyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecialtyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecialtyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Specialty model
   */
  readonly fields: SpecialtyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Specialty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpecialtyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Specialty model
   */
  interface SpecialtyFieldRefs {
    readonly id: FieldRef<"Specialty", 'String'>
    readonly name: FieldRef<"Specialty", 'String'>
    readonly code: FieldRef<"Specialty", 'String'>
    readonly description: FieldRef<"Specialty", 'String'>
    readonly isActive: FieldRef<"Specialty", 'Boolean'>
    readonly tenantId: FieldRef<"Specialty", 'String'>
    readonly createdAt: FieldRef<"Specialty", 'DateTime'>
    readonly updatedAt: FieldRef<"Specialty", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Specialty findUnique
   */
  export type SpecialtyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where: SpecialtyWhereUniqueInput
  }

  /**
   * Specialty findUniqueOrThrow
   */
  export type SpecialtyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where: SpecialtyWhereUniqueInput
  }

  /**
   * Specialty findFirst
   */
  export type SpecialtyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Specialties.
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Specialties.
     */
    distinct?: SpecialtyScalarFieldEnum | SpecialtyScalarFieldEnum[]
  }

  /**
   * Specialty findFirstOrThrow
   */
  export type SpecialtyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Specialties.
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Specialties.
     */
    distinct?: SpecialtyScalarFieldEnum | SpecialtyScalarFieldEnum[]
  }

  /**
   * Specialty findMany
   */
  export type SpecialtyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialties to fetch.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Specialties.
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    distinct?: SpecialtyScalarFieldEnum | SpecialtyScalarFieldEnum[]
  }

  /**
   * Specialty create
   */
  export type SpecialtyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * The data needed to create a Specialty.
     */
    data: XOR<SpecialtyCreateInput, SpecialtyUncheckedCreateInput>
  }

  /**
   * Specialty createMany
   */
  export type SpecialtyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Specialties.
     */
    data: SpecialtyCreateManyInput | SpecialtyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Specialty createManyAndReturn
   */
  export type SpecialtyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * The data used to create many Specialties.
     */
    data: SpecialtyCreateManyInput | SpecialtyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Specialty update
   */
  export type SpecialtyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * The data needed to update a Specialty.
     */
    data: XOR<SpecialtyUpdateInput, SpecialtyUncheckedUpdateInput>
    /**
     * Choose, which Specialty to update.
     */
    where: SpecialtyWhereUniqueInput
  }

  /**
   * Specialty updateMany
   */
  export type SpecialtyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Specialties.
     */
    data: XOR<SpecialtyUpdateManyMutationInput, SpecialtyUncheckedUpdateManyInput>
    /**
     * Filter which Specialties to update
     */
    where?: SpecialtyWhereInput
    /**
     * Limit how many Specialties to update.
     */
    limit?: number
  }

  /**
   * Specialty updateManyAndReturn
   */
  export type SpecialtyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * The data used to update Specialties.
     */
    data: XOR<SpecialtyUpdateManyMutationInput, SpecialtyUncheckedUpdateManyInput>
    /**
     * Filter which Specialties to update
     */
    where?: SpecialtyWhereInput
    /**
     * Limit how many Specialties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Specialty upsert
   */
  export type SpecialtyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * The filter to search for the Specialty to update in case it exists.
     */
    where: SpecialtyWhereUniqueInput
    /**
     * In case the Specialty found by the `where` argument doesn't exist, create a new Specialty with this data.
     */
    create: XOR<SpecialtyCreateInput, SpecialtyUncheckedCreateInput>
    /**
     * In case the Specialty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpecialtyUpdateInput, SpecialtyUncheckedUpdateInput>
  }

  /**
   * Specialty delete
   */
  export type SpecialtyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter which Specialty to delete.
     */
    where: SpecialtyWhereUniqueInput
  }

  /**
   * Specialty deleteMany
   */
  export type SpecialtyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Specialties to delete
     */
    where?: SpecialtyWhereInput
    /**
     * Limit how many Specialties to delete.
     */
    limit?: number
  }

  /**
   * Specialty without action
   */
  export type SpecialtyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
  }


  /**
   * Model Staff
   */

  export type AggregateStaff = {
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  export type StaffMinAggregateOutputType = {
    id: string | null
    userId: string | null
    employeeId: string | null
    designation: string | null
    departmentId: string | null
    joiningDate: Date | null
    qualification: string | null
    experience: string | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    employeeId: string | null
    designation: string | null
    departmentId: string | null
    joiningDate: Date | null
    qualification: string | null
    experience: string | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffCountAggregateOutputType = {
    id: number
    userId: number
    employeeId: number
    designation: number
    departmentId: number
    joiningDate: number
    qualification: number
    experience: number
    isActive: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffMinAggregateInputType = {
    id?: true
    userId?: true
    employeeId?: true
    designation?: true
    departmentId?: true
    joiningDate?: true
    qualification?: true
    experience?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffMaxAggregateInputType = {
    id?: true
    userId?: true
    employeeId?: true
    designation?: true
    departmentId?: true
    joiningDate?: true
    qualification?: true
    experience?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffCountAggregateInputType = {
    id?: true
    userId?: true
    employeeId?: true
    designation?: true
    departmentId?: true
    joiningDate?: true
    qualification?: true
    experience?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to aggregate.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Staff
    **/
    _count?: true | StaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffMaxAggregateInputType
  }

  export type GetStaffAggregateType<T extends StaffAggregateArgs> = {
        [P in keyof T & keyof AggregateStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaff[P]>
      : GetScalarType<T[P], AggregateStaff[P]>
  }




  export type StaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithAggregationInput | StaffOrderByWithAggregationInput[]
    by: StaffScalarFieldEnum[] | StaffScalarFieldEnum
    having?: StaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffCountAggregateInputType | true
    _min?: StaffMinAggregateInputType
    _max?: StaffMaxAggregateInputType
  }

  export type StaffGroupByOutputType = {
    id: string
    userId: string
    employeeId: string | null
    designation: string | null
    departmentId: string | null
    joiningDate: Date | null
    qualification: string | null
    experience: string | null
    isActive: boolean
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: StaffCountAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  type GetStaffGroupByPayload<T extends StaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffGroupByOutputType[P]>
            : GetScalarType<T[P], StaffGroupByOutputType[P]>
        }
      >
    >


  export type StaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employeeId?: boolean
    designation?: boolean
    departmentId?: boolean
    joiningDate?: boolean
    qualification?: boolean
    experience?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    department?: boolean | Staff$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employeeId?: boolean
    designation?: boolean
    departmentId?: boolean
    joiningDate?: boolean
    qualification?: boolean
    experience?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    department?: boolean | Staff$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employeeId?: boolean
    designation?: boolean
    departmentId?: boolean
    joiningDate?: boolean
    qualification?: boolean
    experience?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    department?: boolean | Staff$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectScalar = {
    id?: boolean
    userId?: boolean
    employeeId?: boolean
    designation?: boolean
    departmentId?: boolean
    joiningDate?: boolean
    qualification?: boolean
    experience?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "employeeId" | "designation" | "departmentId" | "joiningDate" | "qualification" | "experience" | "isActive" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["staff"]>
  export type StaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    department?: boolean | Staff$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    department?: boolean | Staff$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StaffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    department?: boolean | Staff$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Staff"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      employeeId: string | null
      designation: string | null
      departmentId: string | null
      joiningDate: Date | null
      qualification: string | null
      experience: string | null
      isActive: boolean
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["staff"]>
    composites: {}
  }

  type StaffGetPayload<S extends boolean | null | undefined | StaffDefaultArgs> = $Result.GetResult<Prisma.$StaffPayload, S>

  type StaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StaffCountAggregateInputType | true
    }

  export interface StaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Staff'], meta: { name: 'Staff' } }
    /**
     * Find zero or one Staff that matches the filter.
     * @param {StaffFindUniqueArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffFindUniqueArgs>(args: SelectSubset<T, StaffFindUniqueArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Staff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaffFindUniqueOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffFindFirstArgs>(args?: SelectSubset<T, StaffFindFirstArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Staff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Staff
     * const staff = await prisma.staff.findMany()
     * 
     * // Get first 10 Staff
     * const staff = await prisma.staff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffWithIdOnly = await prisma.staff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffFindManyArgs>(args?: SelectSubset<T, StaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Staff.
     * @param {StaffCreateArgs} args - Arguments to create a Staff.
     * @example
     * // Create one Staff
     * const Staff = await prisma.staff.create({
     *   data: {
     *     // ... data to create a Staff
     *   }
     * })
     * 
     */
    create<T extends StaffCreateArgs>(args: SelectSubset<T, StaffCreateArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Staff.
     * @param {StaffCreateManyArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffCreateManyArgs>(args?: SelectSubset<T, StaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Staff and returns the data saved in the database.
     * @param {StaffCreateManyAndReturnArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Staff and only return the `id`
     * const staffWithIdOnly = await prisma.staff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Staff.
     * @param {StaffDeleteArgs} args - Arguments to delete one Staff.
     * @example
     * // Delete one Staff
     * const Staff = await prisma.staff.delete({
     *   where: {
     *     // ... filter to delete one Staff
     *   }
     * })
     * 
     */
    delete<T extends StaffDeleteArgs>(args: SelectSubset<T, StaffDeleteArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Staff.
     * @param {StaffUpdateArgs} args - Arguments to update one Staff.
     * @example
     * // Update one Staff
     * const staff = await prisma.staff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffUpdateArgs>(args: SelectSubset<T, StaffUpdateArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Staff.
     * @param {StaffDeleteManyArgs} args - Arguments to filter Staff to delete.
     * @example
     * // Delete a few Staff
     * const { count } = await prisma.staff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffDeleteManyArgs>(args?: SelectSubset<T, StaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffUpdateManyArgs>(args: SelectSubset<T, StaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff and returns the data updated in the database.
     * @param {StaffUpdateManyAndReturnArgs} args - Arguments to update many Staff.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Staff and only return the `id`
     * const staffWithIdOnly = await prisma.staff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StaffUpdateManyAndReturnArgs>(args: SelectSubset<T, StaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Staff.
     * @param {StaffUpsertArgs} args - Arguments to update or create a Staff.
     * @example
     * // Update or create a Staff
     * const staff = await prisma.staff.upsert({
     *   create: {
     *     // ... data to create a Staff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Staff we want to update
     *   }
     * })
     */
    upsert<T extends StaffUpsertArgs>(args: SelectSubset<T, StaffUpsertArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffCountArgs} args - Arguments to filter Staff to count.
     * @example
     * // Count the number of Staff
     * const count = await prisma.staff.count({
     *   where: {
     *     // ... the filter for the Staff we want to count
     *   }
     * })
    **/
    count<T extends StaffCountArgs>(
      args?: Subset<T, StaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffAggregateArgs>(args: Subset<T, StaffAggregateArgs>): Prisma.PrismaPromise<GetStaffAggregateType<T>>

    /**
     * Group by Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffGroupByArgs['orderBy'] }
        : { orderBy?: StaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Staff model
   */
  readonly fields: StaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Staff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    department<T extends Staff$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Staff$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Staff model
   */
  interface StaffFieldRefs {
    readonly id: FieldRef<"Staff", 'String'>
    readonly userId: FieldRef<"Staff", 'String'>
    readonly employeeId: FieldRef<"Staff", 'String'>
    readonly designation: FieldRef<"Staff", 'String'>
    readonly departmentId: FieldRef<"Staff", 'String'>
    readonly joiningDate: FieldRef<"Staff", 'DateTime'>
    readonly qualification: FieldRef<"Staff", 'String'>
    readonly experience: FieldRef<"Staff", 'String'>
    readonly isActive: FieldRef<"Staff", 'Boolean'>
    readonly tenantId: FieldRef<"Staff", 'String'>
    readonly createdAt: FieldRef<"Staff", 'DateTime'>
    readonly updatedAt: FieldRef<"Staff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Staff findUnique
   */
  export type StaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findUniqueOrThrow
   */
  export type StaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findFirst
   */
  export type StaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff findFirstOrThrow
   */
  export type StaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff findMany
   */
  export type StaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff create
   */
  export type StaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to create a Staff.
     */
    data: XOR<StaffCreateInput, StaffUncheckedCreateInput>
  }

  /**
   * Staff createMany
   */
  export type StaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Staff createManyAndReturn
   */
  export type StaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Staff update
   */
  export type StaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to update a Staff.
     */
    data: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
    /**
     * Choose, which Staff to update.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff updateMany
   */
  export type StaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to update.
     */
    limit?: number
  }

  /**
   * Staff updateManyAndReturn
   */
  export type StaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Staff upsert
   */
  export type StaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The filter to search for the Staff to update in case it exists.
     */
    where: StaffWhereUniqueInput
    /**
     * In case the Staff found by the `where` argument doesn't exist, create a new Staff with this data.
     */
    create: XOR<StaffCreateInput, StaffUncheckedCreateInput>
    /**
     * In case the Staff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
  }

  /**
   * Staff delete
   */
  export type StaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter which Staff to delete.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff deleteMany
   */
  export type StaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to delete
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to delete.
     */
    limit?: number
  }

  /**
   * Staff.department
   */
  export type Staff$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Staff without action
   */
  export type StaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
  }


  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    type: $Enums.TenantType | null
    address: string | null
    phone: string | null
    email: string | null
    logo: string | null
    deletedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    type: $Enums.TenantType | null
    address: string | null
    phone: string | null
    email: string | null
    logo: string | null
    deletedAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    type: number
    address: number
    phone: number
    email: number
    logo: number
    deletedAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    type?: true
    address?: true
    phone?: true
    email?: true
    logo?: true
    deletedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    type?: true
    address?: true
    phone?: true
    email?: true
    logo?: true
    deletedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    type?: true
    address?: true
    phone?: true
    email?: true
    logo?: true
    deletedAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    slug: string
    type: $Enums.TenantType
    address: string | null
    phone: string | null
    email: string | null
    logo: string | null
    deletedAt: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    type?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    logo?: boolean
    deletedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appointments?: boolean | Tenant$appointmentsArgs<ExtArgs>
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    departments?: boolean | Tenant$departmentsArgs<ExtArgs>
    invoices?: boolean | Tenant$invoicesArgs<ExtArgs>
    invoiceItems?: boolean | Tenant$invoiceItemsArgs<ExtArgs>
    labOrders?: boolean | Tenant$labOrdersArgs<ExtArgs>
    labOrderTests?: boolean | Tenant$labOrderTestsArgs<ExtArgs>
    labTests?: boolean | Tenant$labTestsArgs<ExtArgs>
    medicalRecords?: boolean | Tenant$medicalRecordsArgs<ExtArgs>
    medications?: boolean | Tenant$medicationsArgs<ExtArgs>
    payments?: boolean | Tenant$paymentsArgs<ExtArgs>
    pharmacyOrders?: boolean | Tenant$pharmacyOrdersArgs<ExtArgs>
    pharmacyOrderItems?: boolean | Tenant$pharmacyOrderItemsArgs<ExtArgs>
    prescriptions?: boolean | Tenant$prescriptionsArgs<ExtArgs>
    prescriptionItems?: boolean | Tenant$prescriptionItemsArgs<ExtArgs>
    refreshTokens?: boolean | Tenant$refreshTokensArgs<ExtArgs>
    specialties?: boolean | Tenant$specialtiesArgs<ExtArgs>
    staff?: boolean | Tenant$staffArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    patients?: boolean | Tenant$patientsArgs<ExtArgs>
    studies?: boolean | Tenant$studiesArgs<ExtArgs>
    radReports?: boolean | Tenant$radReportsArgs<ExtArgs>
    reportTemplates?: boolean | Tenant$reportTemplatesArgs<ExtArgs>
    telemedicineConsultations?: boolean | Tenant$telemedicineConsultationsArgs<ExtArgs>
    videoRooms?: boolean | Tenant$videoRoomsArgs<ExtArgs>
    videoParticipants?: boolean | Tenant$videoParticipantsArgs<ExtArgs>
    videoRecordings?: boolean | Tenant$videoRecordingsArgs<ExtArgs>
    videoMessages?: boolean | Tenant$videoMessagesArgs<ExtArgs>
    radiologyOrders?: boolean | Tenant$radiologyOrdersArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    type?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    logo?: boolean
    deletedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    type?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    logo?: boolean
    deletedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    type?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    logo?: boolean
    deletedAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "type" | "address" | "phone" | "email" | "logo" | "deletedAt" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | Tenant$appointmentsArgs<ExtArgs>
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    departments?: boolean | Tenant$departmentsArgs<ExtArgs>
    invoices?: boolean | Tenant$invoicesArgs<ExtArgs>
    invoiceItems?: boolean | Tenant$invoiceItemsArgs<ExtArgs>
    labOrders?: boolean | Tenant$labOrdersArgs<ExtArgs>
    labOrderTests?: boolean | Tenant$labOrderTestsArgs<ExtArgs>
    labTests?: boolean | Tenant$labTestsArgs<ExtArgs>
    medicalRecords?: boolean | Tenant$medicalRecordsArgs<ExtArgs>
    medications?: boolean | Tenant$medicationsArgs<ExtArgs>
    payments?: boolean | Tenant$paymentsArgs<ExtArgs>
    pharmacyOrders?: boolean | Tenant$pharmacyOrdersArgs<ExtArgs>
    pharmacyOrderItems?: boolean | Tenant$pharmacyOrderItemsArgs<ExtArgs>
    prescriptions?: boolean | Tenant$prescriptionsArgs<ExtArgs>
    prescriptionItems?: boolean | Tenant$prescriptionItemsArgs<ExtArgs>
    refreshTokens?: boolean | Tenant$refreshTokensArgs<ExtArgs>
    specialties?: boolean | Tenant$specialtiesArgs<ExtArgs>
    staff?: boolean | Tenant$staffArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    patients?: boolean | Tenant$patientsArgs<ExtArgs>
    studies?: boolean | Tenant$studiesArgs<ExtArgs>
    radReports?: boolean | Tenant$radReportsArgs<ExtArgs>
    reportTemplates?: boolean | Tenant$reportTemplatesArgs<ExtArgs>
    telemedicineConsultations?: boolean | Tenant$telemedicineConsultationsArgs<ExtArgs>
    videoRooms?: boolean | Tenant$videoRoomsArgs<ExtArgs>
    videoParticipants?: boolean | Tenant$videoParticipantsArgs<ExtArgs>
    videoRecordings?: boolean | Tenant$videoRecordingsArgs<ExtArgs>
    videoMessages?: boolean | Tenant$videoMessagesArgs<ExtArgs>
    radiologyOrders?: boolean | Tenant$radiologyOrdersArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      departments: Prisma.$DepartmentPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      invoiceItems: Prisma.$InvoiceItemPayload<ExtArgs>[]
      labOrders: Prisma.$LabOrderPayload<ExtArgs>[]
      labOrderTests: Prisma.$LabOrderTestPayload<ExtArgs>[]
      labTests: Prisma.$LabTestPayload<ExtArgs>[]
      medicalRecords: Prisma.$MedicalRecordPayload<ExtArgs>[]
      medications: Prisma.$MedicationPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      pharmacyOrders: Prisma.$PharmacyOrderPayload<ExtArgs>[]
      pharmacyOrderItems: Prisma.$PharmacyOrderItemPayload<ExtArgs>[]
      prescriptions: Prisma.$PrescriptionPayload<ExtArgs>[]
      prescriptionItems: Prisma.$PrescriptionItemPayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      specialties: Prisma.$SpecialtyPayload<ExtArgs>[]
      staff: Prisma.$StaffPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      patients: Prisma.$PatientPayload<ExtArgs>[]
      studies: Prisma.$StudyPayload<ExtArgs>[]
      radReports: Prisma.$RadReportPayload<ExtArgs>[]
      reportTemplates: Prisma.$ReportTemplatePayload<ExtArgs>[]
      telemedicineConsultations: Prisma.$TelemedicineConsultationPayload<ExtArgs>[]
      videoRooms: Prisma.$VideoRoomPayload<ExtArgs>[]
      videoParticipants: Prisma.$VideoParticipantPayload<ExtArgs>[]
      videoRecordings: Prisma.$VideoRecordingPayload<ExtArgs>[]
      videoMessages: Prisma.$VideoMessagePayload<ExtArgs>[]
      radiologyOrders: Prisma.$RadiologyOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      type: $Enums.TenantType
      address: string | null
      phone: string | null
      email: string | null
      logo: string | null
      deletedAt: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends Tenant$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Tenant$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departments<T extends Tenant$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Tenant$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoiceItems<T extends Tenant$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labOrders<T extends Tenant$labOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$labOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labOrderTests<T extends Tenant$labOrderTestsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$labOrderTestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labTests<T extends Tenant$labTestsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$labTestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicalRecords<T extends Tenant$medicalRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$medicalRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medications<T extends Tenant$medicationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$medicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Tenant$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pharmacyOrders<T extends Tenant$pharmacyOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$pharmacyOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PharmacyOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pharmacyOrderItems<T extends Tenant$pharmacyOrderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$pharmacyOrderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PharmacyOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prescriptions<T extends Tenant$prescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$prescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prescriptionItems<T extends Tenant$prescriptionItemsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$prescriptionItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refreshTokens<T extends Tenant$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    specialties<T extends Tenant$specialtiesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$specialtiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpecialtyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staff<T extends Tenant$staffArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    patients<T extends Tenant$patientsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$patientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studies<T extends Tenant$studiesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$studiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    radReports<T extends Tenant$radReportsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$radReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportTemplates<T extends Tenant$reportTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$reportTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    telemedicineConsultations<T extends Tenant$telemedicineConsultationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$telemedicineConsultationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelemedicineConsultationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    videoRooms<T extends Tenant$videoRoomsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$videoRoomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    videoParticipants<T extends Tenant$videoParticipantsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$videoParticipantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    videoRecordings<T extends Tenant$videoRecordingsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$videoRecordingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoRecordingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    videoMessages<T extends Tenant$videoMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$videoMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    radiologyOrders<T extends Tenant$radiologyOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$radiologyOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiologyOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly slug: FieldRef<"Tenant", 'String'>
    readonly type: FieldRef<"Tenant", 'TenantType'>
    readonly address: FieldRef<"Tenant", 'String'>
    readonly phone: FieldRef<"Tenant", 'String'>
    readonly email: FieldRef<"Tenant", 'String'>
    readonly logo: FieldRef<"Tenant", 'String'>
    readonly deletedAt: FieldRef<"Tenant", 'DateTime'>
    readonly isActive: FieldRef<"Tenant", 'Boolean'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.appointments
   */
  export type Tenant$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Tenant.auditLogs
   */
  export type Tenant$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Tenant.departments
   */
  export type Tenant$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Tenant.invoices
   */
  export type Tenant$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Tenant.invoiceItems
   */
  export type Tenant$invoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Tenant.labOrders
   */
  export type Tenant$labOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    where?: LabOrderWhereInput
    orderBy?: LabOrderOrderByWithRelationInput | LabOrderOrderByWithRelationInput[]
    cursor?: LabOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabOrderScalarFieldEnum | LabOrderScalarFieldEnum[]
  }

  /**
   * Tenant.labOrderTests
   */
  export type Tenant$labOrderTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    where?: LabOrderTestWhereInput
    orderBy?: LabOrderTestOrderByWithRelationInput | LabOrderTestOrderByWithRelationInput[]
    cursor?: LabOrderTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabOrderTestScalarFieldEnum | LabOrderTestScalarFieldEnum[]
  }

  /**
   * Tenant.labTests
   */
  export type Tenant$labTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    where?: LabTestWhereInput
    orderBy?: LabTestOrderByWithRelationInput | LabTestOrderByWithRelationInput[]
    cursor?: LabTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabTestScalarFieldEnum | LabTestScalarFieldEnum[]
  }

  /**
   * Tenant.medicalRecords
   */
  export type Tenant$medicalRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    where?: MedicalRecordWhereInput
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    cursor?: MedicalRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalRecordScalarFieldEnum | MedicalRecordScalarFieldEnum[]
  }

  /**
   * Tenant.medications
   */
  export type Tenant$medicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    where?: MedicationWhereInput
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    cursor?: MedicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Tenant.payments
   */
  export type Tenant$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Tenant.pharmacyOrders
   */
  export type Tenant$pharmacyOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrder
     */
    select?: PharmacyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrder
     */
    omit?: PharmacyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderInclude<ExtArgs> | null
    where?: PharmacyOrderWhereInput
    orderBy?: PharmacyOrderOrderByWithRelationInput | PharmacyOrderOrderByWithRelationInput[]
    cursor?: PharmacyOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PharmacyOrderScalarFieldEnum | PharmacyOrderScalarFieldEnum[]
  }

  /**
   * Tenant.pharmacyOrderItems
   */
  export type Tenant$pharmacyOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrderItem
     */
    select?: PharmacyOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrderItem
     */
    omit?: PharmacyOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderItemInclude<ExtArgs> | null
    where?: PharmacyOrderItemWhereInput
    orderBy?: PharmacyOrderItemOrderByWithRelationInput | PharmacyOrderItemOrderByWithRelationInput[]
    cursor?: PharmacyOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PharmacyOrderItemScalarFieldEnum | PharmacyOrderItemScalarFieldEnum[]
  }

  /**
   * Tenant.prescriptions
   */
  export type Tenant$prescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Tenant.prescriptionItems
   */
  export type Tenant$prescriptionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    where?: PrescriptionItemWhereInput
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    cursor?: PrescriptionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * Tenant.refreshTokens
   */
  export type Tenant$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * Tenant.specialties
   */
  export type Tenant$specialtiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Specialty
     */
    omit?: SpecialtyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpecialtyInclude<ExtArgs> | null
    where?: SpecialtyWhereInput
    orderBy?: SpecialtyOrderByWithRelationInput | SpecialtyOrderByWithRelationInput[]
    cursor?: SpecialtyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpecialtyScalarFieldEnum | SpecialtyScalarFieldEnum[]
  }

  /**
   * Tenant.staff
   */
  export type Tenant$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    cursor?: StaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.patients
   */
  export type Tenant$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    cursor?: PatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Tenant.studies
   */
  export type Tenant$studiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    where?: StudyWhereInput
    orderBy?: StudyOrderByWithRelationInput | StudyOrderByWithRelationInput[]
    cursor?: StudyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudyScalarFieldEnum | StudyScalarFieldEnum[]
  }

  /**
   * Tenant.radReports
   */
  export type Tenant$radReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadReport
     */
    select?: RadReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadReport
     */
    omit?: RadReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadReportInclude<ExtArgs> | null
    where?: RadReportWhereInput
    orderBy?: RadReportOrderByWithRelationInput | RadReportOrderByWithRelationInput[]
    cursor?: RadReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RadReportScalarFieldEnum | RadReportScalarFieldEnum[]
  }

  /**
   * Tenant.reportTemplates
   */
  export type Tenant$reportTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    where?: ReportTemplateWhereInput
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    cursor?: ReportTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportTemplateScalarFieldEnum | ReportTemplateScalarFieldEnum[]
  }

  /**
   * Tenant.telemedicineConsultations
   */
  export type Tenant$telemedicineConsultationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelemedicineConsultation
     */
    select?: TelemedicineConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelemedicineConsultation
     */
    omit?: TelemedicineConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemedicineConsultationInclude<ExtArgs> | null
    where?: TelemedicineConsultationWhereInput
    orderBy?: TelemedicineConsultationOrderByWithRelationInput | TelemedicineConsultationOrderByWithRelationInput[]
    cursor?: TelemedicineConsultationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TelemedicineConsultationScalarFieldEnum | TelemedicineConsultationScalarFieldEnum[]
  }

  /**
   * Tenant.videoRooms
   */
  export type Tenant$videoRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRoom
     */
    omit?: VideoRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    where?: VideoRoomWhereInput
    orderBy?: VideoRoomOrderByWithRelationInput | VideoRoomOrderByWithRelationInput[]
    cursor?: VideoRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoRoomScalarFieldEnum | VideoRoomScalarFieldEnum[]
  }

  /**
   * Tenant.videoParticipants
   */
  export type Tenant$videoParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoParticipant
     */
    omit?: VideoParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
    where?: VideoParticipantWhereInput
    orderBy?: VideoParticipantOrderByWithRelationInput | VideoParticipantOrderByWithRelationInput[]
    cursor?: VideoParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoParticipantScalarFieldEnum | VideoParticipantScalarFieldEnum[]
  }

  /**
   * Tenant.videoRecordings
   */
  export type Tenant$videoRecordingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRecording
     */
    select?: VideoRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRecording
     */
    omit?: VideoRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRecordingInclude<ExtArgs> | null
    where?: VideoRecordingWhereInput
    orderBy?: VideoRecordingOrderByWithRelationInput | VideoRecordingOrderByWithRelationInput[]
    cursor?: VideoRecordingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoRecordingScalarFieldEnum | VideoRecordingScalarFieldEnum[]
  }

  /**
   * Tenant.videoMessages
   */
  export type Tenant$videoMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMessage
     */
    select?: VideoMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMessage
     */
    omit?: VideoMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMessageInclude<ExtArgs> | null
    where?: VideoMessageWhereInput
    orderBy?: VideoMessageOrderByWithRelationInput | VideoMessageOrderByWithRelationInput[]
    cursor?: VideoMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoMessageScalarFieldEnum | VideoMessageScalarFieldEnum[]
  }

  /**
   * Tenant.radiologyOrders
   */
  export type Tenant$radiologyOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyOrder
     */
    select?: RadiologyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyOrder
     */
    omit?: RadiologyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyOrderInclude<ExtArgs> | null
    where?: RadiologyOrderWhereInput
    orderBy?: RadiologyOrderOrderByWithRelationInput | RadiologyOrderOrderByWithRelationInput[]
    cursor?: RadiologyOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RadiologyOrderScalarFieldEnum | RadiologyOrderScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    experience: number | null
  }

  export type UserSumAggregateOutputType = {
    experience: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.Role | null
    specialization: string | null
    experience: number | null
    licenseNumber: string | null
    signature: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
    deletedAt: Date | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.Role | null
    specialization: string | null
    experience: number | null
    licenseNumber: string | null
    signature: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
    deletedAt: Date | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    firstName: number
    lastName: number
    role: number
    specialization: number
    experience: number
    licenseNumber: number
    signature: number
    isActive: number
    lastLoginAt: number
    deletedAt: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    experience?: true
  }

  export type UserSumAggregateInputType = {
    experience?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    specialization?: true
    experience?: true
    licenseNumber?: true
    signature?: true
    isActive?: true
    lastLoginAt?: true
    deletedAt?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    specialization?: true
    experience?: true
    licenseNumber?: true
    signature?: true
    isActive?: true
    lastLoginAt?: true
    deletedAt?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    specialization?: true
    experience?: true
    licenseNumber?: true
    signature?: true
    isActive?: true
    lastLoginAt?: true
    deletedAt?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization: string | null
    experience: number | null
    licenseNumber: string | null
    signature: string | null
    isActive: boolean
    lastLoginAt: Date | null
    deletedAt: Date | null
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    specialization?: boolean
    experience?: boolean
    licenseNumber?: boolean
    signature?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    deletedAt?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctorAppointments?: boolean | User$doctorAppointmentsArgs<ExtArgs>
    doctorLabOrders?: boolean | User$doctorLabOrdersArgs<ExtArgs>
    doctorPrescriptions?: boolean | User$doctorPrescriptionsArgs<ExtArgs>
    prescriptions?: boolean | User$prescriptionsArgs<ExtArgs>
    doctorTelemedicine?: boolean | User$doctorTelemedicineArgs<ExtArgs>
    doctorRadiologyOrders?: boolean | User$doctorRadiologyOrdersArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    staff?: boolean | User$staffArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    createdMedicalRecords?: boolean | User$createdMedicalRecordsArgs<ExtArgs>
    updatedMedicalRecords?: boolean | User$updatedMedicalRecordsArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    specialization?: boolean
    experience?: boolean
    licenseNumber?: boolean
    signature?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    deletedAt?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    specialization?: boolean
    experience?: boolean
    licenseNumber?: boolean
    signature?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    deletedAt?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    specialization?: boolean
    experience?: boolean
    licenseNumber?: boolean
    signature?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    deletedAt?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "firstName" | "lastName" | "role" | "specialization" | "experience" | "licenseNumber" | "signature" | "isActive" | "lastLoginAt" | "deletedAt" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctorAppointments?: boolean | User$doctorAppointmentsArgs<ExtArgs>
    doctorLabOrders?: boolean | User$doctorLabOrdersArgs<ExtArgs>
    doctorPrescriptions?: boolean | User$doctorPrescriptionsArgs<ExtArgs>
    prescriptions?: boolean | User$prescriptionsArgs<ExtArgs>
    doctorTelemedicine?: boolean | User$doctorTelemedicineArgs<ExtArgs>
    doctorRadiologyOrders?: boolean | User$doctorRadiologyOrdersArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    staff?: boolean | User$staffArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    createdMedicalRecords?: boolean | User$createdMedicalRecordsArgs<ExtArgs>
    updatedMedicalRecords?: boolean | User$updatedMedicalRecordsArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      doctorAppointments: Prisma.$AppointmentPayload<ExtArgs>[]
      doctorLabOrders: Prisma.$LabOrderPayload<ExtArgs>[]
      doctorPrescriptions: Prisma.$PharmacyOrderPayload<ExtArgs>[]
      prescriptions: Prisma.$PrescriptionPayload<ExtArgs>[]
      doctorTelemedicine: Prisma.$TelemedicineConsultationPayload<ExtArgs>[]
      doctorRadiologyOrders: Prisma.$RadiologyOrderPayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      staff: Prisma.$StaffPayload<ExtArgs> | null
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      createdMedicalRecords: Prisma.$MedicalRecordPayload<ExtArgs>[]
      updatedMedicalRecords: Prisma.$MedicalRecordPayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      firstName: string
      lastName: string
      role: $Enums.Role
      specialization: string | null
      experience: number | null
      licenseNumber: string | null
      signature: string | null
      isActive: boolean
      lastLoginAt: Date | null
      deletedAt: Date | null
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctorAppointments<T extends User$doctorAppointmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$doctorAppointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    doctorLabOrders<T extends User$doctorLabOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$doctorLabOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    doctorPrescriptions<T extends User$doctorPrescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$doctorPrescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PharmacyOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prescriptions<T extends User$prescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$prescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    doctorTelemedicine<T extends User$doctorTelemedicineArgs<ExtArgs> = {}>(args?: Subset<T, User$doctorTelemedicineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelemedicineConsultationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    doctorRadiologyOrders<T extends User$doctorRadiologyOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$doctorRadiologyOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiologyOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staff<T extends User$staffArgs<ExtArgs> = {}>(args?: Subset<T, User$staffArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdMedicalRecords<T extends User$createdMedicalRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdMedicalRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedMedicalRecords<T extends User$updatedMedicalRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedMedicalRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly specialization: FieldRef<"User", 'String'>
    readonly experience: FieldRef<"User", 'Int'>
    readonly licenseNumber: FieldRef<"User", 'String'>
    readonly signature: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.doctorAppointments
   */
  export type User$doctorAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * User.doctorLabOrders
   */
  export type User$doctorLabOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    where?: LabOrderWhereInput
    orderBy?: LabOrderOrderByWithRelationInput | LabOrderOrderByWithRelationInput[]
    cursor?: LabOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabOrderScalarFieldEnum | LabOrderScalarFieldEnum[]
  }

  /**
   * User.doctorPrescriptions
   */
  export type User$doctorPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrder
     */
    select?: PharmacyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrder
     */
    omit?: PharmacyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderInclude<ExtArgs> | null
    where?: PharmacyOrderWhereInput
    orderBy?: PharmacyOrderOrderByWithRelationInput | PharmacyOrderOrderByWithRelationInput[]
    cursor?: PharmacyOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PharmacyOrderScalarFieldEnum | PharmacyOrderScalarFieldEnum[]
  }

  /**
   * User.prescriptions
   */
  export type User$prescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * User.doctorTelemedicine
   */
  export type User$doctorTelemedicineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelemedicineConsultation
     */
    select?: TelemedicineConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelemedicineConsultation
     */
    omit?: TelemedicineConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemedicineConsultationInclude<ExtArgs> | null
    where?: TelemedicineConsultationWhereInput
    orderBy?: TelemedicineConsultationOrderByWithRelationInput | TelemedicineConsultationOrderByWithRelationInput[]
    cursor?: TelemedicineConsultationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TelemedicineConsultationScalarFieldEnum | TelemedicineConsultationScalarFieldEnum[]
  }

  /**
   * User.doctorRadiologyOrders
   */
  export type User$doctorRadiologyOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyOrder
     */
    select?: RadiologyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyOrder
     */
    omit?: RadiologyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyOrderInclude<ExtArgs> | null
    where?: RadiologyOrderWhereInput
    orderBy?: RadiologyOrderOrderByWithRelationInput | RadiologyOrderOrderByWithRelationInput[]
    cursor?: RadiologyOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RadiologyOrderScalarFieldEnum | RadiologyOrderScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.staff
   */
  export type User$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.createdMedicalRecords
   */
  export type User$createdMedicalRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    where?: MedicalRecordWhereInput
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    cursor?: MedicalRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalRecordScalarFieldEnum | MedicalRecordScalarFieldEnum[]
  }

  /**
   * User.updatedMedicalRecords
   */
  export type User$updatedMedicalRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    where?: MedicalRecordWhereInput
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    cursor?: MedicalRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalRecordScalarFieldEnum | MedicalRecordScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    jti: string | null
    token: string | null
    userId: string | null
    revoked: boolean | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    jti: string | null
    token: string | null
    userId: string | null
    revoked: boolean | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    jti: number
    token: number
    userId: number
    revoked: number
    expiresAt: number
    ipAddress: number
    userAgent: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    jti?: true
    token?: true
    userId?: true
    revoked?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    jti?: true
    token?: true
    userId?: true
    revoked?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    jti?: true
    token?: true
    userId?: true
    revoked?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    jti: string
    token: string
    userId: string
    revoked: boolean
    expiresAt: Date
    ipAddress: string | null
    userAgent: string | null
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jti?: boolean
    token?: boolean
    userId?: boolean
    revoked?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jti?: boolean
    token?: boolean
    userId?: boolean
    revoked?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jti?: boolean
    token?: boolean
    userId?: boolean
    revoked?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    jti?: boolean
    token?: boolean
    userId?: boolean
    revoked?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jti" | "token" | "userId" | "revoked" | "expiresAt" | "ipAddress" | "userAgent" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jti: string
      token: string
      userId: string
      revoked: boolean
      expiresAt: Date
      ipAddress: string | null
      userAgent: string | null
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly jti: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly revoked: FieldRef<"RefreshToken", 'Boolean'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly ipAddress: FieldRef<"RefreshToken", 'String'>
    readonly userAgent: FieldRef<"RefreshToken", 'String'>
    readonly tenantId: FieldRef<"RefreshToken", 'String'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly updatedAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    medicalRecordNumber: string | null
    registrationNumber: string | null
    externalId: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    gender: $Enums.Gender | null
    bloodType: $Enums.BloodType | null
    maritalStatus: $Enums.MaritalStatus | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    pincode: string | null
    phoneVerified: boolean | null
    emailVerified: boolean | null
    insuranceProvider: string | null
    insuranceId: string | null
    insuranceGroup: string | null
    insuranceValidUntil: Date | null
    insuranceType: $Enums.InsuranceType | null
    tenantId: string | null
    createdBy: string | null
    updatedBy: string | null
    isActive: boolean | null
    isVerified: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    medicalRecordNumber: string | null
    registrationNumber: string | null
    externalId: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    gender: $Enums.Gender | null
    bloodType: $Enums.BloodType | null
    maritalStatus: $Enums.MaritalStatus | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    pincode: string | null
    phoneVerified: boolean | null
    emailVerified: boolean | null
    insuranceProvider: string | null
    insuranceId: string | null
    insuranceGroup: string | null
    insuranceValidUntil: Date | null
    insuranceType: $Enums.InsuranceType | null
    tenantId: string | null
    createdBy: string | null
    updatedBy: string | null
    isActive: boolean | null
    isVerified: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    medicalRecordNumber: number
    registrationNumber: number
    externalId: number
    firstName: number
    middleName: number
    lastName: number
    dateOfBirth: number
    gender: number
    bloodType: number
    maritalStatus: number
    email: number
    phone: number
    address: number
    city: number
    state: number
    country: number
    pincode: number
    phoneVerified: number
    emailVerified: number
    allergies: number
    chronicConditions: number
    currentMedications: number
    knownAllergies: number
    familyHistory: number
    insuranceProvider: number
    insuranceId: number
    insuranceGroup: number
    insuranceValidUntil: number
    insuranceType: number
    tenantId: number
    createdBy: number
    updatedBy: number
    isActive: number
    isVerified: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PatientMinAggregateInputType = {
    id?: true
    medicalRecordNumber?: true
    registrationNumber?: true
    externalId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    dateOfBirth?: true
    gender?: true
    bloodType?: true
    maritalStatus?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    country?: true
    pincode?: true
    phoneVerified?: true
    emailVerified?: true
    insuranceProvider?: true
    insuranceId?: true
    insuranceGroup?: true
    insuranceValidUntil?: true
    insuranceType?: true
    tenantId?: true
    createdBy?: true
    updatedBy?: true
    isActive?: true
    isVerified?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    medicalRecordNumber?: true
    registrationNumber?: true
    externalId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    dateOfBirth?: true
    gender?: true
    bloodType?: true
    maritalStatus?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    country?: true
    pincode?: true
    phoneVerified?: true
    emailVerified?: true
    insuranceProvider?: true
    insuranceId?: true
    insuranceGroup?: true
    insuranceValidUntil?: true
    insuranceType?: true
    tenantId?: true
    createdBy?: true
    updatedBy?: true
    isActive?: true
    isVerified?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    medicalRecordNumber?: true
    registrationNumber?: true
    externalId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    dateOfBirth?: true
    gender?: true
    bloodType?: true
    maritalStatus?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    country?: true
    pincode?: true
    phoneVerified?: true
    emailVerified?: true
    allergies?: true
    chronicConditions?: true
    currentMedications?: true
    knownAllergies?: true
    familyHistory?: true
    insuranceProvider?: true
    insuranceId?: true
    insuranceGroup?: true
    insuranceValidUntil?: true
    insuranceType?: true
    tenantId?: true
    createdBy?: true
    updatedBy?: true
    isActive?: true
    isVerified?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: string
    medicalRecordNumber: string
    registrationNumber: string | null
    externalId: string | null
    firstName: string
    middleName: string | null
    lastName: string
    dateOfBirth: Date | null
    gender: $Enums.Gender | null
    bloodType: $Enums.BloodType | null
    maritalStatus: $Enums.MaritalStatus | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    pincode: string | null
    phoneVerified: boolean
    emailVerified: boolean
    allergies: JsonValue | null
    chronicConditions: JsonValue | null
    currentMedications: JsonValue | null
    knownAllergies: JsonValue | null
    familyHistory: JsonValue | null
    insuranceProvider: string | null
    insuranceId: string | null
    insuranceGroup: string | null
    insuranceValidUntil: Date | null
    insuranceType: $Enums.InsuranceType | null
    tenantId: string
    createdBy: string | null
    updatedBy: string | null
    isActive: boolean
    isVerified: boolean
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicalRecordNumber?: boolean
    registrationNumber?: boolean
    externalId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bloodType?: boolean
    maritalStatus?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    pincode?: boolean
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: boolean
    chronicConditions?: boolean
    currentMedications?: boolean
    knownAllergies?: boolean
    familyHistory?: boolean
    insuranceProvider?: boolean
    insuranceId?: boolean
    insuranceGroup?: boolean
    insuranceValidUntil?: boolean
    insuranceType?: boolean
    tenantId?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    invoices?: boolean | Patient$invoicesArgs<ExtArgs>
    labOrders?: boolean | Patient$labOrdersArgs<ExtArgs>
    medicalRecords?: boolean | Patient$medicalRecordsArgs<ExtArgs>
    pharmacyOrders?: boolean | Patient$pharmacyOrdersArgs<ExtArgs>
    prescriptions?: boolean | Patient$prescriptionsArgs<ExtArgs>
    prescriptionItems?: boolean | Patient$prescriptionItemsArgs<ExtArgs>
    studies?: boolean | Patient$studiesArgs<ExtArgs>
    telemedicineConsultations?: boolean | Patient$telemedicineConsultationsArgs<ExtArgs>
    radiologyOrders?: boolean | Patient$radiologyOrdersArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicalRecordNumber?: boolean
    registrationNumber?: boolean
    externalId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bloodType?: boolean
    maritalStatus?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    pincode?: boolean
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: boolean
    chronicConditions?: boolean
    currentMedications?: boolean
    knownAllergies?: boolean
    familyHistory?: boolean
    insuranceProvider?: boolean
    insuranceId?: boolean
    insuranceGroup?: boolean
    insuranceValidUntil?: boolean
    insuranceType?: boolean
    tenantId?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicalRecordNumber?: boolean
    registrationNumber?: boolean
    externalId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bloodType?: boolean
    maritalStatus?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    pincode?: boolean
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: boolean
    chronicConditions?: boolean
    currentMedications?: boolean
    knownAllergies?: boolean
    familyHistory?: boolean
    insuranceProvider?: boolean
    insuranceId?: boolean
    insuranceGroup?: boolean
    insuranceValidUntil?: boolean
    insuranceType?: boolean
    tenantId?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    medicalRecordNumber?: boolean
    registrationNumber?: boolean
    externalId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bloodType?: boolean
    maritalStatus?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    pincode?: boolean
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: boolean
    chronicConditions?: boolean
    currentMedications?: boolean
    knownAllergies?: boolean
    familyHistory?: boolean
    insuranceProvider?: boolean
    insuranceId?: boolean
    insuranceGroup?: boolean
    insuranceValidUntil?: boolean
    insuranceType?: boolean
    tenantId?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "medicalRecordNumber" | "registrationNumber" | "externalId" | "firstName" | "middleName" | "lastName" | "dateOfBirth" | "gender" | "bloodType" | "maritalStatus" | "email" | "phone" | "address" | "city" | "state" | "country" | "pincode" | "phoneVerified" | "emailVerified" | "allergies" | "chronicConditions" | "currentMedications" | "knownAllergies" | "familyHistory" | "insuranceProvider" | "insuranceId" | "insuranceGroup" | "insuranceValidUntil" | "insuranceType" | "tenantId" | "createdBy" | "updatedBy" | "isActive" | "isVerified" | "lastLoginAt" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["patient"]>
  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    invoices?: boolean | Patient$invoicesArgs<ExtArgs>
    labOrders?: boolean | Patient$labOrdersArgs<ExtArgs>
    medicalRecords?: boolean | Patient$medicalRecordsArgs<ExtArgs>
    pharmacyOrders?: boolean | Patient$pharmacyOrdersArgs<ExtArgs>
    prescriptions?: boolean | Patient$prescriptionsArgs<ExtArgs>
    prescriptionItems?: boolean | Patient$prescriptionItemsArgs<ExtArgs>
    studies?: boolean | Patient$studiesArgs<ExtArgs>
    telemedicineConsultations?: boolean | Patient$telemedicineConsultationsArgs<ExtArgs>
    radiologyOrders?: boolean | Patient$radiologyOrdersArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type PatientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      labOrders: Prisma.$LabOrderPayload<ExtArgs>[]
      medicalRecords: Prisma.$MedicalRecordPayload<ExtArgs>[]
      pharmacyOrders: Prisma.$PharmacyOrderPayload<ExtArgs>[]
      prescriptions: Prisma.$PrescriptionPayload<ExtArgs>[]
      prescriptionItems: Prisma.$PrescriptionItemPayload<ExtArgs>[]
      studies: Prisma.$StudyPayload<ExtArgs>[]
      telemedicineConsultations: Prisma.$TelemedicineConsultationPayload<ExtArgs>[]
      radiologyOrders: Prisma.$RadiologyOrderPayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      medicalRecordNumber: string
      registrationNumber: string | null
      externalId: string | null
      firstName: string
      middleName: string | null
      lastName: string
      dateOfBirth: Date | null
      gender: $Enums.Gender | null
      bloodType: $Enums.BloodType | null
      maritalStatus: $Enums.MaritalStatus | null
      email: string | null
      phone: string | null
      address: string | null
      city: string | null
      state: string | null
      country: string | null
      pincode: string | null
      phoneVerified: boolean
      emailVerified: boolean
      allergies: Prisma.JsonValue | null
      chronicConditions: Prisma.JsonValue | null
      currentMedications: Prisma.JsonValue | null
      knownAllergies: Prisma.JsonValue | null
      familyHistory: Prisma.JsonValue | null
      insuranceProvider: string | null
      insuranceId: string | null
      insuranceGroup: string | null
      insuranceValidUntil: Date | null
      insuranceType: $Enums.InsuranceType | null
      tenantId: string
      createdBy: string | null
      updatedBy: string | null
      isActive: boolean
      isVerified: boolean
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients and returns the data updated in the database.
     * @param {PatientUpdateManyAndReturnArgs} args - Arguments to update many Patients.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends Patient$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Patient$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labOrders<T extends Patient$labOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Patient$labOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicalRecords<T extends Patient$medicalRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$medicalRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pharmacyOrders<T extends Patient$pharmacyOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Patient$pharmacyOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PharmacyOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prescriptions<T extends Patient$prescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$prescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prescriptionItems<T extends Patient$prescriptionItemsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$prescriptionItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studies<T extends Patient$studiesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$studiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    telemedicineConsultations<T extends Patient$telemedicineConsultationsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$telemedicineConsultationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelemedicineConsultationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    radiologyOrders<T extends Patient$radiologyOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Patient$radiologyOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiologyOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'String'>
    readonly medicalRecordNumber: FieldRef<"Patient", 'String'>
    readonly registrationNumber: FieldRef<"Patient", 'String'>
    readonly externalId: FieldRef<"Patient", 'String'>
    readonly firstName: FieldRef<"Patient", 'String'>
    readonly middleName: FieldRef<"Patient", 'String'>
    readonly lastName: FieldRef<"Patient", 'String'>
    readonly dateOfBirth: FieldRef<"Patient", 'DateTime'>
    readonly gender: FieldRef<"Patient", 'Gender'>
    readonly bloodType: FieldRef<"Patient", 'BloodType'>
    readonly maritalStatus: FieldRef<"Patient", 'MaritalStatus'>
    readonly email: FieldRef<"Patient", 'String'>
    readonly phone: FieldRef<"Patient", 'String'>
    readonly address: FieldRef<"Patient", 'String'>
    readonly city: FieldRef<"Patient", 'String'>
    readonly state: FieldRef<"Patient", 'String'>
    readonly country: FieldRef<"Patient", 'String'>
    readonly pincode: FieldRef<"Patient", 'String'>
    readonly phoneVerified: FieldRef<"Patient", 'Boolean'>
    readonly emailVerified: FieldRef<"Patient", 'Boolean'>
    readonly allergies: FieldRef<"Patient", 'Json'>
    readonly chronicConditions: FieldRef<"Patient", 'Json'>
    readonly currentMedications: FieldRef<"Patient", 'Json'>
    readonly knownAllergies: FieldRef<"Patient", 'Json'>
    readonly familyHistory: FieldRef<"Patient", 'Json'>
    readonly insuranceProvider: FieldRef<"Patient", 'String'>
    readonly insuranceId: FieldRef<"Patient", 'String'>
    readonly insuranceGroup: FieldRef<"Patient", 'String'>
    readonly insuranceValidUntil: FieldRef<"Patient", 'DateTime'>
    readonly insuranceType: FieldRef<"Patient", 'InsuranceType'>
    readonly tenantId: FieldRef<"Patient", 'String'>
    readonly createdBy: FieldRef<"Patient", 'String'>
    readonly updatedBy: FieldRef<"Patient", 'String'>
    readonly isActive: FieldRef<"Patient", 'Boolean'>
    readonly isVerified: FieldRef<"Patient", 'Boolean'>
    readonly lastLoginAt: FieldRef<"Patient", 'DateTime'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
    readonly updatedAt: FieldRef<"Patient", 'DateTime'>
    readonly deletedAt: FieldRef<"Patient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient updateManyAndReturn
   */
  export type PatientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to delete.
     */
    limit?: number
  }

  /**
   * Patient.appointments
   */
  export type Patient$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Patient.invoices
   */
  export type Patient$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Patient.labOrders
   */
  export type Patient$labOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    where?: LabOrderWhereInput
    orderBy?: LabOrderOrderByWithRelationInput | LabOrderOrderByWithRelationInput[]
    cursor?: LabOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabOrderScalarFieldEnum | LabOrderScalarFieldEnum[]
  }

  /**
   * Patient.medicalRecords
   */
  export type Patient$medicalRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    where?: MedicalRecordWhereInput
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    cursor?: MedicalRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalRecordScalarFieldEnum | MedicalRecordScalarFieldEnum[]
  }

  /**
   * Patient.pharmacyOrders
   */
  export type Patient$pharmacyOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrder
     */
    select?: PharmacyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrder
     */
    omit?: PharmacyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderInclude<ExtArgs> | null
    where?: PharmacyOrderWhereInput
    orderBy?: PharmacyOrderOrderByWithRelationInput | PharmacyOrderOrderByWithRelationInput[]
    cursor?: PharmacyOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PharmacyOrderScalarFieldEnum | PharmacyOrderScalarFieldEnum[]
  }

  /**
   * Patient.prescriptions
   */
  export type Patient$prescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Patient.prescriptionItems
   */
  export type Patient$prescriptionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    where?: PrescriptionItemWhereInput
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    cursor?: PrescriptionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * Patient.studies
   */
  export type Patient$studiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    where?: StudyWhereInput
    orderBy?: StudyOrderByWithRelationInput | StudyOrderByWithRelationInput[]
    cursor?: StudyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudyScalarFieldEnum | StudyScalarFieldEnum[]
  }

  /**
   * Patient.telemedicineConsultations
   */
  export type Patient$telemedicineConsultationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelemedicineConsultation
     */
    select?: TelemedicineConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelemedicineConsultation
     */
    omit?: TelemedicineConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemedicineConsultationInclude<ExtArgs> | null
    where?: TelemedicineConsultationWhereInput
    orderBy?: TelemedicineConsultationOrderByWithRelationInput | TelemedicineConsultationOrderByWithRelationInput[]
    cursor?: TelemedicineConsultationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TelemedicineConsultationScalarFieldEnum | TelemedicineConsultationScalarFieldEnum[]
  }

  /**
   * Patient.radiologyOrders
   */
  export type Patient$radiologyOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyOrder
     */
    select?: RadiologyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyOrder
     */
    omit?: RadiologyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyOrderInclude<ExtArgs> | null
    where?: RadiologyOrderWhereInput
    orderBy?: RadiologyOrderOrderByWithRelationInput | RadiologyOrderOrderByWithRelationInput[]
    cursor?: RadiologyOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RadiologyOrderScalarFieldEnum | RadiologyOrderScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    departmentId: string | null
    startTime: Date | null
    endTime: Date | null
    status: $Enums.AppointmentStatus | null
    reason: string | null
    notes: string | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    departmentId: string | null
    startTime: Date | null
    endTime: Date | null
    status: $Enums.AppointmentStatus | null
    reason: string | null
    notes: string | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    patientId: number
    doctorId: number
    departmentId: number
    startTime: number
    endTime: number
    status: number
    reason: number
    notes: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppointmentMinAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    departmentId?: true
    startTime?: true
    endTime?: true
    status?: true
    reason?: true
    notes?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    departmentId?: true
    startTime?: true
    endTime?: true
    status?: true
    reason?: true
    notes?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    departmentId?: true
    startTime?: true
    endTime?: true
    status?: true
    reason?: true
    notes?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: string
    patientId: string
    doctorId: string
    departmentId: string | null
    startTime: Date
    endTime: Date
    status: $Enums.AppointmentStatus
    reason: string | null
    notes: string | null
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    departmentId?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    reason?: boolean
    notes?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    department?: boolean | Appointment$departmentArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    departmentId?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    reason?: boolean
    notes?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    department?: boolean | Appointment$departmentArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    departmentId?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    reason?: boolean
    notes?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    department?: boolean | Appointment$departmentArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    departmentId?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    reason?: boolean
    notes?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "doctorId" | "departmentId" | "startTime" | "endTime" | "status" | "reason" | "notes" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["appointment"]>
  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    department?: boolean | Appointment$departmentArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    department?: boolean | Appointment$departmentArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    department?: boolean | Appointment$departmentArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      doctor: Prisma.$UserPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      doctorId: string
      departmentId: string | null
      startTime: Date
      endTime: Date
      status: $Enums.AppointmentStatus
      reason: string | null
      notes: string | null
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments and returns the data updated in the database.
     * @param {AppointmentUpdateManyAndReturnArgs} args - Arguments to update many Appointments.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AppointmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    department<T extends Appointment$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    doctor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'String'>
    readonly patientId: FieldRef<"Appointment", 'String'>
    readonly doctorId: FieldRef<"Appointment", 'String'>
    readonly departmentId: FieldRef<"Appointment", 'String'>
    readonly startTime: FieldRef<"Appointment", 'DateTime'>
    readonly endTime: FieldRef<"Appointment", 'DateTime'>
    readonly status: FieldRef<"Appointment", 'AppointmentStatus'>
    readonly reason: FieldRef<"Appointment", 'String'>
    readonly notes: FieldRef<"Appointment", 'String'>
    readonly tenantId: FieldRef<"Appointment", 'String'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
    readonly updatedAt: FieldRef<"Appointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
  }

  /**
   * Appointment updateManyAndReturn
   */
  export type AppointmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to delete.
     */
    limit?: number
  }

  /**
   * Appointment.department
   */
  export type Appointment$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model Prescription
   */

  export type AggregatePrescription = {
    _count: PrescriptionCountAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  export type PrescriptionMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    diagnosis: string | null
    notes: string | null
    status: $Enums.PrescriptionStatus | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrescriptionMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    diagnosis: string | null
    notes: string | null
    status: $Enums.PrescriptionStatus | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrescriptionCountAggregateOutputType = {
    id: number
    patientId: number
    doctorId: number
    diagnosis: number
    notes: number
    status: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PrescriptionMinAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    diagnosis?: true
    notes?: true
    status?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrescriptionMaxAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    diagnosis?: true
    notes?: true
    status?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrescriptionCountAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    diagnosis?: true
    notes?: true
    status?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PrescriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescription to aggregate.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prescriptions
    **/
    _count?: true | PrescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionMaxAggregateInputType
  }

  export type GetPrescriptionAggregateType<T extends PrescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescription[P]>
      : GetScalarType<T[P], AggregatePrescription[P]>
  }




  export type PrescriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithAggregationInput | PrescriptionOrderByWithAggregationInput[]
    by: PrescriptionScalarFieldEnum[] | PrescriptionScalarFieldEnum
    having?: PrescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionCountAggregateInputType | true
    _min?: PrescriptionMinAggregateInputType
    _max?: PrescriptionMaxAggregateInputType
  }

  export type PrescriptionGroupByOutputType = {
    id: string
    patientId: string
    doctorId: string
    diagnosis: string | null
    notes: string | null
    status: $Enums.PrescriptionStatus
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: PrescriptionCountAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  type GetPrescriptionGroupByPayload<T extends PrescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    diagnosis?: boolean
    notes?: boolean
    status?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    prescriptionItems?: boolean | Prescription$prescriptionItemsArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    diagnosis?: boolean
    notes?: boolean
    status?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    diagnosis?: boolean
    notes?: boolean
    status?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectScalar = {
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    diagnosis?: boolean
    notes?: boolean
    status?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PrescriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "doctorId" | "diagnosis" | "notes" | "status" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["prescription"]>
  export type PrescriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    prescriptionItems?: boolean | Prescription$prescriptionItemsArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PrescriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type PrescriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $PrescriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prescription"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      doctor: Prisma.$UserPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      prescriptionItems: Prisma.$PrescriptionItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      doctorId: string
      diagnosis: string | null
      notes: string | null
      status: $Enums.PrescriptionStatus
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["prescription"]>
    composites: {}
  }

  type PrescriptionGetPayload<S extends boolean | null | undefined | PrescriptionDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionPayload, S>

  type PrescriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrescriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrescriptionCountAggregateInputType | true
    }

  export interface PrescriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prescription'], meta: { name: 'Prescription' } }
    /**
     * Find zero or one Prescription that matches the filter.
     * @param {PrescriptionFindUniqueArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrescriptionFindUniqueArgs>(args: SelectSubset<T, PrescriptionFindUniqueArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Prescription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrescriptionFindUniqueOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrescriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PrescriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrescriptionFindFirstArgs>(args?: SelectSubset<T, PrescriptionFindFirstArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prescription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrescriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PrescriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Prescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prescriptions
     * const prescriptions = await prisma.prescription.findMany()
     * 
     * // Get first 10 Prescriptions
     * const prescriptions = await prisma.prescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrescriptionFindManyArgs>(args?: SelectSubset<T, PrescriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Prescription.
     * @param {PrescriptionCreateArgs} args - Arguments to create a Prescription.
     * @example
     * // Create one Prescription
     * const Prescription = await prisma.prescription.create({
     *   data: {
     *     // ... data to create a Prescription
     *   }
     * })
     * 
     */
    create<T extends PrescriptionCreateArgs>(args: SelectSubset<T, PrescriptionCreateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Prescriptions.
     * @param {PrescriptionCreateManyArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrescriptionCreateManyArgs>(args?: SelectSubset<T, PrescriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prescriptions and returns the data saved in the database.
     * @param {PrescriptionCreateManyAndReturnArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prescriptions and only return the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrescriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PrescriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Prescription.
     * @param {PrescriptionDeleteArgs} args - Arguments to delete one Prescription.
     * @example
     * // Delete one Prescription
     * const Prescription = await prisma.prescription.delete({
     *   where: {
     *     // ... filter to delete one Prescription
     *   }
     * })
     * 
     */
    delete<T extends PrescriptionDeleteArgs>(args: SelectSubset<T, PrescriptionDeleteArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Prescription.
     * @param {PrescriptionUpdateArgs} args - Arguments to update one Prescription.
     * @example
     * // Update one Prescription
     * const prescription = await prisma.prescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrescriptionUpdateArgs>(args: SelectSubset<T, PrescriptionUpdateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Prescriptions.
     * @param {PrescriptionDeleteManyArgs} args - Arguments to filter Prescriptions to delete.
     * @example
     * // Delete a few Prescriptions
     * const { count } = await prisma.prescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrescriptionDeleteManyArgs>(args?: SelectSubset<T, PrescriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrescriptionUpdateManyArgs>(args: SelectSubset<T, PrescriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions and returns the data updated in the database.
     * @param {PrescriptionUpdateManyAndReturnArgs} args - Arguments to update many Prescriptions.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Prescriptions and only return the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrescriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PrescriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Prescription.
     * @param {PrescriptionUpsertArgs} args - Arguments to update or create a Prescription.
     * @example
     * // Update or create a Prescription
     * const prescription = await prisma.prescription.upsert({
     *   create: {
     *     // ... data to create a Prescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prescription we want to update
     *   }
     * })
     */
    upsert<T extends PrescriptionUpsertArgs>(args: SelectSubset<T, PrescriptionUpsertArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionCountArgs} args - Arguments to filter Prescriptions to count.
     * @example
     * // Count the number of Prescriptions
     * const count = await prisma.prescription.count({
     *   where: {
     *     // ... the filter for the Prescriptions we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionCountArgs>(
      args?: Subset<T, PrescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionAggregateArgs>(args: Subset<T, PrescriptionAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionAggregateType<T>>

    /**
     * Group by Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prescription model
   */
  readonly fields: PrescriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prescriptionItems<T extends Prescription$prescriptionItemsArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$prescriptionItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prescription model
   */
  interface PrescriptionFieldRefs {
    readonly id: FieldRef<"Prescription", 'String'>
    readonly patientId: FieldRef<"Prescription", 'String'>
    readonly doctorId: FieldRef<"Prescription", 'String'>
    readonly diagnosis: FieldRef<"Prescription", 'String'>
    readonly notes: FieldRef<"Prescription", 'String'>
    readonly status: FieldRef<"Prescription", 'PrescriptionStatus'>
    readonly tenantId: FieldRef<"Prescription", 'String'>
    readonly createdAt: FieldRef<"Prescription", 'DateTime'>
    readonly updatedAt: FieldRef<"Prescription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Prescription findUnique
   */
  export type PrescriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findUniqueOrThrow
   */
  export type PrescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findFirst
   */
  export type PrescriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findFirstOrThrow
   */
  export type PrescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findMany
   */
  export type PrescriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescriptions to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription create
   */
  export type PrescriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Prescription.
     */
    data: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
  }

  /**
   * Prescription createMany
   */
  export type PrescriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prescription createManyAndReturn
   */
  export type PrescriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prescription update
   */
  export type PrescriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Prescription.
     */
    data: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
    /**
     * Choose, which Prescription to update.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription updateMany
   */
  export type PrescriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to update.
     */
    limit?: number
  }

  /**
   * Prescription updateManyAndReturn
   */
  export type PrescriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prescription upsert
   */
  export type PrescriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Prescription to update in case it exists.
     */
    where: PrescriptionWhereUniqueInput
    /**
     * In case the Prescription found by the `where` argument doesn't exist, create a new Prescription with this data.
     */
    create: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
    /**
     * In case the Prescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
  }

  /**
   * Prescription delete
   */
  export type PrescriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter which Prescription to delete.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription deleteMany
   */
  export type PrescriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescriptions to delete
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to delete.
     */
    limit?: number
  }

  /**
   * Prescription.prescriptionItems
   */
  export type Prescription$prescriptionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    where?: PrescriptionItemWhereInput
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    cursor?: PrescriptionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * Prescription without action
   */
  export type PrescriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
  }


  /**
   * Model PrescriptionItem
   */

  export type AggregatePrescriptionItem = {
    _count: PrescriptionItemCountAggregateOutputType | null
    _min: PrescriptionItemMinAggregateOutputType | null
    _max: PrescriptionItemMaxAggregateOutputType | null
  }

  export type PrescriptionItemMinAggregateOutputType = {
    id: string | null
    prescriptionId: string | null
    medicationId: string | null
    patientId: string | null
    dosage: string | null
    frequency: string | null
    duration: string | null
    instructions: string | null
    isDispensed: boolean | null
    tenantId: string | null
  }

  export type PrescriptionItemMaxAggregateOutputType = {
    id: string | null
    prescriptionId: string | null
    medicationId: string | null
    patientId: string | null
    dosage: string | null
    frequency: string | null
    duration: string | null
    instructions: string | null
    isDispensed: boolean | null
    tenantId: string | null
  }

  export type PrescriptionItemCountAggregateOutputType = {
    id: number
    prescriptionId: number
    medicationId: number
    patientId: number
    dosage: number
    frequency: number
    duration: number
    instructions: number
    isDispensed: number
    tenantId: number
    _all: number
  }


  export type PrescriptionItemMinAggregateInputType = {
    id?: true
    prescriptionId?: true
    medicationId?: true
    patientId?: true
    dosage?: true
    frequency?: true
    duration?: true
    instructions?: true
    isDispensed?: true
    tenantId?: true
  }

  export type PrescriptionItemMaxAggregateInputType = {
    id?: true
    prescriptionId?: true
    medicationId?: true
    patientId?: true
    dosage?: true
    frequency?: true
    duration?: true
    instructions?: true
    isDispensed?: true
    tenantId?: true
  }

  export type PrescriptionItemCountAggregateInputType = {
    id?: true
    prescriptionId?: true
    medicationId?: true
    patientId?: true
    dosage?: true
    frequency?: true
    duration?: true
    instructions?: true
    isDispensed?: true
    tenantId?: true
    _all?: true
  }

  export type PrescriptionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrescriptionItem to aggregate.
     */
    where?: PrescriptionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionItems to fetch.
     */
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrescriptionItems
    **/
    _count?: true | PrescriptionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionItemMaxAggregateInputType
  }

  export type GetPrescriptionItemAggregateType<T extends PrescriptionItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescriptionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescriptionItem[P]>
      : GetScalarType<T[P], AggregatePrescriptionItem[P]>
  }




  export type PrescriptionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionItemWhereInput
    orderBy?: PrescriptionItemOrderByWithAggregationInput | PrescriptionItemOrderByWithAggregationInput[]
    by: PrescriptionItemScalarFieldEnum[] | PrescriptionItemScalarFieldEnum
    having?: PrescriptionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionItemCountAggregateInputType | true
    _min?: PrescriptionItemMinAggregateInputType
    _max?: PrescriptionItemMaxAggregateInputType
  }

  export type PrescriptionItemGroupByOutputType = {
    id: string
    prescriptionId: string
    medicationId: string
    patientId: string
    dosage: string
    frequency: string
    duration: string
    instructions: string | null
    isDispensed: boolean
    tenantId: string
    _count: PrescriptionItemCountAggregateOutputType | null
    _min: PrescriptionItemMinAggregateOutputType | null
    _max: PrescriptionItemMaxAggregateOutputType | null
  }

  type GetPrescriptionItemGroupByPayload<T extends PrescriptionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionItemGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionItemGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    medicationId?: boolean
    patientId?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    instructions?: boolean
    isDispensed?: boolean
    tenantId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionItem"]>

  export type PrescriptionItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    medicationId?: boolean
    patientId?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    instructions?: boolean
    isDispensed?: boolean
    tenantId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionItem"]>

  export type PrescriptionItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    medicationId?: boolean
    patientId?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    instructions?: boolean
    isDispensed?: boolean
    tenantId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionItem"]>

  export type PrescriptionItemSelectScalar = {
    id?: boolean
    prescriptionId?: boolean
    medicationId?: boolean
    patientId?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    instructions?: boolean
    isDispensed?: boolean
    tenantId?: boolean
  }

  export type PrescriptionItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "prescriptionId" | "medicationId" | "patientId" | "dosage" | "frequency" | "duration" | "instructions" | "isDispensed" | "tenantId", ExtArgs["result"]["prescriptionItem"]>
  export type PrescriptionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }
  export type PrescriptionItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }
  export type PrescriptionItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
  }

  export type $PrescriptionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrescriptionItem"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      medication: Prisma.$MedicationPayload<ExtArgs>
      prescription: Prisma.$PrescriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      prescriptionId: string
      medicationId: string
      patientId: string
      dosage: string
      frequency: string
      duration: string
      instructions: string | null
      isDispensed: boolean
      tenantId: string
    }, ExtArgs["result"]["prescriptionItem"]>
    composites: {}
  }

  type PrescriptionItemGetPayload<S extends boolean | null | undefined | PrescriptionItemDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionItemPayload, S>

  type PrescriptionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrescriptionItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrescriptionItemCountAggregateInputType | true
    }

  export interface PrescriptionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrescriptionItem'], meta: { name: 'PrescriptionItem' } }
    /**
     * Find zero or one PrescriptionItem that matches the filter.
     * @param {PrescriptionItemFindUniqueArgs} args - Arguments to find a PrescriptionItem
     * @example
     * // Get one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrescriptionItemFindUniqueArgs>(args: SelectSubset<T, PrescriptionItemFindUniqueArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrescriptionItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrescriptionItemFindUniqueOrThrowArgs} args - Arguments to find a PrescriptionItem
     * @example
     * // Get one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrescriptionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PrescriptionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrescriptionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemFindFirstArgs} args - Arguments to find a PrescriptionItem
     * @example
     * // Get one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrescriptionItemFindFirstArgs>(args?: SelectSubset<T, PrescriptionItemFindFirstArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrescriptionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemFindFirstOrThrowArgs} args - Arguments to find a PrescriptionItem
     * @example
     * // Get one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrescriptionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PrescriptionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrescriptionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrescriptionItems
     * const prescriptionItems = await prisma.prescriptionItem.findMany()
     * 
     * // Get first 10 PrescriptionItems
     * const prescriptionItems = await prisma.prescriptionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionItemWithIdOnly = await prisma.prescriptionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrescriptionItemFindManyArgs>(args?: SelectSubset<T, PrescriptionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrescriptionItem.
     * @param {PrescriptionItemCreateArgs} args - Arguments to create a PrescriptionItem.
     * @example
     * // Create one PrescriptionItem
     * const PrescriptionItem = await prisma.prescriptionItem.create({
     *   data: {
     *     // ... data to create a PrescriptionItem
     *   }
     * })
     * 
     */
    create<T extends PrescriptionItemCreateArgs>(args: SelectSubset<T, PrescriptionItemCreateArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrescriptionItems.
     * @param {PrescriptionItemCreateManyArgs} args - Arguments to create many PrescriptionItems.
     * @example
     * // Create many PrescriptionItems
     * const prescriptionItem = await prisma.prescriptionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrescriptionItemCreateManyArgs>(args?: SelectSubset<T, PrescriptionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrescriptionItems and returns the data saved in the database.
     * @param {PrescriptionItemCreateManyAndReturnArgs} args - Arguments to create many PrescriptionItems.
     * @example
     * // Create many PrescriptionItems
     * const prescriptionItem = await prisma.prescriptionItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrescriptionItems and only return the `id`
     * const prescriptionItemWithIdOnly = await prisma.prescriptionItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrescriptionItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PrescriptionItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PrescriptionItem.
     * @param {PrescriptionItemDeleteArgs} args - Arguments to delete one PrescriptionItem.
     * @example
     * // Delete one PrescriptionItem
     * const PrescriptionItem = await prisma.prescriptionItem.delete({
     *   where: {
     *     // ... filter to delete one PrescriptionItem
     *   }
     * })
     * 
     */
    delete<T extends PrescriptionItemDeleteArgs>(args: SelectSubset<T, PrescriptionItemDeleteArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrescriptionItem.
     * @param {PrescriptionItemUpdateArgs} args - Arguments to update one PrescriptionItem.
     * @example
     * // Update one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrescriptionItemUpdateArgs>(args: SelectSubset<T, PrescriptionItemUpdateArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrescriptionItems.
     * @param {PrescriptionItemDeleteManyArgs} args - Arguments to filter PrescriptionItems to delete.
     * @example
     * // Delete a few PrescriptionItems
     * const { count } = await prisma.prescriptionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrescriptionItemDeleteManyArgs>(args?: SelectSubset<T, PrescriptionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrescriptionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrescriptionItems
     * const prescriptionItem = await prisma.prescriptionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrescriptionItemUpdateManyArgs>(args: SelectSubset<T, PrescriptionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrescriptionItems and returns the data updated in the database.
     * @param {PrescriptionItemUpdateManyAndReturnArgs} args - Arguments to update many PrescriptionItems.
     * @example
     * // Update many PrescriptionItems
     * const prescriptionItem = await prisma.prescriptionItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PrescriptionItems and only return the `id`
     * const prescriptionItemWithIdOnly = await prisma.prescriptionItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrescriptionItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PrescriptionItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PrescriptionItem.
     * @param {PrescriptionItemUpsertArgs} args - Arguments to update or create a PrescriptionItem.
     * @example
     * // Update or create a PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.upsert({
     *   create: {
     *     // ... data to create a PrescriptionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrescriptionItem we want to update
     *   }
     * })
     */
    upsert<T extends PrescriptionItemUpsertArgs>(args: SelectSubset<T, PrescriptionItemUpsertArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrescriptionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemCountArgs} args - Arguments to filter PrescriptionItems to count.
     * @example
     * // Count the number of PrescriptionItems
     * const count = await prisma.prescriptionItem.count({
     *   where: {
     *     // ... the filter for the PrescriptionItems we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionItemCountArgs>(
      args?: Subset<T, PrescriptionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrescriptionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionItemAggregateArgs>(args: Subset<T, PrescriptionItemAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionItemAggregateType<T>>

    /**
     * Group by PrescriptionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionItemGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrescriptionItem model
   */
  readonly fields: PrescriptionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrescriptionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medication<T extends MedicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicationDefaultArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prescription<T extends PrescriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrescriptionDefaultArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrescriptionItem model
   */
  interface PrescriptionItemFieldRefs {
    readonly id: FieldRef<"PrescriptionItem", 'String'>
    readonly prescriptionId: FieldRef<"PrescriptionItem", 'String'>
    readonly medicationId: FieldRef<"PrescriptionItem", 'String'>
    readonly patientId: FieldRef<"PrescriptionItem", 'String'>
    readonly dosage: FieldRef<"PrescriptionItem", 'String'>
    readonly frequency: FieldRef<"PrescriptionItem", 'String'>
    readonly duration: FieldRef<"PrescriptionItem", 'String'>
    readonly instructions: FieldRef<"PrescriptionItem", 'String'>
    readonly isDispensed: FieldRef<"PrescriptionItem", 'Boolean'>
    readonly tenantId: FieldRef<"PrescriptionItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PrescriptionItem findUnique
   */
  export type PrescriptionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItem to fetch.
     */
    where: PrescriptionItemWhereUniqueInput
  }

  /**
   * PrescriptionItem findUniqueOrThrow
   */
  export type PrescriptionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItem to fetch.
     */
    where: PrescriptionItemWhereUniqueInput
  }

  /**
   * PrescriptionItem findFirst
   */
  export type PrescriptionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItem to fetch.
     */
    where?: PrescriptionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionItems to fetch.
     */
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrescriptionItems.
     */
    cursor?: PrescriptionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrescriptionItems.
     */
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * PrescriptionItem findFirstOrThrow
   */
  export type PrescriptionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItem to fetch.
     */
    where?: PrescriptionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionItems to fetch.
     */
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrescriptionItems.
     */
    cursor?: PrescriptionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrescriptionItems.
     */
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * PrescriptionItem findMany
   */
  export type PrescriptionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItems to fetch.
     */
    where?: PrescriptionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionItems to fetch.
     */
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrescriptionItems.
     */
    cursor?: PrescriptionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionItems.
     */
    skip?: number
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * PrescriptionItem create
   */
  export type PrescriptionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PrescriptionItem.
     */
    data: XOR<PrescriptionItemCreateInput, PrescriptionItemUncheckedCreateInput>
  }

  /**
   * PrescriptionItem createMany
   */
  export type PrescriptionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrescriptionItems.
     */
    data: PrescriptionItemCreateManyInput | PrescriptionItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrescriptionItem createManyAndReturn
   */
  export type PrescriptionItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * The data used to create many PrescriptionItems.
     */
    data: PrescriptionItemCreateManyInput | PrescriptionItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrescriptionItem update
   */
  export type PrescriptionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PrescriptionItem.
     */
    data: XOR<PrescriptionItemUpdateInput, PrescriptionItemUncheckedUpdateInput>
    /**
     * Choose, which PrescriptionItem to update.
     */
    where: PrescriptionItemWhereUniqueInput
  }

  /**
   * PrescriptionItem updateMany
   */
  export type PrescriptionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrescriptionItems.
     */
    data: XOR<PrescriptionItemUpdateManyMutationInput, PrescriptionItemUncheckedUpdateManyInput>
    /**
     * Filter which PrescriptionItems to update
     */
    where?: PrescriptionItemWhereInput
    /**
     * Limit how many PrescriptionItems to update.
     */
    limit?: number
  }

  /**
   * PrescriptionItem updateManyAndReturn
   */
  export type PrescriptionItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * The data used to update PrescriptionItems.
     */
    data: XOR<PrescriptionItemUpdateManyMutationInput, PrescriptionItemUncheckedUpdateManyInput>
    /**
     * Filter which PrescriptionItems to update
     */
    where?: PrescriptionItemWhereInput
    /**
     * Limit how many PrescriptionItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrescriptionItem upsert
   */
  export type PrescriptionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PrescriptionItem to update in case it exists.
     */
    where: PrescriptionItemWhereUniqueInput
    /**
     * In case the PrescriptionItem found by the `where` argument doesn't exist, create a new PrescriptionItem with this data.
     */
    create: XOR<PrescriptionItemCreateInput, PrescriptionItemUncheckedCreateInput>
    /**
     * In case the PrescriptionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionItemUpdateInput, PrescriptionItemUncheckedUpdateInput>
  }

  /**
   * PrescriptionItem delete
   */
  export type PrescriptionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter which PrescriptionItem to delete.
     */
    where: PrescriptionItemWhereUniqueInput
  }

  /**
   * PrescriptionItem deleteMany
   */
  export type PrescriptionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrescriptionItems to delete
     */
    where?: PrescriptionItemWhereInput
    /**
     * Limit how many PrescriptionItems to delete.
     */
    limit?: number
  }

  /**
   * PrescriptionItem without action
   */
  export type PrescriptionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
  }


  /**
   * Model MedicalRecord
   */

  export type AggregateMedicalRecord = {
    _count: MedicalRecordCountAggregateOutputType | null
    _min: MedicalRecordMinAggregateOutputType | null
    _max: MedicalRecordMaxAggregateOutputType | null
  }

  export type MedicalRecordMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    recordType: string | null
    title: string | null
    description: string | null
    date: Date | null
    doctorId: string | null
    updatedById: string | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalRecordMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    recordType: string | null
    title: string | null
    description: string | null
    date: Date | null
    doctorId: string | null
    updatedById: string | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalRecordCountAggregateOutputType = {
    id: number
    patientId: number
    recordType: number
    title: number
    description: number
    date: number
    doctorId: number
    updatedById: number
    isActive: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicalRecordMinAggregateInputType = {
    id?: true
    patientId?: true
    recordType?: true
    title?: true
    description?: true
    date?: true
    doctorId?: true
    updatedById?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalRecordMaxAggregateInputType = {
    id?: true
    patientId?: true
    recordType?: true
    title?: true
    description?: true
    date?: true
    doctorId?: true
    updatedById?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalRecordCountAggregateInputType = {
    id?: true
    patientId?: true
    recordType?: true
    title?: true
    description?: true
    date?: true
    doctorId?: true
    updatedById?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicalRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalRecord to aggregate.
     */
    where?: MedicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalRecords
    **/
    _count?: true | MedicalRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalRecordMaxAggregateInputType
  }

  export type GetMedicalRecordAggregateType<T extends MedicalRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalRecord[P]>
      : GetScalarType<T[P], AggregateMedicalRecord[P]>
  }




  export type MedicalRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalRecordWhereInput
    orderBy?: MedicalRecordOrderByWithAggregationInput | MedicalRecordOrderByWithAggregationInput[]
    by: MedicalRecordScalarFieldEnum[] | MedicalRecordScalarFieldEnum
    having?: MedicalRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalRecordCountAggregateInputType | true
    _min?: MedicalRecordMinAggregateInputType
    _max?: MedicalRecordMaxAggregateInputType
  }

  export type MedicalRecordGroupByOutputType = {
    id: string
    patientId: string
    recordType: string
    title: string
    description: string | null
    date: Date
    doctorId: string | null
    updatedById: string | null
    isActive: boolean
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: MedicalRecordCountAggregateOutputType | null
    _min: MedicalRecordMinAggregateOutputType | null
    _max: MedicalRecordMaxAggregateOutputType | null
  }

  type GetMedicalRecordGroupByPayload<T extends MedicalRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalRecordGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalRecordGroupByOutputType[P]>
        }
      >
    >


  export type MedicalRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    recordType?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    doctorId?: boolean
    updatedById?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | MedicalRecord$doctorArgs<ExtArgs>
    updatedBy?: boolean | MedicalRecord$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["medicalRecord"]>

  export type MedicalRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    recordType?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    doctorId?: boolean
    updatedById?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | MedicalRecord$doctorArgs<ExtArgs>
    updatedBy?: boolean | MedicalRecord$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["medicalRecord"]>

  export type MedicalRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    recordType?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    doctorId?: boolean
    updatedById?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | MedicalRecord$doctorArgs<ExtArgs>
    updatedBy?: boolean | MedicalRecord$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["medicalRecord"]>

  export type MedicalRecordSelectScalar = {
    id?: boolean
    patientId?: boolean
    recordType?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    doctorId?: boolean
    updatedById?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicalRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "recordType" | "title" | "description" | "date" | "doctorId" | "updatedById" | "isActive" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["medicalRecord"]>
  export type MedicalRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | MedicalRecord$doctorArgs<ExtArgs>
    updatedBy?: boolean | MedicalRecord$updatedByArgs<ExtArgs>
  }
  export type MedicalRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | MedicalRecord$doctorArgs<ExtArgs>
    updatedBy?: boolean | MedicalRecord$updatedByArgs<ExtArgs>
  }
  export type MedicalRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | MedicalRecord$doctorArgs<ExtArgs>
    updatedBy?: boolean | MedicalRecord$updatedByArgs<ExtArgs>
  }

  export type $MedicalRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalRecord"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      doctor: Prisma.$UserPayload<ExtArgs> | null
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      recordType: string
      title: string
      description: string | null
      date: Date
      doctorId: string | null
      updatedById: string | null
      isActive: boolean
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicalRecord"]>
    composites: {}
  }

  type MedicalRecordGetPayload<S extends boolean | null | undefined | MedicalRecordDefaultArgs> = $Result.GetResult<Prisma.$MedicalRecordPayload, S>

  type MedicalRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicalRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicalRecordCountAggregateInputType | true
    }

  export interface MedicalRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalRecord'], meta: { name: 'MedicalRecord' } }
    /**
     * Find zero or one MedicalRecord that matches the filter.
     * @param {MedicalRecordFindUniqueArgs} args - Arguments to find a MedicalRecord
     * @example
     * // Get one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalRecordFindUniqueArgs>(args: SelectSubset<T, MedicalRecordFindUniqueArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicalRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicalRecordFindUniqueOrThrowArgs} args - Arguments to find a MedicalRecord
     * @example
     * // Get one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordFindFirstArgs} args - Arguments to find a MedicalRecord
     * @example
     * // Get one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalRecordFindFirstArgs>(args?: SelectSubset<T, MedicalRecordFindFirstArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordFindFirstOrThrowArgs} args - Arguments to find a MedicalRecord
     * @example
     * // Get one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalRecords
     * const medicalRecords = await prisma.medicalRecord.findMany()
     * 
     * // Get first 10 MedicalRecords
     * const medicalRecords = await prisma.medicalRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalRecordWithIdOnly = await prisma.medicalRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicalRecordFindManyArgs>(args?: SelectSubset<T, MedicalRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicalRecord.
     * @param {MedicalRecordCreateArgs} args - Arguments to create a MedicalRecord.
     * @example
     * // Create one MedicalRecord
     * const MedicalRecord = await prisma.medicalRecord.create({
     *   data: {
     *     // ... data to create a MedicalRecord
     *   }
     * })
     * 
     */
    create<T extends MedicalRecordCreateArgs>(args: SelectSubset<T, MedicalRecordCreateArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicalRecords.
     * @param {MedicalRecordCreateManyArgs} args - Arguments to create many MedicalRecords.
     * @example
     * // Create many MedicalRecords
     * const medicalRecord = await prisma.medicalRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalRecordCreateManyArgs>(args?: SelectSubset<T, MedicalRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicalRecords and returns the data saved in the database.
     * @param {MedicalRecordCreateManyAndReturnArgs} args - Arguments to create many MedicalRecords.
     * @example
     * // Create many MedicalRecords
     * const medicalRecord = await prisma.medicalRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicalRecords and only return the `id`
     * const medicalRecordWithIdOnly = await prisma.medicalRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicalRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicalRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicalRecord.
     * @param {MedicalRecordDeleteArgs} args - Arguments to delete one MedicalRecord.
     * @example
     * // Delete one MedicalRecord
     * const MedicalRecord = await prisma.medicalRecord.delete({
     *   where: {
     *     // ... filter to delete one MedicalRecord
     *   }
     * })
     * 
     */
    delete<T extends MedicalRecordDeleteArgs>(args: SelectSubset<T, MedicalRecordDeleteArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicalRecord.
     * @param {MedicalRecordUpdateArgs} args - Arguments to update one MedicalRecord.
     * @example
     * // Update one MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalRecordUpdateArgs>(args: SelectSubset<T, MedicalRecordUpdateArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicalRecords.
     * @param {MedicalRecordDeleteManyArgs} args - Arguments to filter MedicalRecords to delete.
     * @example
     * // Delete a few MedicalRecords
     * const { count } = await prisma.medicalRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalRecordDeleteManyArgs>(args?: SelectSubset<T, MedicalRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalRecords
     * const medicalRecord = await prisma.medicalRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalRecordUpdateManyArgs>(args: SelectSubset<T, MedicalRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalRecords and returns the data updated in the database.
     * @param {MedicalRecordUpdateManyAndReturnArgs} args - Arguments to update many MedicalRecords.
     * @example
     * // Update many MedicalRecords
     * const medicalRecord = await prisma.medicalRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicalRecords and only return the `id`
     * const medicalRecordWithIdOnly = await prisma.medicalRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicalRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicalRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicalRecord.
     * @param {MedicalRecordUpsertArgs} args - Arguments to update or create a MedicalRecord.
     * @example
     * // Update or create a MedicalRecord
     * const medicalRecord = await prisma.medicalRecord.upsert({
     *   create: {
     *     // ... data to create a MedicalRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalRecord we want to update
     *   }
     * })
     */
    upsert<T extends MedicalRecordUpsertArgs>(args: SelectSubset<T, MedicalRecordUpsertArgs<ExtArgs>>): Prisma__MedicalRecordClient<$Result.GetResult<Prisma.$MedicalRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicalRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordCountArgs} args - Arguments to filter MedicalRecords to count.
     * @example
     * // Count the number of MedicalRecords
     * const count = await prisma.medicalRecord.count({
     *   where: {
     *     // ... the filter for the MedicalRecords we want to count
     *   }
     * })
    **/
    count<T extends MedicalRecordCountArgs>(
      args?: Subset<T, MedicalRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalRecordAggregateArgs>(args: Subset<T, MedicalRecordAggregateArgs>): Prisma.PrismaPromise<GetMedicalRecordAggregateType<T>>

    /**
     * Group by MedicalRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalRecordGroupByArgs['orderBy'] }
        : { orderBy?: MedicalRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalRecord model
   */
  readonly fields: MedicalRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends MedicalRecord$doctorArgs<ExtArgs> = {}>(args?: Subset<T, MedicalRecord$doctorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends MedicalRecord$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, MedicalRecord$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalRecord model
   */
  interface MedicalRecordFieldRefs {
    readonly id: FieldRef<"MedicalRecord", 'String'>
    readonly patientId: FieldRef<"MedicalRecord", 'String'>
    readonly recordType: FieldRef<"MedicalRecord", 'String'>
    readonly title: FieldRef<"MedicalRecord", 'String'>
    readonly description: FieldRef<"MedicalRecord", 'String'>
    readonly date: FieldRef<"MedicalRecord", 'DateTime'>
    readonly doctorId: FieldRef<"MedicalRecord", 'String'>
    readonly updatedById: FieldRef<"MedicalRecord", 'String'>
    readonly isActive: FieldRef<"MedicalRecord", 'Boolean'>
    readonly tenantId: FieldRef<"MedicalRecord", 'String'>
    readonly createdAt: FieldRef<"MedicalRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicalRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicalRecord findUnique
   */
  export type MedicalRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecord to fetch.
     */
    where: MedicalRecordWhereUniqueInput
  }

  /**
   * MedicalRecord findUniqueOrThrow
   */
  export type MedicalRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecord to fetch.
     */
    where: MedicalRecordWhereUniqueInput
  }

  /**
   * MedicalRecord findFirst
   */
  export type MedicalRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecord to fetch.
     */
    where?: MedicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalRecords.
     */
    cursor?: MedicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalRecords.
     */
    distinct?: MedicalRecordScalarFieldEnum | MedicalRecordScalarFieldEnum[]
  }

  /**
   * MedicalRecord findFirstOrThrow
   */
  export type MedicalRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecord to fetch.
     */
    where?: MedicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalRecords.
     */
    cursor?: MedicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalRecords.
     */
    distinct?: MedicalRecordScalarFieldEnum | MedicalRecordScalarFieldEnum[]
  }

  /**
   * MedicalRecord findMany
   */
  export type MedicalRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter, which MedicalRecords to fetch.
     */
    where?: MedicalRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalRecords to fetch.
     */
    orderBy?: MedicalRecordOrderByWithRelationInput | MedicalRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalRecords.
     */
    cursor?: MedicalRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalRecords.
     */
    skip?: number
    distinct?: MedicalRecordScalarFieldEnum | MedicalRecordScalarFieldEnum[]
  }

  /**
   * MedicalRecord create
   */
  export type MedicalRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalRecord.
     */
    data: XOR<MedicalRecordCreateInput, MedicalRecordUncheckedCreateInput>
  }

  /**
   * MedicalRecord createMany
   */
  export type MedicalRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalRecords.
     */
    data: MedicalRecordCreateManyInput | MedicalRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicalRecord createManyAndReturn
   */
  export type MedicalRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * The data used to create many MedicalRecords.
     */
    data: MedicalRecordCreateManyInput | MedicalRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalRecord update
   */
  export type MedicalRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalRecord.
     */
    data: XOR<MedicalRecordUpdateInput, MedicalRecordUncheckedUpdateInput>
    /**
     * Choose, which MedicalRecord to update.
     */
    where: MedicalRecordWhereUniqueInput
  }

  /**
   * MedicalRecord updateMany
   */
  export type MedicalRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalRecords.
     */
    data: XOR<MedicalRecordUpdateManyMutationInput, MedicalRecordUncheckedUpdateManyInput>
    /**
     * Filter which MedicalRecords to update
     */
    where?: MedicalRecordWhereInput
    /**
     * Limit how many MedicalRecords to update.
     */
    limit?: number
  }

  /**
   * MedicalRecord updateManyAndReturn
   */
  export type MedicalRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * The data used to update MedicalRecords.
     */
    data: XOR<MedicalRecordUpdateManyMutationInput, MedicalRecordUncheckedUpdateManyInput>
    /**
     * Filter which MedicalRecords to update
     */
    where?: MedicalRecordWhereInput
    /**
     * Limit how many MedicalRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalRecord upsert
   */
  export type MedicalRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalRecord to update in case it exists.
     */
    where: MedicalRecordWhereUniqueInput
    /**
     * In case the MedicalRecord found by the `where` argument doesn't exist, create a new MedicalRecord with this data.
     */
    create: XOR<MedicalRecordCreateInput, MedicalRecordUncheckedCreateInput>
    /**
     * In case the MedicalRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalRecordUpdateInput, MedicalRecordUncheckedUpdateInput>
  }

  /**
   * MedicalRecord delete
   */
  export type MedicalRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
    /**
     * Filter which MedicalRecord to delete.
     */
    where: MedicalRecordWhereUniqueInput
  }

  /**
   * MedicalRecord deleteMany
   */
  export type MedicalRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalRecords to delete
     */
    where?: MedicalRecordWhereInput
    /**
     * Limit how many MedicalRecords to delete.
     */
    limit?: number
  }

  /**
   * MedicalRecord.doctor
   */
  export type MedicalRecord$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MedicalRecord.updatedBy
   */
  export type MedicalRecord$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MedicalRecord without action
   */
  export type MedicalRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalRecord
     */
    select?: MedicalRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalRecord
     */
    omit?: MedicalRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalRecordInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    subTotal: number | null
    taxAmount: number | null
    discountAmount: number | null
    totalAmount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    subTotal: number | null
    taxAmount: number | null
    discountAmount: number | null
    totalAmount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    patientId: string | null
    date: Date | null
    dueDate: Date | null
    status: $Enums.InvoiceStatus | null
    subTotal: number | null
    taxAmount: number | null
    discountAmount: number | null
    totalAmount: number | null
    notes: string | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    patientId: string | null
    date: Date | null
    dueDate: Date | null
    status: $Enums.InvoiceStatus | null
    subTotal: number | null
    taxAmount: number | null
    discountAmount: number | null
    totalAmount: number | null
    notes: string | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    invoiceNumber: number
    patientId: number
    date: number
    dueDate: number
    status: number
    subTotal: number
    taxAmount: number
    discountAmount: number
    totalAmount: number
    notes: number
    tenantId: number
    createdAt: number
    updatedAt: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    subTotal?: true
    taxAmount?: true
    discountAmount?: true
    totalAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    subTotal?: true
    taxAmount?: true
    discountAmount?: true
    totalAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    patientId?: true
    date?: true
    dueDate?: true
    status?: true
    subTotal?: true
    taxAmount?: true
    discountAmount?: true
    totalAmount?: true
    notes?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    patientId?: true
    date?: true
    dueDate?: true
    status?: true
    subTotal?: true
    taxAmount?: true
    discountAmount?: true
    totalAmount?: true
    notes?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    patientId?: true
    date?: true
    dueDate?: true
    status?: true
    subTotal?: true
    taxAmount?: true
    discountAmount?: true
    totalAmount?: true
    notes?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    invoiceNumber: string
    patientId: string
    date: Date
    dueDate: Date
    status: $Enums.InvoiceStatus
    subTotal: number
    taxAmount: number
    discountAmount: number
    totalAmount: number
    notes: string | null
    tenantId: string
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    updatedBy: string | null
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    patientId?: boolean
    date?: boolean
    dueDate?: boolean
    status?: boolean
    subTotal?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    totalAmount?: boolean
    notes?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    invoiceItems?: boolean | Invoice$invoiceItemsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    pharmacyOrder?: boolean | Invoice$pharmacyOrderArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    patientId?: boolean
    date?: boolean
    dueDate?: boolean
    status?: boolean
    subTotal?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    totalAmount?: boolean
    notes?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    patientId?: boolean
    date?: boolean
    dueDate?: boolean
    status?: boolean
    subTotal?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    totalAmount?: boolean
    notes?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    invoiceNumber?: boolean
    patientId?: boolean
    date?: boolean
    dueDate?: boolean
    status?: boolean
    subTotal?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    totalAmount?: boolean
    notes?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNumber" | "patientId" | "date" | "dueDate" | "status" | "subTotal" | "taxAmount" | "discountAmount" | "totalAmount" | "notes" | "tenantId" | "createdAt" | "updatedAt" | "createdBy" | "updatedBy", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    invoiceItems?: boolean | Invoice$invoiceItemsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    pharmacyOrder?: boolean | Invoice$pharmacyOrderArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      invoiceItems: Prisma.$InvoiceItemPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      pharmacyOrder: Prisma.$PharmacyOrderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceNumber: string
      patientId: string
      date: Date
      dueDate: Date
      status: $Enums.InvoiceStatus
      subTotal: number
      taxAmount: number
      discountAmount: number
      totalAmount: number
      notes: string | null
      tenantId: string
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
      updatedBy: string | null
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoiceItems<T extends Invoice$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pharmacyOrder<T extends Invoice$pharmacyOrderArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$pharmacyOrderArgs<ExtArgs>>): Prisma__PharmacyOrderClient<$Result.GetResult<Prisma.$PharmacyOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly patientId: FieldRef<"Invoice", 'String'>
    readonly date: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly subTotal: FieldRef<"Invoice", 'Float'>
    readonly taxAmount: FieldRef<"Invoice", 'Float'>
    readonly discountAmount: FieldRef<"Invoice", 'Float'>
    readonly totalAmount: FieldRef<"Invoice", 'Float'>
    readonly notes: FieldRef<"Invoice", 'String'>
    readonly tenantId: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
    readonly createdBy: FieldRef<"Invoice", 'String'>
    readonly updatedBy: FieldRef<"Invoice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.invoiceItems
   */
  export type Invoice$invoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice.pharmacyOrder
   */
  export type Invoice$pharmacyOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrder
     */
    select?: PharmacyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrder
     */
    omit?: PharmacyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderInclude<ExtArgs> | null
    where?: PharmacyOrderWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    discount: number | null
    taxRate: number | null
    totalAmount: number | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    discount: number | null
    taxRate: number | null
    totalAmount: number | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    itemType: string | null
    itemId: string | null
    description: string | null
    quantity: number | null
    unitPrice: number | null
    discount: number | null
    taxRate: number | null
    totalAmount: number | null
    tenantId: string | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    itemType: string | null
    itemId: string | null
    description: string | null
    quantity: number | null
    unitPrice: number | null
    discount: number | null
    taxRate: number | null
    totalAmount: number | null
    tenantId: string | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    itemType: number
    itemId: number
    description: number
    quantity: number
    unitPrice: number
    discount: number
    taxRate: number
    totalAmount: number
    tenantId: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    discount?: true
    taxRate?: true
    totalAmount?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    discount?: true
    taxRate?: true
    totalAmount?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    itemType?: true
    itemId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    discount?: true
    taxRate?: true
    totalAmount?: true
    tenantId?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    itemType?: true
    itemId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    discount?: true
    taxRate?: true
    totalAmount?: true
    tenantId?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    itemType?: true
    itemId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    discount?: true
    taxRate?: true
    totalAmount?: true
    tenantId?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[]
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type InvoiceItemGroupByOutputType = {
    id: string
    invoiceId: string
    itemType: string
    itemId: string
    description: string
    quantity: number
    unitPrice: number
    discount: number
    taxRate: number
    totalAmount: number
    tenantId: string
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    itemType?: boolean
    itemId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    taxRate?: boolean
    totalAmount?: boolean
    tenantId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    itemType?: boolean
    itemId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    taxRate?: boolean
    totalAmount?: boolean
    tenantId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    itemType?: boolean
    itemId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    taxRate?: boolean
    totalAmount?: boolean
    tenantId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    itemType?: boolean
    itemId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discount?: boolean
    taxRate?: boolean
    totalAmount?: boolean
    tenantId?: boolean
  }

  export type InvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "itemType" | "itemId" | "description" | "quantity" | "unitPrice" | "discount" | "taxRate" | "totalAmount" | "tenantId", ExtArgs["result"]["invoiceItem"]>
  export type InvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceItem"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      itemType: string
      itemId: string
      description: string
      quantity: number
      unitPrice: number
      discount: number
      taxRate: number
      totalAmount: number
      tenantId: string
    }, ExtArgs["result"]["invoiceItem"]>
    composites: {}
  }

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceItemFindManyArgs>(args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceItemCreateArgs>(args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceItemCreateManyArgs>(args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceItems and returns the data saved in the database.
     * @param {InvoiceItemCreateManyAndReturnArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceItemDeleteArgs>(args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceItemUpdateArgs>(args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems and returns the data updated in the database.
     * @param {InvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many InvoiceItems.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceItem model
   */
  readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceItem model
   */
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<"InvoiceItem", 'String'>
    readonly invoiceId: FieldRef<"InvoiceItem", 'String'>
    readonly itemType: FieldRef<"InvoiceItem", 'String'>
    readonly itemId: FieldRef<"InvoiceItem", 'String'>
    readonly description: FieldRef<"InvoiceItem", 'String'>
    readonly quantity: FieldRef<"InvoiceItem", 'Int'>
    readonly unitPrice: FieldRef<"InvoiceItem", 'Float'>
    readonly discount: FieldRef<"InvoiceItem", 'Float'>
    readonly taxRate: FieldRef<"InvoiceItem", 'Float'>
    readonly totalAmount: FieldRef<"InvoiceItem", 'Float'>
    readonly tenantId: FieldRef<"InvoiceItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceItem createManyAndReturn
   */
  export type InvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number
  }

  /**
   * InvoiceItem updateManyAndReturn
   */
  export type InvoiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    paymentNumber: string | null
    invoiceId: string | null
    amount: number | null
    paymentDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    referenceNumber: string | null
    notes: string | null
    status: $Enums.PaymentStatus | null
    tenantId: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    paymentNumber: string | null
    invoiceId: string | null
    amount: number | null
    paymentDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    referenceNumber: string | null
    notes: string | null
    status: $Enums.PaymentStatus | null
    tenantId: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    paymentNumber: number
    invoiceId: number
    amount: number
    paymentDate: number
    paymentMethod: number
    referenceNumber: number
    notes: number
    status: number
    tenantId: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    paymentNumber?: true
    invoiceId?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    referenceNumber?: true
    notes?: true
    status?: true
    tenantId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    paymentNumber?: true
    invoiceId?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    referenceNumber?: true
    notes?: true
    status?: true
    tenantId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    paymentNumber?: true
    invoiceId?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    referenceNumber?: true
    notes?: true
    status?: true
    tenantId?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    paymentNumber: string
    invoiceId: string
    amount: number
    paymentDate: Date
    paymentMethod: $Enums.PaymentMethod
    referenceNumber: string | null
    notes: string | null
    status: $Enums.PaymentStatus
    tenantId: string
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentNumber?: boolean
    invoiceId?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    referenceNumber?: boolean
    notes?: boolean
    status?: boolean
    tenantId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentNumber?: boolean
    invoiceId?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    referenceNumber?: boolean
    notes?: boolean
    status?: boolean
    tenantId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentNumber?: boolean
    invoiceId?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    referenceNumber?: boolean
    notes?: boolean
    status?: boolean
    tenantId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    paymentNumber?: boolean
    invoiceId?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    referenceNumber?: boolean
    notes?: boolean
    status?: boolean
    tenantId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentNumber" | "invoiceId" | "amount" | "paymentDate" | "paymentMethod" | "referenceNumber" | "notes" | "status" | "tenantId" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentNumber: string
      invoiceId: string
      amount: number
      paymentDate: Date
      paymentMethod: $Enums.PaymentMethod
      referenceNumber: string | null
      notes: string | null
      status: $Enums.PaymentStatus
      tenantId: string
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly paymentNumber: FieldRef<"Payment", 'String'>
    readonly invoiceId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly paymentMethod: FieldRef<"Payment", 'PaymentMethod'>
    readonly referenceNumber: FieldRef<"Payment", 'String'>
    readonly notes: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly tenantId: FieldRef<"Payment", 'String'>
    readonly createdBy: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model LabTest
   */

  export type AggregateLabTest = {
    _count: LabTestCountAggregateOutputType | null
    _avg: LabTestAvgAggregateOutputType | null
    _sum: LabTestSumAggregateOutputType | null
    _min: LabTestMinAggregateOutputType | null
    _max: LabTestMaxAggregateOutputType | null
  }

  export type LabTestAvgAggregateOutputType = {
    price: number | null
  }

  export type LabTestSumAggregateOutputType = {
    price: number | null
  }

  export type LabTestMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    category: string | null
    price: number | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LabTestMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    category: string | null
    price: number | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LabTestCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    category: number
    price: number
    isActive: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LabTestAvgAggregateInputType = {
    price?: true
  }

  export type LabTestSumAggregateInputType = {
    price?: true
  }

  export type LabTestMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    category?: true
    price?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LabTestMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    category?: true
    price?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LabTestCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    category?: true
    price?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LabTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabTest to aggregate.
     */
    where?: LabTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabTests to fetch.
     */
    orderBy?: LabTestOrderByWithRelationInput | LabTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabTests
    **/
    _count?: true | LabTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabTestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabTestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabTestMaxAggregateInputType
  }

  export type GetLabTestAggregateType<T extends LabTestAggregateArgs> = {
        [P in keyof T & keyof AggregateLabTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabTest[P]>
      : GetScalarType<T[P], AggregateLabTest[P]>
  }




  export type LabTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabTestWhereInput
    orderBy?: LabTestOrderByWithAggregationInput | LabTestOrderByWithAggregationInput[]
    by: LabTestScalarFieldEnum[] | LabTestScalarFieldEnum
    having?: LabTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabTestCountAggregateInputType | true
    _avg?: LabTestAvgAggregateInputType
    _sum?: LabTestSumAggregateInputType
    _min?: LabTestMinAggregateInputType
    _max?: LabTestMaxAggregateInputType
  }

  export type LabTestGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    category: string
    price: number | null
    isActive: boolean
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: LabTestCountAggregateOutputType | null
    _avg: LabTestAvgAggregateOutputType | null
    _sum: LabTestSumAggregateOutputType | null
    _min: LabTestMinAggregateOutputType | null
    _max: LabTestMaxAggregateOutputType | null
  }

  type GetLabTestGroupByPayload<T extends LabTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabTestGroupByOutputType[P]>
            : GetScalarType<T[P], LabTestGroupByOutputType[P]>
        }
      >
    >


  export type LabTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    category?: boolean
    price?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    labOrders?: boolean | LabTest$labOrdersArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | LabTestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labTest"]>

  export type LabTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    category?: boolean
    price?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labTest"]>

  export type LabTestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    category?: boolean
    price?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labTest"]>

  export type LabTestSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    category?: boolean
    price?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LabTestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "description" | "category" | "price" | "isActive" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["labTest"]>
  export type LabTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labOrders?: boolean | LabTest$labOrdersArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | LabTestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LabTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type LabTestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $LabTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabTest"
    objects: {
      labOrders: Prisma.$LabOrderTestPayload<ExtArgs>[]
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      category: string
      price: number | null
      isActive: boolean
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["labTest"]>
    composites: {}
  }

  type LabTestGetPayload<S extends boolean | null | undefined | LabTestDefaultArgs> = $Result.GetResult<Prisma.$LabTestPayload, S>

  type LabTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabTestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabTestCountAggregateInputType | true
    }

  export interface LabTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabTest'], meta: { name: 'LabTest' } }
    /**
     * Find zero or one LabTest that matches the filter.
     * @param {LabTestFindUniqueArgs} args - Arguments to find a LabTest
     * @example
     * // Get one LabTest
     * const labTest = await prisma.labTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabTestFindUniqueArgs>(args: SelectSubset<T, LabTestFindUniqueArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabTest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabTestFindUniqueOrThrowArgs} args - Arguments to find a LabTest
     * @example
     * // Get one LabTest
     * const labTest = await prisma.labTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabTestFindUniqueOrThrowArgs>(args: SelectSubset<T, LabTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestFindFirstArgs} args - Arguments to find a LabTest
     * @example
     * // Get one LabTest
     * const labTest = await prisma.labTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabTestFindFirstArgs>(args?: SelectSubset<T, LabTestFindFirstArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestFindFirstOrThrowArgs} args - Arguments to find a LabTest
     * @example
     * // Get one LabTest
     * const labTest = await prisma.labTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabTestFindFirstOrThrowArgs>(args?: SelectSubset<T, LabTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabTests
     * const labTests = await prisma.labTest.findMany()
     * 
     * // Get first 10 LabTests
     * const labTests = await prisma.labTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labTestWithIdOnly = await prisma.labTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabTestFindManyArgs>(args?: SelectSubset<T, LabTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabTest.
     * @param {LabTestCreateArgs} args - Arguments to create a LabTest.
     * @example
     * // Create one LabTest
     * const LabTest = await prisma.labTest.create({
     *   data: {
     *     // ... data to create a LabTest
     *   }
     * })
     * 
     */
    create<T extends LabTestCreateArgs>(args: SelectSubset<T, LabTestCreateArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabTests.
     * @param {LabTestCreateManyArgs} args - Arguments to create many LabTests.
     * @example
     * // Create many LabTests
     * const labTest = await prisma.labTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabTestCreateManyArgs>(args?: SelectSubset<T, LabTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabTests and returns the data saved in the database.
     * @param {LabTestCreateManyAndReturnArgs} args - Arguments to create many LabTests.
     * @example
     * // Create many LabTests
     * const labTest = await prisma.labTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabTests and only return the `id`
     * const labTestWithIdOnly = await prisma.labTest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabTestCreateManyAndReturnArgs>(args?: SelectSubset<T, LabTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabTest.
     * @param {LabTestDeleteArgs} args - Arguments to delete one LabTest.
     * @example
     * // Delete one LabTest
     * const LabTest = await prisma.labTest.delete({
     *   where: {
     *     // ... filter to delete one LabTest
     *   }
     * })
     * 
     */
    delete<T extends LabTestDeleteArgs>(args: SelectSubset<T, LabTestDeleteArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabTest.
     * @param {LabTestUpdateArgs} args - Arguments to update one LabTest.
     * @example
     * // Update one LabTest
     * const labTest = await prisma.labTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabTestUpdateArgs>(args: SelectSubset<T, LabTestUpdateArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabTests.
     * @param {LabTestDeleteManyArgs} args - Arguments to filter LabTests to delete.
     * @example
     * // Delete a few LabTests
     * const { count } = await prisma.labTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabTestDeleteManyArgs>(args?: SelectSubset<T, LabTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabTests
     * const labTest = await prisma.labTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabTestUpdateManyArgs>(args: SelectSubset<T, LabTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabTests and returns the data updated in the database.
     * @param {LabTestUpdateManyAndReturnArgs} args - Arguments to update many LabTests.
     * @example
     * // Update many LabTests
     * const labTest = await prisma.labTest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabTests and only return the `id`
     * const labTestWithIdOnly = await prisma.labTest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabTestUpdateManyAndReturnArgs>(args: SelectSubset<T, LabTestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabTest.
     * @param {LabTestUpsertArgs} args - Arguments to update or create a LabTest.
     * @example
     * // Update or create a LabTest
     * const labTest = await prisma.labTest.upsert({
     *   create: {
     *     // ... data to create a LabTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabTest we want to update
     *   }
     * })
     */
    upsert<T extends LabTestUpsertArgs>(args: SelectSubset<T, LabTestUpsertArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestCountArgs} args - Arguments to filter LabTests to count.
     * @example
     * // Count the number of LabTests
     * const count = await prisma.labTest.count({
     *   where: {
     *     // ... the filter for the LabTests we want to count
     *   }
     * })
    **/
    count<T extends LabTestCountArgs>(
      args?: Subset<T, LabTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabTestAggregateArgs>(args: Subset<T, LabTestAggregateArgs>): Prisma.PrismaPromise<GetLabTestAggregateType<T>>

    /**
     * Group by LabTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabTestGroupByArgs['orderBy'] }
        : { orderBy?: LabTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabTest model
   */
  readonly fields: LabTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    labOrders<T extends LabTest$labOrdersArgs<ExtArgs> = {}>(args?: Subset<T, LabTest$labOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabTest model
   */
  interface LabTestFieldRefs {
    readonly id: FieldRef<"LabTest", 'String'>
    readonly name: FieldRef<"LabTest", 'String'>
    readonly code: FieldRef<"LabTest", 'String'>
    readonly description: FieldRef<"LabTest", 'String'>
    readonly category: FieldRef<"LabTest", 'String'>
    readonly price: FieldRef<"LabTest", 'Float'>
    readonly isActive: FieldRef<"LabTest", 'Boolean'>
    readonly tenantId: FieldRef<"LabTest", 'String'>
    readonly createdAt: FieldRef<"LabTest", 'DateTime'>
    readonly updatedAt: FieldRef<"LabTest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LabTest findUnique
   */
  export type LabTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * Filter, which LabTest to fetch.
     */
    where: LabTestWhereUniqueInput
  }

  /**
   * LabTest findUniqueOrThrow
   */
  export type LabTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * Filter, which LabTest to fetch.
     */
    where: LabTestWhereUniqueInput
  }

  /**
   * LabTest findFirst
   */
  export type LabTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * Filter, which LabTest to fetch.
     */
    where?: LabTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabTests to fetch.
     */
    orderBy?: LabTestOrderByWithRelationInput | LabTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabTests.
     */
    cursor?: LabTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabTests.
     */
    distinct?: LabTestScalarFieldEnum | LabTestScalarFieldEnum[]
  }

  /**
   * LabTest findFirstOrThrow
   */
  export type LabTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * Filter, which LabTest to fetch.
     */
    where?: LabTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabTests to fetch.
     */
    orderBy?: LabTestOrderByWithRelationInput | LabTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabTests.
     */
    cursor?: LabTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabTests.
     */
    distinct?: LabTestScalarFieldEnum | LabTestScalarFieldEnum[]
  }

  /**
   * LabTest findMany
   */
  export type LabTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * Filter, which LabTests to fetch.
     */
    where?: LabTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabTests to fetch.
     */
    orderBy?: LabTestOrderByWithRelationInput | LabTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabTests.
     */
    cursor?: LabTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabTests.
     */
    skip?: number
    distinct?: LabTestScalarFieldEnum | LabTestScalarFieldEnum[]
  }

  /**
   * LabTest create
   */
  export type LabTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * The data needed to create a LabTest.
     */
    data: XOR<LabTestCreateInput, LabTestUncheckedCreateInput>
  }

  /**
   * LabTest createMany
   */
  export type LabTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabTests.
     */
    data: LabTestCreateManyInput | LabTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabTest createManyAndReturn
   */
  export type LabTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * The data used to create many LabTests.
     */
    data: LabTestCreateManyInput | LabTestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabTest update
   */
  export type LabTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * The data needed to update a LabTest.
     */
    data: XOR<LabTestUpdateInput, LabTestUncheckedUpdateInput>
    /**
     * Choose, which LabTest to update.
     */
    where: LabTestWhereUniqueInput
  }

  /**
   * LabTest updateMany
   */
  export type LabTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabTests.
     */
    data: XOR<LabTestUpdateManyMutationInput, LabTestUncheckedUpdateManyInput>
    /**
     * Filter which LabTests to update
     */
    where?: LabTestWhereInput
    /**
     * Limit how many LabTests to update.
     */
    limit?: number
  }

  /**
   * LabTest updateManyAndReturn
   */
  export type LabTestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * The data used to update LabTests.
     */
    data: XOR<LabTestUpdateManyMutationInput, LabTestUncheckedUpdateManyInput>
    /**
     * Filter which LabTests to update
     */
    where?: LabTestWhereInput
    /**
     * Limit how many LabTests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabTest upsert
   */
  export type LabTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * The filter to search for the LabTest to update in case it exists.
     */
    where: LabTestWhereUniqueInput
    /**
     * In case the LabTest found by the `where` argument doesn't exist, create a new LabTest with this data.
     */
    create: XOR<LabTestCreateInput, LabTestUncheckedCreateInput>
    /**
     * In case the LabTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabTestUpdateInput, LabTestUncheckedUpdateInput>
  }

  /**
   * LabTest delete
   */
  export type LabTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * Filter which LabTest to delete.
     */
    where: LabTestWhereUniqueInput
  }

  /**
   * LabTest deleteMany
   */
  export type LabTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabTests to delete
     */
    where?: LabTestWhereInput
    /**
     * Limit how many LabTests to delete.
     */
    limit?: number
  }

  /**
   * LabTest.labOrders
   */
  export type LabTest$labOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    where?: LabOrderTestWhereInput
    orderBy?: LabOrderTestOrderByWithRelationInput | LabOrderTestOrderByWithRelationInput[]
    cursor?: LabOrderTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabOrderTestScalarFieldEnum | LabOrderTestScalarFieldEnum[]
  }

  /**
   * LabTest without action
   */
  export type LabTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTest
     */
    omit?: LabTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
  }


  /**
   * Model LabOrder
   */

  export type AggregateLabOrder = {
    _count: LabOrderCountAggregateOutputType | null
    _min: LabOrderMinAggregateOutputType | null
    _max: LabOrderMaxAggregateOutputType | null
  }

  export type LabOrderMinAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    patientId: string | null
    doctorId: string | null
    status: $Enums.LabOrderStatus | null
    orderDate: Date | null
    completedDate: Date | null
    notes: string | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    consultationId: string | null
  }

  export type LabOrderMaxAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    patientId: string | null
    doctorId: string | null
    status: $Enums.LabOrderStatus | null
    orderDate: Date | null
    completedDate: Date | null
    notes: string | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    consultationId: string | null
  }

  export type LabOrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    patientId: number
    doctorId: number
    status: number
    orderDate: number
    completedDate: number
    notes: number
    tenantId: number
    createdAt: number
    updatedAt: number
    consultationId: number
    _all: number
  }


  export type LabOrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    patientId?: true
    doctorId?: true
    status?: true
    orderDate?: true
    completedDate?: true
    notes?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    consultationId?: true
  }

  export type LabOrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    patientId?: true
    doctorId?: true
    status?: true
    orderDate?: true
    completedDate?: true
    notes?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    consultationId?: true
  }

  export type LabOrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    patientId?: true
    doctorId?: true
    status?: true
    orderDate?: true
    completedDate?: true
    notes?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    consultationId?: true
    _all?: true
  }

  export type LabOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabOrder to aggregate.
     */
    where?: LabOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabOrders to fetch.
     */
    orderBy?: LabOrderOrderByWithRelationInput | LabOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabOrders
    **/
    _count?: true | LabOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabOrderMaxAggregateInputType
  }

  export type GetLabOrderAggregateType<T extends LabOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateLabOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabOrder[P]>
      : GetScalarType<T[P], AggregateLabOrder[P]>
  }




  export type LabOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderWhereInput
    orderBy?: LabOrderOrderByWithAggregationInput | LabOrderOrderByWithAggregationInput[]
    by: LabOrderScalarFieldEnum[] | LabOrderScalarFieldEnum
    having?: LabOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabOrderCountAggregateInputType | true
    _min?: LabOrderMinAggregateInputType
    _max?: LabOrderMaxAggregateInputType
  }

  export type LabOrderGroupByOutputType = {
    id: string
    orderNumber: string
    patientId: string
    doctorId: string | null
    status: $Enums.LabOrderStatus
    orderDate: Date
    completedDate: Date | null
    notes: string | null
    tenantId: string
    createdAt: Date
    updatedAt: Date
    consultationId: string | null
    _count: LabOrderCountAggregateOutputType | null
    _min: LabOrderMinAggregateOutputType | null
    _max: LabOrderMaxAggregateOutputType | null
  }

  type GetLabOrderGroupByPayload<T extends LabOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabOrderGroupByOutputType[P]>
            : GetScalarType<T[P], LabOrderGroupByOutputType[P]>
        }
      >
    >


  export type LabOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    patientId?: boolean
    doctorId?: boolean
    status?: boolean
    orderDate?: boolean
    completedDate?: boolean
    notes?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consultationId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    doctor?: boolean | LabOrder$doctorArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    tests?: boolean | LabOrder$testsArgs<ExtArgs>
    consultation?: boolean | LabOrder$consultationArgs<ExtArgs>
    _count?: boolean | LabOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labOrder"]>

  export type LabOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    patientId?: boolean
    doctorId?: boolean
    status?: boolean
    orderDate?: boolean
    completedDate?: boolean
    notes?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consultationId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    doctor?: boolean | LabOrder$doctorArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    consultation?: boolean | LabOrder$consultationArgs<ExtArgs>
  }, ExtArgs["result"]["labOrder"]>

  export type LabOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    patientId?: boolean
    doctorId?: boolean
    status?: boolean
    orderDate?: boolean
    completedDate?: boolean
    notes?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consultationId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    doctor?: boolean | LabOrder$doctorArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    consultation?: boolean | LabOrder$consultationArgs<ExtArgs>
  }, ExtArgs["result"]["labOrder"]>

  export type LabOrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    patientId?: boolean
    doctorId?: boolean
    status?: boolean
    orderDate?: boolean
    completedDate?: boolean
    notes?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consultationId?: boolean
  }

  export type LabOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNumber" | "patientId" | "doctorId" | "status" | "orderDate" | "completedDate" | "notes" | "tenantId" | "createdAt" | "updatedAt" | "consultationId", ExtArgs["result"]["labOrder"]>
  export type LabOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    doctor?: boolean | LabOrder$doctorArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    tests?: boolean | LabOrder$testsArgs<ExtArgs>
    consultation?: boolean | LabOrder$consultationArgs<ExtArgs>
    _count?: boolean | LabOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LabOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    doctor?: boolean | LabOrder$doctorArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    consultation?: boolean | LabOrder$consultationArgs<ExtArgs>
  }
  export type LabOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    doctor?: boolean | LabOrder$doctorArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    consultation?: boolean | LabOrder$consultationArgs<ExtArgs>
  }

  export type $LabOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabOrder"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      doctor: Prisma.$UserPayload<ExtArgs> | null
      patient: Prisma.$PatientPayload<ExtArgs>
      tests: Prisma.$LabOrderTestPayload<ExtArgs>[]
      consultation: Prisma.$TelemedicineConsultationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNumber: string
      patientId: string
      doctorId: string | null
      status: $Enums.LabOrderStatus
      orderDate: Date
      completedDate: Date | null
      notes: string | null
      tenantId: string
      createdAt: Date
      updatedAt: Date
      consultationId: string | null
    }, ExtArgs["result"]["labOrder"]>
    composites: {}
  }

  type LabOrderGetPayload<S extends boolean | null | undefined | LabOrderDefaultArgs> = $Result.GetResult<Prisma.$LabOrderPayload, S>

  type LabOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabOrderCountAggregateInputType | true
    }

  export interface LabOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabOrder'], meta: { name: 'LabOrder' } }
    /**
     * Find zero or one LabOrder that matches the filter.
     * @param {LabOrderFindUniqueArgs} args - Arguments to find a LabOrder
     * @example
     * // Get one LabOrder
     * const labOrder = await prisma.labOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabOrderFindUniqueArgs>(args: SelectSubset<T, LabOrderFindUniqueArgs<ExtArgs>>): Prisma__LabOrderClient<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabOrderFindUniqueOrThrowArgs} args - Arguments to find a LabOrder
     * @example
     * // Get one LabOrder
     * const labOrder = await prisma.labOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, LabOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabOrderClient<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderFindFirstArgs} args - Arguments to find a LabOrder
     * @example
     * // Get one LabOrder
     * const labOrder = await prisma.labOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabOrderFindFirstArgs>(args?: SelectSubset<T, LabOrderFindFirstArgs<ExtArgs>>): Prisma__LabOrderClient<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderFindFirstOrThrowArgs} args - Arguments to find a LabOrder
     * @example
     * // Get one LabOrder
     * const labOrder = await prisma.labOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, LabOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabOrderClient<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabOrders
     * const labOrders = await prisma.labOrder.findMany()
     * 
     * // Get first 10 LabOrders
     * const labOrders = await prisma.labOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labOrderWithIdOnly = await prisma.labOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabOrderFindManyArgs>(args?: SelectSubset<T, LabOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabOrder.
     * @param {LabOrderCreateArgs} args - Arguments to create a LabOrder.
     * @example
     * // Create one LabOrder
     * const LabOrder = await prisma.labOrder.create({
     *   data: {
     *     // ... data to create a LabOrder
     *   }
     * })
     * 
     */
    create<T extends LabOrderCreateArgs>(args: SelectSubset<T, LabOrderCreateArgs<ExtArgs>>): Prisma__LabOrderClient<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabOrders.
     * @param {LabOrderCreateManyArgs} args - Arguments to create many LabOrders.
     * @example
     * // Create many LabOrders
     * const labOrder = await prisma.labOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabOrderCreateManyArgs>(args?: SelectSubset<T, LabOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabOrders and returns the data saved in the database.
     * @param {LabOrderCreateManyAndReturnArgs} args - Arguments to create many LabOrders.
     * @example
     * // Create many LabOrders
     * const labOrder = await prisma.labOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabOrders and only return the `id`
     * const labOrderWithIdOnly = await prisma.labOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, LabOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabOrder.
     * @param {LabOrderDeleteArgs} args - Arguments to delete one LabOrder.
     * @example
     * // Delete one LabOrder
     * const LabOrder = await prisma.labOrder.delete({
     *   where: {
     *     // ... filter to delete one LabOrder
     *   }
     * })
     * 
     */
    delete<T extends LabOrderDeleteArgs>(args: SelectSubset<T, LabOrderDeleteArgs<ExtArgs>>): Prisma__LabOrderClient<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabOrder.
     * @param {LabOrderUpdateArgs} args - Arguments to update one LabOrder.
     * @example
     * // Update one LabOrder
     * const labOrder = await prisma.labOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabOrderUpdateArgs>(args: SelectSubset<T, LabOrderUpdateArgs<ExtArgs>>): Prisma__LabOrderClient<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabOrders.
     * @param {LabOrderDeleteManyArgs} args - Arguments to filter LabOrders to delete.
     * @example
     * // Delete a few LabOrders
     * const { count } = await prisma.labOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabOrderDeleteManyArgs>(args?: SelectSubset<T, LabOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabOrders
     * const labOrder = await prisma.labOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabOrderUpdateManyArgs>(args: SelectSubset<T, LabOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabOrders and returns the data updated in the database.
     * @param {LabOrderUpdateManyAndReturnArgs} args - Arguments to update many LabOrders.
     * @example
     * // Update many LabOrders
     * const labOrder = await prisma.labOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabOrders and only return the `id`
     * const labOrderWithIdOnly = await prisma.labOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, LabOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabOrder.
     * @param {LabOrderUpsertArgs} args - Arguments to update or create a LabOrder.
     * @example
     * // Update or create a LabOrder
     * const labOrder = await prisma.labOrder.upsert({
     *   create: {
     *     // ... data to create a LabOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabOrder we want to update
     *   }
     * })
     */
    upsert<T extends LabOrderUpsertArgs>(args: SelectSubset<T, LabOrderUpsertArgs<ExtArgs>>): Prisma__LabOrderClient<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderCountArgs} args - Arguments to filter LabOrders to count.
     * @example
     * // Count the number of LabOrders
     * const count = await prisma.labOrder.count({
     *   where: {
     *     // ... the filter for the LabOrders we want to count
     *   }
     * })
    **/
    count<T extends LabOrderCountArgs>(
      args?: Subset<T, LabOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabOrderAggregateArgs>(args: Subset<T, LabOrderAggregateArgs>): Prisma.PrismaPromise<GetLabOrderAggregateType<T>>

    /**
     * Group by LabOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabOrderGroupByArgs['orderBy'] }
        : { orderBy?: LabOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabOrder model
   */
  readonly fields: LabOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends LabOrder$doctorArgs<ExtArgs> = {}>(args?: Subset<T, LabOrder$doctorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tests<T extends LabOrder$testsArgs<ExtArgs> = {}>(args?: Subset<T, LabOrder$testsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    consultation<T extends LabOrder$consultationArgs<ExtArgs> = {}>(args?: Subset<T, LabOrder$consultationArgs<ExtArgs>>): Prisma__TelemedicineConsultationClient<$Result.GetResult<Prisma.$TelemedicineConsultationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabOrder model
   */
  interface LabOrderFieldRefs {
    readonly id: FieldRef<"LabOrder", 'String'>
    readonly orderNumber: FieldRef<"LabOrder", 'String'>
    readonly patientId: FieldRef<"LabOrder", 'String'>
    readonly doctorId: FieldRef<"LabOrder", 'String'>
    readonly status: FieldRef<"LabOrder", 'LabOrderStatus'>
    readonly orderDate: FieldRef<"LabOrder", 'DateTime'>
    readonly completedDate: FieldRef<"LabOrder", 'DateTime'>
    readonly notes: FieldRef<"LabOrder", 'String'>
    readonly tenantId: FieldRef<"LabOrder", 'String'>
    readonly createdAt: FieldRef<"LabOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"LabOrder", 'DateTime'>
    readonly consultationId: FieldRef<"LabOrder", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LabOrder findUnique
   */
  export type LabOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    /**
     * Filter, which LabOrder to fetch.
     */
    where: LabOrderWhereUniqueInput
  }

  /**
   * LabOrder findUniqueOrThrow
   */
  export type LabOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    /**
     * Filter, which LabOrder to fetch.
     */
    where: LabOrderWhereUniqueInput
  }

  /**
   * LabOrder findFirst
   */
  export type LabOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    /**
     * Filter, which LabOrder to fetch.
     */
    where?: LabOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabOrders to fetch.
     */
    orderBy?: LabOrderOrderByWithRelationInput | LabOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabOrders.
     */
    cursor?: LabOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabOrders.
     */
    distinct?: LabOrderScalarFieldEnum | LabOrderScalarFieldEnum[]
  }

  /**
   * LabOrder findFirstOrThrow
   */
  export type LabOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    /**
     * Filter, which LabOrder to fetch.
     */
    where?: LabOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabOrders to fetch.
     */
    orderBy?: LabOrderOrderByWithRelationInput | LabOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabOrders.
     */
    cursor?: LabOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabOrders.
     */
    distinct?: LabOrderScalarFieldEnum | LabOrderScalarFieldEnum[]
  }

  /**
   * LabOrder findMany
   */
  export type LabOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    /**
     * Filter, which LabOrders to fetch.
     */
    where?: LabOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabOrders to fetch.
     */
    orderBy?: LabOrderOrderByWithRelationInput | LabOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabOrders.
     */
    cursor?: LabOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabOrders.
     */
    skip?: number
    distinct?: LabOrderScalarFieldEnum | LabOrderScalarFieldEnum[]
  }

  /**
   * LabOrder create
   */
  export type LabOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a LabOrder.
     */
    data: XOR<LabOrderCreateInput, LabOrderUncheckedCreateInput>
  }

  /**
   * LabOrder createMany
   */
  export type LabOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabOrders.
     */
    data: LabOrderCreateManyInput | LabOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabOrder createManyAndReturn
   */
  export type LabOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * The data used to create many LabOrders.
     */
    data: LabOrderCreateManyInput | LabOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabOrder update
   */
  export type LabOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a LabOrder.
     */
    data: XOR<LabOrderUpdateInput, LabOrderUncheckedUpdateInput>
    /**
     * Choose, which LabOrder to update.
     */
    where: LabOrderWhereUniqueInput
  }

  /**
   * LabOrder updateMany
   */
  export type LabOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabOrders.
     */
    data: XOR<LabOrderUpdateManyMutationInput, LabOrderUncheckedUpdateManyInput>
    /**
     * Filter which LabOrders to update
     */
    where?: LabOrderWhereInput
    /**
     * Limit how many LabOrders to update.
     */
    limit?: number
  }

  /**
   * LabOrder updateManyAndReturn
   */
  export type LabOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * The data used to update LabOrders.
     */
    data: XOR<LabOrderUpdateManyMutationInput, LabOrderUncheckedUpdateManyInput>
    /**
     * Filter which LabOrders to update
     */
    where?: LabOrderWhereInput
    /**
     * Limit how many LabOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabOrder upsert
   */
  export type LabOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the LabOrder to update in case it exists.
     */
    where: LabOrderWhereUniqueInput
    /**
     * In case the LabOrder found by the `where` argument doesn't exist, create a new LabOrder with this data.
     */
    create: XOR<LabOrderCreateInput, LabOrderUncheckedCreateInput>
    /**
     * In case the LabOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabOrderUpdateInput, LabOrderUncheckedUpdateInput>
  }

  /**
   * LabOrder delete
   */
  export type LabOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    /**
     * Filter which LabOrder to delete.
     */
    where: LabOrderWhereUniqueInput
  }

  /**
   * LabOrder deleteMany
   */
  export type LabOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabOrders to delete
     */
    where?: LabOrderWhereInput
    /**
     * Limit how many LabOrders to delete.
     */
    limit?: number
  }

  /**
   * LabOrder.doctor
   */
  export type LabOrder$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LabOrder.tests
   */
  export type LabOrder$testsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    where?: LabOrderTestWhereInput
    orderBy?: LabOrderTestOrderByWithRelationInput | LabOrderTestOrderByWithRelationInput[]
    cursor?: LabOrderTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabOrderTestScalarFieldEnum | LabOrderTestScalarFieldEnum[]
  }

  /**
   * LabOrder.consultation
   */
  export type LabOrder$consultationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelemedicineConsultation
     */
    select?: TelemedicineConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelemedicineConsultation
     */
    omit?: TelemedicineConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemedicineConsultationInclude<ExtArgs> | null
    where?: TelemedicineConsultationWhereInput
  }

  /**
   * LabOrder without action
   */
  export type LabOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
  }


  /**
   * Model LabOrderTest
   */

  export type AggregateLabOrderTest = {
    _count: LabOrderTestCountAggregateOutputType | null
    _min: LabOrderTestMinAggregateOutputType | null
    _max: LabOrderTestMaxAggregateOutputType | null
  }

  export type LabOrderTestMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    testId: string | null
    status: $Enums.LabTestStatus | null
    result: string | null
    resultDate: Date | null
    referenceRange: string | null
    notes: string | null
    tenantId: string | null
  }

  export type LabOrderTestMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    testId: string | null
    status: $Enums.LabTestStatus | null
    result: string | null
    resultDate: Date | null
    referenceRange: string | null
    notes: string | null
    tenantId: string | null
  }

  export type LabOrderTestCountAggregateOutputType = {
    id: number
    orderId: number
    testId: number
    status: number
    result: number
    resultDate: number
    referenceRange: number
    notes: number
    tenantId: number
    _all: number
  }


  export type LabOrderTestMinAggregateInputType = {
    id?: true
    orderId?: true
    testId?: true
    status?: true
    result?: true
    resultDate?: true
    referenceRange?: true
    notes?: true
    tenantId?: true
  }

  export type LabOrderTestMaxAggregateInputType = {
    id?: true
    orderId?: true
    testId?: true
    status?: true
    result?: true
    resultDate?: true
    referenceRange?: true
    notes?: true
    tenantId?: true
  }

  export type LabOrderTestCountAggregateInputType = {
    id?: true
    orderId?: true
    testId?: true
    status?: true
    result?: true
    resultDate?: true
    referenceRange?: true
    notes?: true
    tenantId?: true
    _all?: true
  }

  export type LabOrderTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabOrderTest to aggregate.
     */
    where?: LabOrderTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabOrderTests to fetch.
     */
    orderBy?: LabOrderTestOrderByWithRelationInput | LabOrderTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabOrderTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabOrderTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabOrderTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabOrderTests
    **/
    _count?: true | LabOrderTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabOrderTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabOrderTestMaxAggregateInputType
  }

  export type GetLabOrderTestAggregateType<T extends LabOrderTestAggregateArgs> = {
        [P in keyof T & keyof AggregateLabOrderTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabOrderTest[P]>
      : GetScalarType<T[P], AggregateLabOrderTest[P]>
  }




  export type LabOrderTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabOrderTestWhereInput
    orderBy?: LabOrderTestOrderByWithAggregationInput | LabOrderTestOrderByWithAggregationInput[]
    by: LabOrderTestScalarFieldEnum[] | LabOrderTestScalarFieldEnum
    having?: LabOrderTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabOrderTestCountAggregateInputType | true
    _min?: LabOrderTestMinAggregateInputType
    _max?: LabOrderTestMaxAggregateInputType
  }

  export type LabOrderTestGroupByOutputType = {
    id: string
    orderId: string
    testId: string
    status: $Enums.LabTestStatus
    result: string | null
    resultDate: Date | null
    referenceRange: string | null
    notes: string | null
    tenantId: string
    _count: LabOrderTestCountAggregateOutputType | null
    _min: LabOrderTestMinAggregateOutputType | null
    _max: LabOrderTestMaxAggregateOutputType | null
  }

  type GetLabOrderTestGroupByPayload<T extends LabOrderTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabOrderTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabOrderTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabOrderTestGroupByOutputType[P]>
            : GetScalarType<T[P], LabOrderTestGroupByOutputType[P]>
        }
      >
    >


  export type LabOrderTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    testId?: boolean
    status?: boolean
    result?: boolean
    resultDate?: boolean
    referenceRange?: boolean
    notes?: boolean
    tenantId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    test?: boolean | LabTestDefaultArgs<ExtArgs>
    order?: boolean | LabOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labOrderTest"]>

  export type LabOrderTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    testId?: boolean
    status?: boolean
    result?: boolean
    resultDate?: boolean
    referenceRange?: boolean
    notes?: boolean
    tenantId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    test?: boolean | LabTestDefaultArgs<ExtArgs>
    order?: boolean | LabOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labOrderTest"]>

  export type LabOrderTestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    testId?: boolean
    status?: boolean
    result?: boolean
    resultDate?: boolean
    referenceRange?: boolean
    notes?: boolean
    tenantId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    test?: boolean | LabTestDefaultArgs<ExtArgs>
    order?: boolean | LabOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labOrderTest"]>

  export type LabOrderTestSelectScalar = {
    id?: boolean
    orderId?: boolean
    testId?: boolean
    status?: boolean
    result?: boolean
    resultDate?: boolean
    referenceRange?: boolean
    notes?: boolean
    tenantId?: boolean
  }

  export type LabOrderTestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "testId" | "status" | "result" | "resultDate" | "referenceRange" | "notes" | "tenantId", ExtArgs["result"]["labOrderTest"]>
  export type LabOrderTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    test?: boolean | LabTestDefaultArgs<ExtArgs>
    order?: boolean | LabOrderDefaultArgs<ExtArgs>
  }
  export type LabOrderTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    test?: boolean | LabTestDefaultArgs<ExtArgs>
    order?: boolean | LabOrderDefaultArgs<ExtArgs>
  }
  export type LabOrderTestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    test?: boolean | LabTestDefaultArgs<ExtArgs>
    order?: boolean | LabOrderDefaultArgs<ExtArgs>
  }

  export type $LabOrderTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabOrderTest"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      test: Prisma.$LabTestPayload<ExtArgs>
      order: Prisma.$LabOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      testId: string
      status: $Enums.LabTestStatus
      result: string | null
      resultDate: Date | null
      referenceRange: string | null
      notes: string | null
      tenantId: string
    }, ExtArgs["result"]["labOrderTest"]>
    composites: {}
  }

  type LabOrderTestGetPayload<S extends boolean | null | undefined | LabOrderTestDefaultArgs> = $Result.GetResult<Prisma.$LabOrderTestPayload, S>

  type LabOrderTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabOrderTestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabOrderTestCountAggregateInputType | true
    }

  export interface LabOrderTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabOrderTest'], meta: { name: 'LabOrderTest' } }
    /**
     * Find zero or one LabOrderTest that matches the filter.
     * @param {LabOrderTestFindUniqueArgs} args - Arguments to find a LabOrderTest
     * @example
     * // Get one LabOrderTest
     * const labOrderTest = await prisma.labOrderTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabOrderTestFindUniqueArgs>(args: SelectSubset<T, LabOrderTestFindUniqueArgs<ExtArgs>>): Prisma__LabOrderTestClient<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabOrderTest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabOrderTestFindUniqueOrThrowArgs} args - Arguments to find a LabOrderTest
     * @example
     * // Get one LabOrderTest
     * const labOrderTest = await prisma.labOrderTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabOrderTestFindUniqueOrThrowArgs>(args: SelectSubset<T, LabOrderTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabOrderTestClient<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabOrderTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderTestFindFirstArgs} args - Arguments to find a LabOrderTest
     * @example
     * // Get one LabOrderTest
     * const labOrderTest = await prisma.labOrderTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabOrderTestFindFirstArgs>(args?: SelectSubset<T, LabOrderTestFindFirstArgs<ExtArgs>>): Prisma__LabOrderTestClient<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabOrderTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderTestFindFirstOrThrowArgs} args - Arguments to find a LabOrderTest
     * @example
     * // Get one LabOrderTest
     * const labOrderTest = await prisma.labOrderTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabOrderTestFindFirstOrThrowArgs>(args?: SelectSubset<T, LabOrderTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabOrderTestClient<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabOrderTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabOrderTests
     * const labOrderTests = await prisma.labOrderTest.findMany()
     * 
     * // Get first 10 LabOrderTests
     * const labOrderTests = await prisma.labOrderTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labOrderTestWithIdOnly = await prisma.labOrderTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabOrderTestFindManyArgs>(args?: SelectSubset<T, LabOrderTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabOrderTest.
     * @param {LabOrderTestCreateArgs} args - Arguments to create a LabOrderTest.
     * @example
     * // Create one LabOrderTest
     * const LabOrderTest = await prisma.labOrderTest.create({
     *   data: {
     *     // ... data to create a LabOrderTest
     *   }
     * })
     * 
     */
    create<T extends LabOrderTestCreateArgs>(args: SelectSubset<T, LabOrderTestCreateArgs<ExtArgs>>): Prisma__LabOrderTestClient<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabOrderTests.
     * @param {LabOrderTestCreateManyArgs} args - Arguments to create many LabOrderTests.
     * @example
     * // Create many LabOrderTests
     * const labOrderTest = await prisma.labOrderTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabOrderTestCreateManyArgs>(args?: SelectSubset<T, LabOrderTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabOrderTests and returns the data saved in the database.
     * @param {LabOrderTestCreateManyAndReturnArgs} args - Arguments to create many LabOrderTests.
     * @example
     * // Create many LabOrderTests
     * const labOrderTest = await prisma.labOrderTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabOrderTests and only return the `id`
     * const labOrderTestWithIdOnly = await prisma.labOrderTest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabOrderTestCreateManyAndReturnArgs>(args?: SelectSubset<T, LabOrderTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabOrderTest.
     * @param {LabOrderTestDeleteArgs} args - Arguments to delete one LabOrderTest.
     * @example
     * // Delete one LabOrderTest
     * const LabOrderTest = await prisma.labOrderTest.delete({
     *   where: {
     *     // ... filter to delete one LabOrderTest
     *   }
     * })
     * 
     */
    delete<T extends LabOrderTestDeleteArgs>(args: SelectSubset<T, LabOrderTestDeleteArgs<ExtArgs>>): Prisma__LabOrderTestClient<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabOrderTest.
     * @param {LabOrderTestUpdateArgs} args - Arguments to update one LabOrderTest.
     * @example
     * // Update one LabOrderTest
     * const labOrderTest = await prisma.labOrderTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabOrderTestUpdateArgs>(args: SelectSubset<T, LabOrderTestUpdateArgs<ExtArgs>>): Prisma__LabOrderTestClient<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabOrderTests.
     * @param {LabOrderTestDeleteManyArgs} args - Arguments to filter LabOrderTests to delete.
     * @example
     * // Delete a few LabOrderTests
     * const { count } = await prisma.labOrderTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabOrderTestDeleteManyArgs>(args?: SelectSubset<T, LabOrderTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabOrderTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabOrderTests
     * const labOrderTest = await prisma.labOrderTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabOrderTestUpdateManyArgs>(args: SelectSubset<T, LabOrderTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabOrderTests and returns the data updated in the database.
     * @param {LabOrderTestUpdateManyAndReturnArgs} args - Arguments to update many LabOrderTests.
     * @example
     * // Update many LabOrderTests
     * const labOrderTest = await prisma.labOrderTest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabOrderTests and only return the `id`
     * const labOrderTestWithIdOnly = await prisma.labOrderTest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabOrderTestUpdateManyAndReturnArgs>(args: SelectSubset<T, LabOrderTestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabOrderTest.
     * @param {LabOrderTestUpsertArgs} args - Arguments to update or create a LabOrderTest.
     * @example
     * // Update or create a LabOrderTest
     * const labOrderTest = await prisma.labOrderTest.upsert({
     *   create: {
     *     // ... data to create a LabOrderTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabOrderTest we want to update
     *   }
     * })
     */
    upsert<T extends LabOrderTestUpsertArgs>(args: SelectSubset<T, LabOrderTestUpsertArgs<ExtArgs>>): Prisma__LabOrderTestClient<$Result.GetResult<Prisma.$LabOrderTestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabOrderTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderTestCountArgs} args - Arguments to filter LabOrderTests to count.
     * @example
     * // Count the number of LabOrderTests
     * const count = await prisma.labOrderTest.count({
     *   where: {
     *     // ... the filter for the LabOrderTests we want to count
     *   }
     * })
    **/
    count<T extends LabOrderTestCountArgs>(
      args?: Subset<T, LabOrderTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabOrderTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabOrderTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabOrderTestAggregateArgs>(args: Subset<T, LabOrderTestAggregateArgs>): Prisma.PrismaPromise<GetLabOrderTestAggregateType<T>>

    /**
     * Group by LabOrderTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabOrderTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabOrderTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabOrderTestGroupByArgs['orderBy'] }
        : { orderBy?: LabOrderTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabOrderTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabOrderTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabOrderTest model
   */
  readonly fields: LabOrderTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabOrderTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabOrderTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    test<T extends LabTestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabTestDefaultArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends LabOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabOrderDefaultArgs<ExtArgs>>): Prisma__LabOrderClient<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabOrderTest model
   */
  interface LabOrderTestFieldRefs {
    readonly id: FieldRef<"LabOrderTest", 'String'>
    readonly orderId: FieldRef<"LabOrderTest", 'String'>
    readonly testId: FieldRef<"LabOrderTest", 'String'>
    readonly status: FieldRef<"LabOrderTest", 'LabTestStatus'>
    readonly result: FieldRef<"LabOrderTest", 'String'>
    readonly resultDate: FieldRef<"LabOrderTest", 'DateTime'>
    readonly referenceRange: FieldRef<"LabOrderTest", 'String'>
    readonly notes: FieldRef<"LabOrderTest", 'String'>
    readonly tenantId: FieldRef<"LabOrderTest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LabOrderTest findUnique
   */
  export type LabOrderTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    /**
     * Filter, which LabOrderTest to fetch.
     */
    where: LabOrderTestWhereUniqueInput
  }

  /**
   * LabOrderTest findUniqueOrThrow
   */
  export type LabOrderTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    /**
     * Filter, which LabOrderTest to fetch.
     */
    where: LabOrderTestWhereUniqueInput
  }

  /**
   * LabOrderTest findFirst
   */
  export type LabOrderTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    /**
     * Filter, which LabOrderTest to fetch.
     */
    where?: LabOrderTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabOrderTests to fetch.
     */
    orderBy?: LabOrderTestOrderByWithRelationInput | LabOrderTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabOrderTests.
     */
    cursor?: LabOrderTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabOrderTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabOrderTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabOrderTests.
     */
    distinct?: LabOrderTestScalarFieldEnum | LabOrderTestScalarFieldEnum[]
  }

  /**
   * LabOrderTest findFirstOrThrow
   */
  export type LabOrderTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    /**
     * Filter, which LabOrderTest to fetch.
     */
    where?: LabOrderTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabOrderTests to fetch.
     */
    orderBy?: LabOrderTestOrderByWithRelationInput | LabOrderTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabOrderTests.
     */
    cursor?: LabOrderTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabOrderTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabOrderTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabOrderTests.
     */
    distinct?: LabOrderTestScalarFieldEnum | LabOrderTestScalarFieldEnum[]
  }

  /**
   * LabOrderTest findMany
   */
  export type LabOrderTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    /**
     * Filter, which LabOrderTests to fetch.
     */
    where?: LabOrderTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabOrderTests to fetch.
     */
    orderBy?: LabOrderTestOrderByWithRelationInput | LabOrderTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabOrderTests.
     */
    cursor?: LabOrderTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabOrderTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabOrderTests.
     */
    skip?: number
    distinct?: LabOrderTestScalarFieldEnum | LabOrderTestScalarFieldEnum[]
  }

  /**
   * LabOrderTest create
   */
  export type LabOrderTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    /**
     * The data needed to create a LabOrderTest.
     */
    data: XOR<LabOrderTestCreateInput, LabOrderTestUncheckedCreateInput>
  }

  /**
   * LabOrderTest createMany
   */
  export type LabOrderTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabOrderTests.
     */
    data: LabOrderTestCreateManyInput | LabOrderTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabOrderTest createManyAndReturn
   */
  export type LabOrderTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * The data used to create many LabOrderTests.
     */
    data: LabOrderTestCreateManyInput | LabOrderTestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabOrderTest update
   */
  export type LabOrderTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    /**
     * The data needed to update a LabOrderTest.
     */
    data: XOR<LabOrderTestUpdateInput, LabOrderTestUncheckedUpdateInput>
    /**
     * Choose, which LabOrderTest to update.
     */
    where: LabOrderTestWhereUniqueInput
  }

  /**
   * LabOrderTest updateMany
   */
  export type LabOrderTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabOrderTests.
     */
    data: XOR<LabOrderTestUpdateManyMutationInput, LabOrderTestUncheckedUpdateManyInput>
    /**
     * Filter which LabOrderTests to update
     */
    where?: LabOrderTestWhereInput
    /**
     * Limit how many LabOrderTests to update.
     */
    limit?: number
  }

  /**
   * LabOrderTest updateManyAndReturn
   */
  export type LabOrderTestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * The data used to update LabOrderTests.
     */
    data: XOR<LabOrderTestUpdateManyMutationInput, LabOrderTestUncheckedUpdateManyInput>
    /**
     * Filter which LabOrderTests to update
     */
    where?: LabOrderTestWhereInput
    /**
     * Limit how many LabOrderTests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabOrderTest upsert
   */
  export type LabOrderTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    /**
     * The filter to search for the LabOrderTest to update in case it exists.
     */
    where: LabOrderTestWhereUniqueInput
    /**
     * In case the LabOrderTest found by the `where` argument doesn't exist, create a new LabOrderTest with this data.
     */
    create: XOR<LabOrderTestCreateInput, LabOrderTestUncheckedCreateInput>
    /**
     * In case the LabOrderTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabOrderTestUpdateInput, LabOrderTestUncheckedUpdateInput>
  }

  /**
   * LabOrderTest delete
   */
  export type LabOrderTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
    /**
     * Filter which LabOrderTest to delete.
     */
    where: LabOrderTestWhereUniqueInput
  }

  /**
   * LabOrderTest deleteMany
   */
  export type LabOrderTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabOrderTests to delete
     */
    where?: LabOrderTestWhereInput
    /**
     * Limit how many LabOrderTests to delete.
     */
    limit?: number
  }

  /**
   * LabOrderTest without action
   */
  export type LabOrderTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrderTest
     */
    select?: LabOrderTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrderTest
     */
    omit?: LabOrderTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderTestInclude<ExtArgs> | null
  }


  /**
   * Model Medication
   */

  export type AggregateMedication = {
    _count: MedicationCountAggregateOutputType | null
    _min: MedicationMinAggregateOutputType | null
    _max: MedicationMaxAggregateOutputType | null
  }

  export type MedicationMinAggregateOutputType = {
    id: string | null
    name: string | null
    genericName: string | null
    description: string | null
    strength: string | null
    unit: string | null
    dosageForm: string | null
    route: string | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    genericName: string | null
    description: string | null
    strength: string | null
    unit: string | null
    dosageForm: string | null
    route: string | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicationCountAggregateOutputType = {
    id: number
    name: number
    genericName: number
    description: number
    strength: number
    unit: number
    dosageForm: number
    route: number
    schedule: number
    isActive: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicationMinAggregateInputType = {
    id?: true
    name?: true
    genericName?: true
    description?: true
    strength?: true
    unit?: true
    dosageForm?: true
    route?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicationMaxAggregateInputType = {
    id?: true
    name?: true
    genericName?: true
    description?: true
    strength?: true
    unit?: true
    dosageForm?: true
    route?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicationCountAggregateInputType = {
    id?: true
    name?: true
    genericName?: true
    description?: true
    strength?: true
    unit?: true
    dosageForm?: true
    route?: true
    schedule?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medication to aggregate.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Medications
    **/
    _count?: true | MedicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicationMaxAggregateInputType
  }

  export type GetMedicationAggregateType<T extends MedicationAggregateArgs> = {
        [P in keyof T & keyof AggregateMedication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedication[P]>
      : GetScalarType<T[P], AggregateMedication[P]>
  }




  export type MedicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationWhereInput
    orderBy?: MedicationOrderByWithAggregationInput | MedicationOrderByWithAggregationInput[]
    by: MedicationScalarFieldEnum[] | MedicationScalarFieldEnum
    having?: MedicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicationCountAggregateInputType | true
    _min?: MedicationMinAggregateInputType
    _max?: MedicationMaxAggregateInputType
  }

  export type MedicationGroupByOutputType = {
    id: string
    name: string
    genericName: string | null
    description: string | null
    strength: string | null
    unit: string | null
    dosageForm: string | null
    route: string | null
    schedule: JsonValue | null
    isActive: boolean
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: MedicationCountAggregateOutputType | null
    _min: MedicationMinAggregateOutputType | null
    _max: MedicationMaxAggregateOutputType | null
  }

  type GetMedicationGroupByPayload<T extends MedicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicationGroupByOutputType[P]>
            : GetScalarType<T[P], MedicationGroupByOutputType[P]>
        }
      >
    >


  export type MedicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    genericName?: boolean
    description?: boolean
    strength?: boolean
    unit?: boolean
    dosageForm?: boolean
    route?: boolean
    schedule?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    pharmacyOrderItems?: boolean | Medication$pharmacyOrderItemsArgs<ExtArgs>
    prescriptionItems?: boolean | Medication$prescriptionItemsArgs<ExtArgs>
    _count?: boolean | MedicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medication"]>

  export type MedicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    genericName?: boolean
    description?: boolean
    strength?: boolean
    unit?: boolean
    dosageForm?: boolean
    route?: boolean
    schedule?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medication"]>

  export type MedicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    genericName?: boolean
    description?: boolean
    strength?: boolean
    unit?: boolean
    dosageForm?: boolean
    route?: boolean
    schedule?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medication"]>

  export type MedicationSelectScalar = {
    id?: boolean
    name?: boolean
    genericName?: boolean
    description?: boolean
    strength?: boolean
    unit?: boolean
    dosageForm?: boolean
    route?: boolean
    schedule?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "genericName" | "description" | "strength" | "unit" | "dosageForm" | "route" | "schedule" | "isActive" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["medication"]>
  export type MedicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    pharmacyOrderItems?: boolean | Medication$pharmacyOrderItemsArgs<ExtArgs>
    prescriptionItems?: boolean | Medication$prescriptionItemsArgs<ExtArgs>
    _count?: boolean | MedicationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MedicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type MedicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $MedicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Medication"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      pharmacyOrderItems: Prisma.$PharmacyOrderItemPayload<ExtArgs>[]
      prescriptionItems: Prisma.$PrescriptionItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      genericName: string | null
      description: string | null
      strength: string | null
      unit: string | null
      dosageForm: string | null
      route: string | null
      schedule: Prisma.JsonValue | null
      isActive: boolean
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medication"]>
    composites: {}
  }

  type MedicationGetPayload<S extends boolean | null | undefined | MedicationDefaultArgs> = $Result.GetResult<Prisma.$MedicationPayload, S>

  type MedicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicationCountAggregateInputType | true
    }

  export interface MedicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Medication'], meta: { name: 'Medication' } }
    /**
     * Find zero or one Medication that matches the filter.
     * @param {MedicationFindUniqueArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicationFindUniqueArgs>(args: SelectSubset<T, MedicationFindUniqueArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Medication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicationFindUniqueOrThrowArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicationFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindFirstArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicationFindFirstArgs>(args?: SelectSubset<T, MedicationFindFirstArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindFirstOrThrowArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicationFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Medications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medications
     * const medications = await prisma.medication.findMany()
     * 
     * // Get first 10 Medications
     * const medications = await prisma.medication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicationWithIdOnly = await prisma.medication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicationFindManyArgs>(args?: SelectSubset<T, MedicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Medication.
     * @param {MedicationCreateArgs} args - Arguments to create a Medication.
     * @example
     * // Create one Medication
     * const Medication = await prisma.medication.create({
     *   data: {
     *     // ... data to create a Medication
     *   }
     * })
     * 
     */
    create<T extends MedicationCreateArgs>(args: SelectSubset<T, MedicationCreateArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Medications.
     * @param {MedicationCreateManyArgs} args - Arguments to create many Medications.
     * @example
     * // Create many Medications
     * const medication = await prisma.medication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicationCreateManyArgs>(args?: SelectSubset<T, MedicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medications and returns the data saved in the database.
     * @param {MedicationCreateManyAndReturnArgs} args - Arguments to create many Medications.
     * @example
     * // Create many Medications
     * const medication = await prisma.medication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medications and only return the `id`
     * const medicationWithIdOnly = await prisma.medication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicationCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Medication.
     * @param {MedicationDeleteArgs} args - Arguments to delete one Medication.
     * @example
     * // Delete one Medication
     * const Medication = await prisma.medication.delete({
     *   where: {
     *     // ... filter to delete one Medication
     *   }
     * })
     * 
     */
    delete<T extends MedicationDeleteArgs>(args: SelectSubset<T, MedicationDeleteArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Medication.
     * @param {MedicationUpdateArgs} args - Arguments to update one Medication.
     * @example
     * // Update one Medication
     * const medication = await prisma.medication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicationUpdateArgs>(args: SelectSubset<T, MedicationUpdateArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Medications.
     * @param {MedicationDeleteManyArgs} args - Arguments to filter Medications to delete.
     * @example
     * // Delete a few Medications
     * const { count } = await prisma.medication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicationDeleteManyArgs>(args?: SelectSubset<T, MedicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medications
     * const medication = await prisma.medication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicationUpdateManyArgs>(args: SelectSubset<T, MedicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medications and returns the data updated in the database.
     * @param {MedicationUpdateManyAndReturnArgs} args - Arguments to update many Medications.
     * @example
     * // Update many Medications
     * const medication = await prisma.medication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Medications and only return the `id`
     * const medicationWithIdOnly = await prisma.medication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicationUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Medication.
     * @param {MedicationUpsertArgs} args - Arguments to update or create a Medication.
     * @example
     * // Update or create a Medication
     * const medication = await prisma.medication.upsert({
     *   create: {
     *     // ... data to create a Medication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medication we want to update
     *   }
     * })
     */
    upsert<T extends MedicationUpsertArgs>(args: SelectSubset<T, MedicationUpsertArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Medications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationCountArgs} args - Arguments to filter Medications to count.
     * @example
     * // Count the number of Medications
     * const count = await prisma.medication.count({
     *   where: {
     *     // ... the filter for the Medications we want to count
     *   }
     * })
    **/
    count<T extends MedicationCountArgs>(
      args?: Subset<T, MedicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicationAggregateArgs>(args: Subset<T, MedicationAggregateArgs>): Prisma.PrismaPromise<GetMedicationAggregateType<T>>

    /**
     * Group by Medication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicationGroupByArgs['orderBy'] }
        : { orderBy?: MedicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Medication model
   */
  readonly fields: MedicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Medication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pharmacyOrderItems<T extends Medication$pharmacyOrderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Medication$pharmacyOrderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PharmacyOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prescriptionItems<T extends Medication$prescriptionItemsArgs<ExtArgs> = {}>(args?: Subset<T, Medication$prescriptionItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Medication model
   */
  interface MedicationFieldRefs {
    readonly id: FieldRef<"Medication", 'String'>
    readonly name: FieldRef<"Medication", 'String'>
    readonly genericName: FieldRef<"Medication", 'String'>
    readonly description: FieldRef<"Medication", 'String'>
    readonly strength: FieldRef<"Medication", 'String'>
    readonly unit: FieldRef<"Medication", 'String'>
    readonly dosageForm: FieldRef<"Medication", 'String'>
    readonly route: FieldRef<"Medication", 'String'>
    readonly schedule: FieldRef<"Medication", 'Json'>
    readonly isActive: FieldRef<"Medication", 'Boolean'>
    readonly tenantId: FieldRef<"Medication", 'String'>
    readonly createdAt: FieldRef<"Medication", 'DateTime'>
    readonly updatedAt: FieldRef<"Medication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Medication findUnique
   */
  export type MedicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication findUniqueOrThrow
   */
  export type MedicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication findFirst
   */
  export type MedicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medications.
     */
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication findFirstOrThrow
   */
  export type MedicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medications.
     */
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication findMany
   */
  export type MedicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medications to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication create
   */
  export type MedicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Medication.
     */
    data: XOR<MedicationCreateInput, MedicationUncheckedCreateInput>
  }

  /**
   * Medication createMany
   */
  export type MedicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Medications.
     */
    data: MedicationCreateManyInput | MedicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Medication createManyAndReturn
   */
  export type MedicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * The data used to create many Medications.
     */
    data: MedicationCreateManyInput | MedicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Medication update
   */
  export type MedicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Medication.
     */
    data: XOR<MedicationUpdateInput, MedicationUncheckedUpdateInput>
    /**
     * Choose, which Medication to update.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication updateMany
   */
  export type MedicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Medications.
     */
    data: XOR<MedicationUpdateManyMutationInput, MedicationUncheckedUpdateManyInput>
    /**
     * Filter which Medications to update
     */
    where?: MedicationWhereInput
    /**
     * Limit how many Medications to update.
     */
    limit?: number
  }

  /**
   * Medication updateManyAndReturn
   */
  export type MedicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * The data used to update Medications.
     */
    data: XOR<MedicationUpdateManyMutationInput, MedicationUncheckedUpdateManyInput>
    /**
     * Filter which Medications to update
     */
    where?: MedicationWhereInput
    /**
     * Limit how many Medications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Medication upsert
   */
  export type MedicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Medication to update in case it exists.
     */
    where: MedicationWhereUniqueInput
    /**
     * In case the Medication found by the `where` argument doesn't exist, create a new Medication with this data.
     */
    create: XOR<MedicationCreateInput, MedicationUncheckedCreateInput>
    /**
     * In case the Medication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicationUpdateInput, MedicationUncheckedUpdateInput>
  }

  /**
   * Medication delete
   */
  export type MedicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter which Medication to delete.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication deleteMany
   */
  export type MedicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medications to delete
     */
    where?: MedicationWhereInput
    /**
     * Limit how many Medications to delete.
     */
    limit?: number
  }

  /**
   * Medication.pharmacyOrderItems
   */
  export type Medication$pharmacyOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrderItem
     */
    select?: PharmacyOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrderItem
     */
    omit?: PharmacyOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderItemInclude<ExtArgs> | null
    where?: PharmacyOrderItemWhereInput
    orderBy?: PharmacyOrderItemOrderByWithRelationInput | PharmacyOrderItemOrderByWithRelationInput[]
    cursor?: PharmacyOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PharmacyOrderItemScalarFieldEnum | PharmacyOrderItemScalarFieldEnum[]
  }

  /**
   * Medication.prescriptionItems
   */
  export type Medication$prescriptionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    where?: PrescriptionItemWhereInput
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    cursor?: PrescriptionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * Medication without action
   */
  export type MedicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
  }


  /**
   * Model PharmacyOrder
   */

  export type AggregatePharmacyOrder = {
    _count: PharmacyOrderCountAggregateOutputType | null
    _min: PharmacyOrderMinAggregateOutputType | null
    _max: PharmacyOrderMaxAggregateOutputType | null
  }

  export type PharmacyOrderMinAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    patientId: string | null
    doctorId: string | null
    status: $Enums.PharmacyOrderStatus | null
    orderDate: Date | null
    dispensedDate: Date | null
    notes: string | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    invoiceId: string | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type PharmacyOrderMaxAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    patientId: string | null
    doctorId: string | null
    status: $Enums.PharmacyOrderStatus | null
    orderDate: Date | null
    dispensedDate: Date | null
    notes: string | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    invoiceId: string | null
    createdBy: string | null
    updatedBy: string | null
  }

  export type PharmacyOrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    patientId: number
    doctorId: number
    status: number
    orderDate: number
    dispensedDate: number
    notes: number
    tenantId: number
    createdAt: number
    updatedAt: number
    invoiceId: number
    createdBy: number
    updatedBy: number
    _all: number
  }


  export type PharmacyOrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    patientId?: true
    doctorId?: true
    status?: true
    orderDate?: true
    dispensedDate?: true
    notes?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    invoiceId?: true
    createdBy?: true
    updatedBy?: true
  }

  export type PharmacyOrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    patientId?: true
    doctorId?: true
    status?: true
    orderDate?: true
    dispensedDate?: true
    notes?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    invoiceId?: true
    createdBy?: true
    updatedBy?: true
  }

  export type PharmacyOrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    patientId?: true
    doctorId?: true
    status?: true
    orderDate?: true
    dispensedDate?: true
    notes?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    invoiceId?: true
    createdBy?: true
    updatedBy?: true
    _all?: true
  }

  export type PharmacyOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PharmacyOrder to aggregate.
     */
    where?: PharmacyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PharmacyOrders to fetch.
     */
    orderBy?: PharmacyOrderOrderByWithRelationInput | PharmacyOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PharmacyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PharmacyOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PharmacyOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PharmacyOrders
    **/
    _count?: true | PharmacyOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PharmacyOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PharmacyOrderMaxAggregateInputType
  }

  export type GetPharmacyOrderAggregateType<T extends PharmacyOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePharmacyOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePharmacyOrder[P]>
      : GetScalarType<T[P], AggregatePharmacyOrder[P]>
  }




  export type PharmacyOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PharmacyOrderWhereInput
    orderBy?: PharmacyOrderOrderByWithAggregationInput | PharmacyOrderOrderByWithAggregationInput[]
    by: PharmacyOrderScalarFieldEnum[] | PharmacyOrderScalarFieldEnum
    having?: PharmacyOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PharmacyOrderCountAggregateInputType | true
    _min?: PharmacyOrderMinAggregateInputType
    _max?: PharmacyOrderMaxAggregateInputType
  }

  export type PharmacyOrderGroupByOutputType = {
    id: string
    orderNumber: string
    patientId: string
    doctorId: string | null
    status: $Enums.PharmacyOrderStatus
    orderDate: Date
    dispensedDate: Date | null
    notes: string | null
    tenantId: string
    createdAt: Date
    updatedAt: Date
    invoiceId: string | null
    createdBy: string | null
    updatedBy: string | null
    _count: PharmacyOrderCountAggregateOutputType | null
    _min: PharmacyOrderMinAggregateOutputType | null
    _max: PharmacyOrderMaxAggregateOutputType | null
  }

  type GetPharmacyOrderGroupByPayload<T extends PharmacyOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PharmacyOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PharmacyOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PharmacyOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PharmacyOrderGroupByOutputType[P]>
        }
      >
    >


  export type PharmacyOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    patientId?: boolean
    doctorId?: boolean
    status?: boolean
    orderDate?: boolean
    dispensedDate?: boolean
    notes?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoiceId?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    doctor?: boolean | PharmacyOrder$doctorArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    invoice?: boolean | PharmacyOrder$invoiceArgs<ExtArgs>
    items?: boolean | PharmacyOrder$itemsArgs<ExtArgs>
    _count?: boolean | PharmacyOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pharmacyOrder"]>

  export type PharmacyOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    patientId?: boolean
    doctorId?: boolean
    status?: boolean
    orderDate?: boolean
    dispensedDate?: boolean
    notes?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoiceId?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    doctor?: boolean | PharmacyOrder$doctorArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    invoice?: boolean | PharmacyOrder$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["pharmacyOrder"]>

  export type PharmacyOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    patientId?: boolean
    doctorId?: boolean
    status?: boolean
    orderDate?: boolean
    dispensedDate?: boolean
    notes?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoiceId?: boolean
    createdBy?: boolean
    updatedBy?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    doctor?: boolean | PharmacyOrder$doctorArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    invoice?: boolean | PharmacyOrder$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["pharmacyOrder"]>

  export type PharmacyOrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    patientId?: boolean
    doctorId?: boolean
    status?: boolean
    orderDate?: boolean
    dispensedDate?: boolean
    notes?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoiceId?: boolean
    createdBy?: boolean
    updatedBy?: boolean
  }

  export type PharmacyOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNumber" | "patientId" | "doctorId" | "status" | "orderDate" | "dispensedDate" | "notes" | "tenantId" | "createdAt" | "updatedAt" | "invoiceId" | "createdBy" | "updatedBy", ExtArgs["result"]["pharmacyOrder"]>
  export type PharmacyOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    doctor?: boolean | PharmacyOrder$doctorArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    invoice?: boolean | PharmacyOrder$invoiceArgs<ExtArgs>
    items?: boolean | PharmacyOrder$itemsArgs<ExtArgs>
    _count?: boolean | PharmacyOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PharmacyOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    doctor?: boolean | PharmacyOrder$doctorArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    invoice?: boolean | PharmacyOrder$invoiceArgs<ExtArgs>
  }
  export type PharmacyOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    doctor?: boolean | PharmacyOrder$doctorArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    invoice?: boolean | PharmacyOrder$invoiceArgs<ExtArgs>
  }

  export type $PharmacyOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PharmacyOrder"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      doctor: Prisma.$UserPayload<ExtArgs> | null
      patient: Prisma.$PatientPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      items: Prisma.$PharmacyOrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNumber: string
      patientId: string
      doctorId: string | null
      status: $Enums.PharmacyOrderStatus
      orderDate: Date
      dispensedDate: Date | null
      notes: string | null
      tenantId: string
      createdAt: Date
      updatedAt: Date
      invoiceId: string | null
      createdBy: string | null
      updatedBy: string | null
    }, ExtArgs["result"]["pharmacyOrder"]>
    composites: {}
  }

  type PharmacyOrderGetPayload<S extends boolean | null | undefined | PharmacyOrderDefaultArgs> = $Result.GetResult<Prisma.$PharmacyOrderPayload, S>

  type PharmacyOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PharmacyOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PharmacyOrderCountAggregateInputType | true
    }

  export interface PharmacyOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PharmacyOrder'], meta: { name: 'PharmacyOrder' } }
    /**
     * Find zero or one PharmacyOrder that matches the filter.
     * @param {PharmacyOrderFindUniqueArgs} args - Arguments to find a PharmacyOrder
     * @example
     * // Get one PharmacyOrder
     * const pharmacyOrder = await prisma.pharmacyOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PharmacyOrderFindUniqueArgs>(args: SelectSubset<T, PharmacyOrderFindUniqueArgs<ExtArgs>>): Prisma__PharmacyOrderClient<$Result.GetResult<Prisma.$PharmacyOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PharmacyOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PharmacyOrderFindUniqueOrThrowArgs} args - Arguments to find a PharmacyOrder
     * @example
     * // Get one PharmacyOrder
     * const pharmacyOrder = await prisma.pharmacyOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PharmacyOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PharmacyOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PharmacyOrderClient<$Result.GetResult<Prisma.$PharmacyOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PharmacyOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacyOrderFindFirstArgs} args - Arguments to find a PharmacyOrder
     * @example
     * // Get one PharmacyOrder
     * const pharmacyOrder = await prisma.pharmacyOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PharmacyOrderFindFirstArgs>(args?: SelectSubset<T, PharmacyOrderFindFirstArgs<ExtArgs>>): Prisma__PharmacyOrderClient<$Result.GetResult<Prisma.$PharmacyOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PharmacyOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacyOrderFindFirstOrThrowArgs} args - Arguments to find a PharmacyOrder
     * @example
     * // Get one PharmacyOrder
     * const pharmacyOrder = await prisma.pharmacyOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PharmacyOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PharmacyOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PharmacyOrderClient<$Result.GetResult<Prisma.$PharmacyOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PharmacyOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacyOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PharmacyOrders
     * const pharmacyOrders = await prisma.pharmacyOrder.findMany()
     * 
     * // Get first 10 PharmacyOrders
     * const pharmacyOrders = await prisma.pharmacyOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pharmacyOrderWithIdOnly = await prisma.pharmacyOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PharmacyOrderFindManyArgs>(args?: SelectSubset<T, PharmacyOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PharmacyOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PharmacyOrder.
     * @param {PharmacyOrderCreateArgs} args - Arguments to create a PharmacyOrder.
     * @example
     * // Create one PharmacyOrder
     * const PharmacyOrder = await prisma.pharmacyOrder.create({
     *   data: {
     *     // ... data to create a PharmacyOrder
     *   }
     * })
     * 
     */
    create<T extends PharmacyOrderCreateArgs>(args: SelectSubset<T, PharmacyOrderCreateArgs<ExtArgs>>): Prisma__PharmacyOrderClient<$Result.GetResult<Prisma.$PharmacyOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PharmacyOrders.
     * @param {PharmacyOrderCreateManyArgs} args - Arguments to create many PharmacyOrders.
     * @example
     * // Create many PharmacyOrders
     * const pharmacyOrder = await prisma.pharmacyOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PharmacyOrderCreateManyArgs>(args?: SelectSubset<T, PharmacyOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PharmacyOrders and returns the data saved in the database.
     * @param {PharmacyOrderCreateManyAndReturnArgs} args - Arguments to create many PharmacyOrders.
     * @example
     * // Create many PharmacyOrders
     * const pharmacyOrder = await prisma.pharmacyOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PharmacyOrders and only return the `id`
     * const pharmacyOrderWithIdOnly = await prisma.pharmacyOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PharmacyOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, PharmacyOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PharmacyOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PharmacyOrder.
     * @param {PharmacyOrderDeleteArgs} args - Arguments to delete one PharmacyOrder.
     * @example
     * // Delete one PharmacyOrder
     * const PharmacyOrder = await prisma.pharmacyOrder.delete({
     *   where: {
     *     // ... filter to delete one PharmacyOrder
     *   }
     * })
     * 
     */
    delete<T extends PharmacyOrderDeleteArgs>(args: SelectSubset<T, PharmacyOrderDeleteArgs<ExtArgs>>): Prisma__PharmacyOrderClient<$Result.GetResult<Prisma.$PharmacyOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PharmacyOrder.
     * @param {PharmacyOrderUpdateArgs} args - Arguments to update one PharmacyOrder.
     * @example
     * // Update one PharmacyOrder
     * const pharmacyOrder = await prisma.pharmacyOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PharmacyOrderUpdateArgs>(args: SelectSubset<T, PharmacyOrderUpdateArgs<ExtArgs>>): Prisma__PharmacyOrderClient<$Result.GetResult<Prisma.$PharmacyOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PharmacyOrders.
     * @param {PharmacyOrderDeleteManyArgs} args - Arguments to filter PharmacyOrders to delete.
     * @example
     * // Delete a few PharmacyOrders
     * const { count } = await prisma.pharmacyOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PharmacyOrderDeleteManyArgs>(args?: SelectSubset<T, PharmacyOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PharmacyOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacyOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PharmacyOrders
     * const pharmacyOrder = await prisma.pharmacyOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PharmacyOrderUpdateManyArgs>(args: SelectSubset<T, PharmacyOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PharmacyOrders and returns the data updated in the database.
     * @param {PharmacyOrderUpdateManyAndReturnArgs} args - Arguments to update many PharmacyOrders.
     * @example
     * // Update many PharmacyOrders
     * const pharmacyOrder = await prisma.pharmacyOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PharmacyOrders and only return the `id`
     * const pharmacyOrderWithIdOnly = await prisma.pharmacyOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PharmacyOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, PharmacyOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PharmacyOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PharmacyOrder.
     * @param {PharmacyOrderUpsertArgs} args - Arguments to update or create a PharmacyOrder.
     * @example
     * // Update or create a PharmacyOrder
     * const pharmacyOrder = await prisma.pharmacyOrder.upsert({
     *   create: {
     *     // ... data to create a PharmacyOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PharmacyOrder we want to update
     *   }
     * })
     */
    upsert<T extends PharmacyOrderUpsertArgs>(args: SelectSubset<T, PharmacyOrderUpsertArgs<ExtArgs>>): Prisma__PharmacyOrderClient<$Result.GetResult<Prisma.$PharmacyOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PharmacyOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacyOrderCountArgs} args - Arguments to filter PharmacyOrders to count.
     * @example
     * // Count the number of PharmacyOrders
     * const count = await prisma.pharmacyOrder.count({
     *   where: {
     *     // ... the filter for the PharmacyOrders we want to count
     *   }
     * })
    **/
    count<T extends PharmacyOrderCountArgs>(
      args?: Subset<T, PharmacyOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PharmacyOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PharmacyOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacyOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PharmacyOrderAggregateArgs>(args: Subset<T, PharmacyOrderAggregateArgs>): Prisma.PrismaPromise<GetPharmacyOrderAggregateType<T>>

    /**
     * Group by PharmacyOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacyOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PharmacyOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PharmacyOrderGroupByArgs['orderBy'] }
        : { orderBy?: PharmacyOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PharmacyOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPharmacyOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PharmacyOrder model
   */
  readonly fields: PharmacyOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PharmacyOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PharmacyOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends PharmacyOrder$doctorArgs<ExtArgs> = {}>(args?: Subset<T, PharmacyOrder$doctorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoice<T extends PharmacyOrder$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, PharmacyOrder$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends PharmacyOrder$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PharmacyOrder$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PharmacyOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PharmacyOrder model
   */
  interface PharmacyOrderFieldRefs {
    readonly id: FieldRef<"PharmacyOrder", 'String'>
    readonly orderNumber: FieldRef<"PharmacyOrder", 'String'>
    readonly patientId: FieldRef<"PharmacyOrder", 'String'>
    readonly doctorId: FieldRef<"PharmacyOrder", 'String'>
    readonly status: FieldRef<"PharmacyOrder", 'PharmacyOrderStatus'>
    readonly orderDate: FieldRef<"PharmacyOrder", 'DateTime'>
    readonly dispensedDate: FieldRef<"PharmacyOrder", 'DateTime'>
    readonly notes: FieldRef<"PharmacyOrder", 'String'>
    readonly tenantId: FieldRef<"PharmacyOrder", 'String'>
    readonly createdAt: FieldRef<"PharmacyOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"PharmacyOrder", 'DateTime'>
    readonly invoiceId: FieldRef<"PharmacyOrder", 'String'>
    readonly createdBy: FieldRef<"PharmacyOrder", 'String'>
    readonly updatedBy: FieldRef<"PharmacyOrder", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PharmacyOrder findUnique
   */
  export type PharmacyOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrder
     */
    select?: PharmacyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrder
     */
    omit?: PharmacyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderInclude<ExtArgs> | null
    /**
     * Filter, which PharmacyOrder to fetch.
     */
    where: PharmacyOrderWhereUniqueInput
  }

  /**
   * PharmacyOrder findUniqueOrThrow
   */
  export type PharmacyOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrder
     */
    select?: PharmacyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrder
     */
    omit?: PharmacyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderInclude<ExtArgs> | null
    /**
     * Filter, which PharmacyOrder to fetch.
     */
    where: PharmacyOrderWhereUniqueInput
  }

  /**
   * PharmacyOrder findFirst
   */
  export type PharmacyOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrder
     */
    select?: PharmacyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrder
     */
    omit?: PharmacyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderInclude<ExtArgs> | null
    /**
     * Filter, which PharmacyOrder to fetch.
     */
    where?: PharmacyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PharmacyOrders to fetch.
     */
    orderBy?: PharmacyOrderOrderByWithRelationInput | PharmacyOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PharmacyOrders.
     */
    cursor?: PharmacyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PharmacyOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PharmacyOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PharmacyOrders.
     */
    distinct?: PharmacyOrderScalarFieldEnum | PharmacyOrderScalarFieldEnum[]
  }

  /**
   * PharmacyOrder findFirstOrThrow
   */
  export type PharmacyOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrder
     */
    select?: PharmacyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrder
     */
    omit?: PharmacyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderInclude<ExtArgs> | null
    /**
     * Filter, which PharmacyOrder to fetch.
     */
    where?: PharmacyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PharmacyOrders to fetch.
     */
    orderBy?: PharmacyOrderOrderByWithRelationInput | PharmacyOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PharmacyOrders.
     */
    cursor?: PharmacyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PharmacyOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PharmacyOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PharmacyOrders.
     */
    distinct?: PharmacyOrderScalarFieldEnum | PharmacyOrderScalarFieldEnum[]
  }

  /**
   * PharmacyOrder findMany
   */
  export type PharmacyOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrder
     */
    select?: PharmacyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrder
     */
    omit?: PharmacyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderInclude<ExtArgs> | null
    /**
     * Filter, which PharmacyOrders to fetch.
     */
    where?: PharmacyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PharmacyOrders to fetch.
     */
    orderBy?: PharmacyOrderOrderByWithRelationInput | PharmacyOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PharmacyOrders.
     */
    cursor?: PharmacyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PharmacyOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PharmacyOrders.
     */
    skip?: number
    distinct?: PharmacyOrderScalarFieldEnum | PharmacyOrderScalarFieldEnum[]
  }

  /**
   * PharmacyOrder create
   */
  export type PharmacyOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrder
     */
    select?: PharmacyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrder
     */
    omit?: PharmacyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a PharmacyOrder.
     */
    data: XOR<PharmacyOrderCreateInput, PharmacyOrderUncheckedCreateInput>
  }

  /**
   * PharmacyOrder createMany
   */
  export type PharmacyOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PharmacyOrders.
     */
    data: PharmacyOrderCreateManyInput | PharmacyOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PharmacyOrder createManyAndReturn
   */
  export type PharmacyOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrder
     */
    select?: PharmacyOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrder
     */
    omit?: PharmacyOrderOmit<ExtArgs> | null
    /**
     * The data used to create many PharmacyOrders.
     */
    data: PharmacyOrderCreateManyInput | PharmacyOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PharmacyOrder update
   */
  export type PharmacyOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrder
     */
    select?: PharmacyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrder
     */
    omit?: PharmacyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a PharmacyOrder.
     */
    data: XOR<PharmacyOrderUpdateInput, PharmacyOrderUncheckedUpdateInput>
    /**
     * Choose, which PharmacyOrder to update.
     */
    where: PharmacyOrderWhereUniqueInput
  }

  /**
   * PharmacyOrder updateMany
   */
  export type PharmacyOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PharmacyOrders.
     */
    data: XOR<PharmacyOrderUpdateManyMutationInput, PharmacyOrderUncheckedUpdateManyInput>
    /**
     * Filter which PharmacyOrders to update
     */
    where?: PharmacyOrderWhereInput
    /**
     * Limit how many PharmacyOrders to update.
     */
    limit?: number
  }

  /**
   * PharmacyOrder updateManyAndReturn
   */
  export type PharmacyOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrder
     */
    select?: PharmacyOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrder
     */
    omit?: PharmacyOrderOmit<ExtArgs> | null
    /**
     * The data used to update PharmacyOrders.
     */
    data: XOR<PharmacyOrderUpdateManyMutationInput, PharmacyOrderUncheckedUpdateManyInput>
    /**
     * Filter which PharmacyOrders to update
     */
    where?: PharmacyOrderWhereInput
    /**
     * Limit how many PharmacyOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PharmacyOrder upsert
   */
  export type PharmacyOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrder
     */
    select?: PharmacyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrder
     */
    omit?: PharmacyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the PharmacyOrder to update in case it exists.
     */
    where: PharmacyOrderWhereUniqueInput
    /**
     * In case the PharmacyOrder found by the `where` argument doesn't exist, create a new PharmacyOrder with this data.
     */
    create: XOR<PharmacyOrderCreateInput, PharmacyOrderUncheckedCreateInput>
    /**
     * In case the PharmacyOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PharmacyOrderUpdateInput, PharmacyOrderUncheckedUpdateInput>
  }

  /**
   * PharmacyOrder delete
   */
  export type PharmacyOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrder
     */
    select?: PharmacyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrder
     */
    omit?: PharmacyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderInclude<ExtArgs> | null
    /**
     * Filter which PharmacyOrder to delete.
     */
    where: PharmacyOrderWhereUniqueInput
  }

  /**
   * PharmacyOrder deleteMany
   */
  export type PharmacyOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PharmacyOrders to delete
     */
    where?: PharmacyOrderWhereInput
    /**
     * Limit how many PharmacyOrders to delete.
     */
    limit?: number
  }

  /**
   * PharmacyOrder.doctor
   */
  export type PharmacyOrder$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PharmacyOrder.invoice
   */
  export type PharmacyOrder$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * PharmacyOrder.items
   */
  export type PharmacyOrder$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrderItem
     */
    select?: PharmacyOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrderItem
     */
    omit?: PharmacyOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderItemInclude<ExtArgs> | null
    where?: PharmacyOrderItemWhereInput
    orderBy?: PharmacyOrderItemOrderByWithRelationInput | PharmacyOrderItemOrderByWithRelationInput[]
    cursor?: PharmacyOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PharmacyOrderItemScalarFieldEnum | PharmacyOrderItemScalarFieldEnum[]
  }

  /**
   * PharmacyOrder without action
   */
  export type PharmacyOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrder
     */
    select?: PharmacyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrder
     */
    omit?: PharmacyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderInclude<ExtArgs> | null
  }


  /**
   * Model PharmacyOrderItem
   */

  export type AggregatePharmacyOrderItem = {
    _count: PharmacyOrderItemCountAggregateOutputType | null
    _avg: PharmacyOrderItemAvgAggregateOutputType | null
    _sum: PharmacyOrderItemSumAggregateOutputType | null
    _min: PharmacyOrderItemMinAggregateOutputType | null
    _max: PharmacyOrderItemMaxAggregateOutputType | null
  }

  export type PharmacyOrderItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type PharmacyOrderItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type PharmacyOrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    medicationId: string | null
    quantity: number | null
    dosage: string | null
    frequency: string | null
    duration: string | null
    instructions: string | null
    status: $Enums.PharmacyItemStatus | null
    tenantId: string | null
  }

  export type PharmacyOrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    medicationId: string | null
    quantity: number | null
    dosage: string | null
    frequency: string | null
    duration: string | null
    instructions: string | null
    status: $Enums.PharmacyItemStatus | null
    tenantId: string | null
  }

  export type PharmacyOrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    medicationId: number
    quantity: number
    dosage: number
    frequency: number
    duration: number
    instructions: number
    status: number
    tenantId: number
    _all: number
  }


  export type PharmacyOrderItemAvgAggregateInputType = {
    quantity?: true
  }

  export type PharmacyOrderItemSumAggregateInputType = {
    quantity?: true
  }

  export type PharmacyOrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    medicationId?: true
    quantity?: true
    dosage?: true
    frequency?: true
    duration?: true
    instructions?: true
    status?: true
    tenantId?: true
  }

  export type PharmacyOrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    medicationId?: true
    quantity?: true
    dosage?: true
    frequency?: true
    duration?: true
    instructions?: true
    status?: true
    tenantId?: true
  }

  export type PharmacyOrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    medicationId?: true
    quantity?: true
    dosage?: true
    frequency?: true
    duration?: true
    instructions?: true
    status?: true
    tenantId?: true
    _all?: true
  }

  export type PharmacyOrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PharmacyOrderItem to aggregate.
     */
    where?: PharmacyOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PharmacyOrderItems to fetch.
     */
    orderBy?: PharmacyOrderItemOrderByWithRelationInput | PharmacyOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PharmacyOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PharmacyOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PharmacyOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PharmacyOrderItems
    **/
    _count?: true | PharmacyOrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PharmacyOrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PharmacyOrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PharmacyOrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PharmacyOrderItemMaxAggregateInputType
  }

  export type GetPharmacyOrderItemAggregateType<T extends PharmacyOrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePharmacyOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePharmacyOrderItem[P]>
      : GetScalarType<T[P], AggregatePharmacyOrderItem[P]>
  }




  export type PharmacyOrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PharmacyOrderItemWhereInput
    orderBy?: PharmacyOrderItemOrderByWithAggregationInput | PharmacyOrderItemOrderByWithAggregationInput[]
    by: PharmacyOrderItemScalarFieldEnum[] | PharmacyOrderItemScalarFieldEnum
    having?: PharmacyOrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PharmacyOrderItemCountAggregateInputType | true
    _avg?: PharmacyOrderItemAvgAggregateInputType
    _sum?: PharmacyOrderItemSumAggregateInputType
    _min?: PharmacyOrderItemMinAggregateInputType
    _max?: PharmacyOrderItemMaxAggregateInputType
  }

  export type PharmacyOrderItemGroupByOutputType = {
    id: string
    orderId: string
    medicationId: string
    quantity: number
    dosage: string | null
    frequency: string | null
    duration: string | null
    instructions: string | null
    status: $Enums.PharmacyItemStatus
    tenantId: string
    _count: PharmacyOrderItemCountAggregateOutputType | null
    _avg: PharmacyOrderItemAvgAggregateOutputType | null
    _sum: PharmacyOrderItemSumAggregateOutputType | null
    _min: PharmacyOrderItemMinAggregateOutputType | null
    _max: PharmacyOrderItemMaxAggregateOutputType | null
  }

  type GetPharmacyOrderItemGroupByPayload<T extends PharmacyOrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PharmacyOrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PharmacyOrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PharmacyOrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], PharmacyOrderItemGroupByOutputType[P]>
        }
      >
    >


  export type PharmacyOrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    medicationId?: boolean
    quantity?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    instructions?: boolean
    status?: boolean
    tenantId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
    order?: boolean | PharmacyOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pharmacyOrderItem"]>

  export type PharmacyOrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    medicationId?: boolean
    quantity?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    instructions?: boolean
    status?: boolean
    tenantId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
    order?: boolean | PharmacyOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pharmacyOrderItem"]>

  export type PharmacyOrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    medicationId?: boolean
    quantity?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    instructions?: boolean
    status?: boolean
    tenantId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
    order?: boolean | PharmacyOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pharmacyOrderItem"]>

  export type PharmacyOrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    medicationId?: boolean
    quantity?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    instructions?: boolean
    status?: boolean
    tenantId?: boolean
  }

  export type PharmacyOrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "medicationId" | "quantity" | "dosage" | "frequency" | "duration" | "instructions" | "status" | "tenantId", ExtArgs["result"]["pharmacyOrderItem"]>
  export type PharmacyOrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
    order?: boolean | PharmacyOrderDefaultArgs<ExtArgs>
  }
  export type PharmacyOrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
    order?: boolean | PharmacyOrderDefaultArgs<ExtArgs>
  }
  export type PharmacyOrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
    order?: boolean | PharmacyOrderDefaultArgs<ExtArgs>
  }

  export type $PharmacyOrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PharmacyOrderItem"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      medication: Prisma.$MedicationPayload<ExtArgs>
      order: Prisma.$PharmacyOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      medicationId: string
      quantity: number
      dosage: string | null
      frequency: string | null
      duration: string | null
      instructions: string | null
      status: $Enums.PharmacyItemStatus
      tenantId: string
    }, ExtArgs["result"]["pharmacyOrderItem"]>
    composites: {}
  }

  type PharmacyOrderItemGetPayload<S extends boolean | null | undefined | PharmacyOrderItemDefaultArgs> = $Result.GetResult<Prisma.$PharmacyOrderItemPayload, S>

  type PharmacyOrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PharmacyOrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PharmacyOrderItemCountAggregateInputType | true
    }

  export interface PharmacyOrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PharmacyOrderItem'], meta: { name: 'PharmacyOrderItem' } }
    /**
     * Find zero or one PharmacyOrderItem that matches the filter.
     * @param {PharmacyOrderItemFindUniqueArgs} args - Arguments to find a PharmacyOrderItem
     * @example
     * // Get one PharmacyOrderItem
     * const pharmacyOrderItem = await prisma.pharmacyOrderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PharmacyOrderItemFindUniqueArgs>(args: SelectSubset<T, PharmacyOrderItemFindUniqueArgs<ExtArgs>>): Prisma__PharmacyOrderItemClient<$Result.GetResult<Prisma.$PharmacyOrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PharmacyOrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PharmacyOrderItemFindUniqueOrThrowArgs} args - Arguments to find a PharmacyOrderItem
     * @example
     * // Get one PharmacyOrderItem
     * const pharmacyOrderItem = await prisma.pharmacyOrderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PharmacyOrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PharmacyOrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PharmacyOrderItemClient<$Result.GetResult<Prisma.$PharmacyOrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PharmacyOrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacyOrderItemFindFirstArgs} args - Arguments to find a PharmacyOrderItem
     * @example
     * // Get one PharmacyOrderItem
     * const pharmacyOrderItem = await prisma.pharmacyOrderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PharmacyOrderItemFindFirstArgs>(args?: SelectSubset<T, PharmacyOrderItemFindFirstArgs<ExtArgs>>): Prisma__PharmacyOrderItemClient<$Result.GetResult<Prisma.$PharmacyOrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PharmacyOrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacyOrderItemFindFirstOrThrowArgs} args - Arguments to find a PharmacyOrderItem
     * @example
     * // Get one PharmacyOrderItem
     * const pharmacyOrderItem = await prisma.pharmacyOrderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PharmacyOrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PharmacyOrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PharmacyOrderItemClient<$Result.GetResult<Prisma.$PharmacyOrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PharmacyOrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacyOrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PharmacyOrderItems
     * const pharmacyOrderItems = await prisma.pharmacyOrderItem.findMany()
     * 
     * // Get first 10 PharmacyOrderItems
     * const pharmacyOrderItems = await prisma.pharmacyOrderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pharmacyOrderItemWithIdOnly = await prisma.pharmacyOrderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PharmacyOrderItemFindManyArgs>(args?: SelectSubset<T, PharmacyOrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PharmacyOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PharmacyOrderItem.
     * @param {PharmacyOrderItemCreateArgs} args - Arguments to create a PharmacyOrderItem.
     * @example
     * // Create one PharmacyOrderItem
     * const PharmacyOrderItem = await prisma.pharmacyOrderItem.create({
     *   data: {
     *     // ... data to create a PharmacyOrderItem
     *   }
     * })
     * 
     */
    create<T extends PharmacyOrderItemCreateArgs>(args: SelectSubset<T, PharmacyOrderItemCreateArgs<ExtArgs>>): Prisma__PharmacyOrderItemClient<$Result.GetResult<Prisma.$PharmacyOrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PharmacyOrderItems.
     * @param {PharmacyOrderItemCreateManyArgs} args - Arguments to create many PharmacyOrderItems.
     * @example
     * // Create many PharmacyOrderItems
     * const pharmacyOrderItem = await prisma.pharmacyOrderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PharmacyOrderItemCreateManyArgs>(args?: SelectSubset<T, PharmacyOrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PharmacyOrderItems and returns the data saved in the database.
     * @param {PharmacyOrderItemCreateManyAndReturnArgs} args - Arguments to create many PharmacyOrderItems.
     * @example
     * // Create many PharmacyOrderItems
     * const pharmacyOrderItem = await prisma.pharmacyOrderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PharmacyOrderItems and only return the `id`
     * const pharmacyOrderItemWithIdOnly = await prisma.pharmacyOrderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PharmacyOrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PharmacyOrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PharmacyOrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PharmacyOrderItem.
     * @param {PharmacyOrderItemDeleteArgs} args - Arguments to delete one PharmacyOrderItem.
     * @example
     * // Delete one PharmacyOrderItem
     * const PharmacyOrderItem = await prisma.pharmacyOrderItem.delete({
     *   where: {
     *     // ... filter to delete one PharmacyOrderItem
     *   }
     * })
     * 
     */
    delete<T extends PharmacyOrderItemDeleteArgs>(args: SelectSubset<T, PharmacyOrderItemDeleteArgs<ExtArgs>>): Prisma__PharmacyOrderItemClient<$Result.GetResult<Prisma.$PharmacyOrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PharmacyOrderItem.
     * @param {PharmacyOrderItemUpdateArgs} args - Arguments to update one PharmacyOrderItem.
     * @example
     * // Update one PharmacyOrderItem
     * const pharmacyOrderItem = await prisma.pharmacyOrderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PharmacyOrderItemUpdateArgs>(args: SelectSubset<T, PharmacyOrderItemUpdateArgs<ExtArgs>>): Prisma__PharmacyOrderItemClient<$Result.GetResult<Prisma.$PharmacyOrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PharmacyOrderItems.
     * @param {PharmacyOrderItemDeleteManyArgs} args - Arguments to filter PharmacyOrderItems to delete.
     * @example
     * // Delete a few PharmacyOrderItems
     * const { count } = await prisma.pharmacyOrderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PharmacyOrderItemDeleteManyArgs>(args?: SelectSubset<T, PharmacyOrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PharmacyOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacyOrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PharmacyOrderItems
     * const pharmacyOrderItem = await prisma.pharmacyOrderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PharmacyOrderItemUpdateManyArgs>(args: SelectSubset<T, PharmacyOrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PharmacyOrderItems and returns the data updated in the database.
     * @param {PharmacyOrderItemUpdateManyAndReturnArgs} args - Arguments to update many PharmacyOrderItems.
     * @example
     * // Update many PharmacyOrderItems
     * const pharmacyOrderItem = await prisma.pharmacyOrderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PharmacyOrderItems and only return the `id`
     * const pharmacyOrderItemWithIdOnly = await prisma.pharmacyOrderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PharmacyOrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PharmacyOrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PharmacyOrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PharmacyOrderItem.
     * @param {PharmacyOrderItemUpsertArgs} args - Arguments to update or create a PharmacyOrderItem.
     * @example
     * // Update or create a PharmacyOrderItem
     * const pharmacyOrderItem = await prisma.pharmacyOrderItem.upsert({
     *   create: {
     *     // ... data to create a PharmacyOrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PharmacyOrderItem we want to update
     *   }
     * })
     */
    upsert<T extends PharmacyOrderItemUpsertArgs>(args: SelectSubset<T, PharmacyOrderItemUpsertArgs<ExtArgs>>): Prisma__PharmacyOrderItemClient<$Result.GetResult<Prisma.$PharmacyOrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PharmacyOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacyOrderItemCountArgs} args - Arguments to filter PharmacyOrderItems to count.
     * @example
     * // Count the number of PharmacyOrderItems
     * const count = await prisma.pharmacyOrderItem.count({
     *   where: {
     *     // ... the filter for the PharmacyOrderItems we want to count
     *   }
     * })
    **/
    count<T extends PharmacyOrderItemCountArgs>(
      args?: Subset<T, PharmacyOrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PharmacyOrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PharmacyOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacyOrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PharmacyOrderItemAggregateArgs>(args: Subset<T, PharmacyOrderItemAggregateArgs>): Prisma.PrismaPromise<GetPharmacyOrderItemAggregateType<T>>

    /**
     * Group by PharmacyOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacyOrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PharmacyOrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PharmacyOrderItemGroupByArgs['orderBy'] }
        : { orderBy?: PharmacyOrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PharmacyOrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPharmacyOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PharmacyOrderItem model
   */
  readonly fields: PharmacyOrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PharmacyOrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PharmacyOrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medication<T extends MedicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicationDefaultArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends PharmacyOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PharmacyOrderDefaultArgs<ExtArgs>>): Prisma__PharmacyOrderClient<$Result.GetResult<Prisma.$PharmacyOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PharmacyOrderItem model
   */
  interface PharmacyOrderItemFieldRefs {
    readonly id: FieldRef<"PharmacyOrderItem", 'String'>
    readonly orderId: FieldRef<"PharmacyOrderItem", 'String'>
    readonly medicationId: FieldRef<"PharmacyOrderItem", 'String'>
    readonly quantity: FieldRef<"PharmacyOrderItem", 'Int'>
    readonly dosage: FieldRef<"PharmacyOrderItem", 'String'>
    readonly frequency: FieldRef<"PharmacyOrderItem", 'String'>
    readonly duration: FieldRef<"PharmacyOrderItem", 'String'>
    readonly instructions: FieldRef<"PharmacyOrderItem", 'String'>
    readonly status: FieldRef<"PharmacyOrderItem", 'PharmacyItemStatus'>
    readonly tenantId: FieldRef<"PharmacyOrderItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PharmacyOrderItem findUnique
   */
  export type PharmacyOrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrderItem
     */
    select?: PharmacyOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrderItem
     */
    omit?: PharmacyOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PharmacyOrderItem to fetch.
     */
    where: PharmacyOrderItemWhereUniqueInput
  }

  /**
   * PharmacyOrderItem findUniqueOrThrow
   */
  export type PharmacyOrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrderItem
     */
    select?: PharmacyOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrderItem
     */
    omit?: PharmacyOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PharmacyOrderItem to fetch.
     */
    where: PharmacyOrderItemWhereUniqueInput
  }

  /**
   * PharmacyOrderItem findFirst
   */
  export type PharmacyOrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrderItem
     */
    select?: PharmacyOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrderItem
     */
    omit?: PharmacyOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PharmacyOrderItem to fetch.
     */
    where?: PharmacyOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PharmacyOrderItems to fetch.
     */
    orderBy?: PharmacyOrderItemOrderByWithRelationInput | PharmacyOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PharmacyOrderItems.
     */
    cursor?: PharmacyOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PharmacyOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PharmacyOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PharmacyOrderItems.
     */
    distinct?: PharmacyOrderItemScalarFieldEnum | PharmacyOrderItemScalarFieldEnum[]
  }

  /**
   * PharmacyOrderItem findFirstOrThrow
   */
  export type PharmacyOrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrderItem
     */
    select?: PharmacyOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrderItem
     */
    omit?: PharmacyOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PharmacyOrderItem to fetch.
     */
    where?: PharmacyOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PharmacyOrderItems to fetch.
     */
    orderBy?: PharmacyOrderItemOrderByWithRelationInput | PharmacyOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PharmacyOrderItems.
     */
    cursor?: PharmacyOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PharmacyOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PharmacyOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PharmacyOrderItems.
     */
    distinct?: PharmacyOrderItemScalarFieldEnum | PharmacyOrderItemScalarFieldEnum[]
  }

  /**
   * PharmacyOrderItem findMany
   */
  export type PharmacyOrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrderItem
     */
    select?: PharmacyOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrderItem
     */
    omit?: PharmacyOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PharmacyOrderItems to fetch.
     */
    where?: PharmacyOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PharmacyOrderItems to fetch.
     */
    orderBy?: PharmacyOrderItemOrderByWithRelationInput | PharmacyOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PharmacyOrderItems.
     */
    cursor?: PharmacyOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PharmacyOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PharmacyOrderItems.
     */
    skip?: number
    distinct?: PharmacyOrderItemScalarFieldEnum | PharmacyOrderItemScalarFieldEnum[]
  }

  /**
   * PharmacyOrderItem create
   */
  export type PharmacyOrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrderItem
     */
    select?: PharmacyOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrderItem
     */
    omit?: PharmacyOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PharmacyOrderItem.
     */
    data: XOR<PharmacyOrderItemCreateInput, PharmacyOrderItemUncheckedCreateInput>
  }

  /**
   * PharmacyOrderItem createMany
   */
  export type PharmacyOrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PharmacyOrderItems.
     */
    data: PharmacyOrderItemCreateManyInput | PharmacyOrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PharmacyOrderItem createManyAndReturn
   */
  export type PharmacyOrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrderItem
     */
    select?: PharmacyOrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrderItem
     */
    omit?: PharmacyOrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many PharmacyOrderItems.
     */
    data: PharmacyOrderItemCreateManyInput | PharmacyOrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PharmacyOrderItem update
   */
  export type PharmacyOrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrderItem
     */
    select?: PharmacyOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrderItem
     */
    omit?: PharmacyOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PharmacyOrderItem.
     */
    data: XOR<PharmacyOrderItemUpdateInput, PharmacyOrderItemUncheckedUpdateInput>
    /**
     * Choose, which PharmacyOrderItem to update.
     */
    where: PharmacyOrderItemWhereUniqueInput
  }

  /**
   * PharmacyOrderItem updateMany
   */
  export type PharmacyOrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PharmacyOrderItems.
     */
    data: XOR<PharmacyOrderItemUpdateManyMutationInput, PharmacyOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which PharmacyOrderItems to update
     */
    where?: PharmacyOrderItemWhereInput
    /**
     * Limit how many PharmacyOrderItems to update.
     */
    limit?: number
  }

  /**
   * PharmacyOrderItem updateManyAndReturn
   */
  export type PharmacyOrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrderItem
     */
    select?: PharmacyOrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrderItem
     */
    omit?: PharmacyOrderItemOmit<ExtArgs> | null
    /**
     * The data used to update PharmacyOrderItems.
     */
    data: XOR<PharmacyOrderItemUpdateManyMutationInput, PharmacyOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which PharmacyOrderItems to update
     */
    where?: PharmacyOrderItemWhereInput
    /**
     * Limit how many PharmacyOrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PharmacyOrderItem upsert
   */
  export type PharmacyOrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrderItem
     */
    select?: PharmacyOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrderItem
     */
    omit?: PharmacyOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PharmacyOrderItem to update in case it exists.
     */
    where: PharmacyOrderItemWhereUniqueInput
    /**
     * In case the PharmacyOrderItem found by the `where` argument doesn't exist, create a new PharmacyOrderItem with this data.
     */
    create: XOR<PharmacyOrderItemCreateInput, PharmacyOrderItemUncheckedCreateInput>
    /**
     * In case the PharmacyOrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PharmacyOrderItemUpdateInput, PharmacyOrderItemUncheckedUpdateInput>
  }

  /**
   * PharmacyOrderItem delete
   */
  export type PharmacyOrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrderItem
     */
    select?: PharmacyOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrderItem
     */
    omit?: PharmacyOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderItemInclude<ExtArgs> | null
    /**
     * Filter which PharmacyOrderItem to delete.
     */
    where: PharmacyOrderItemWhereUniqueInput
  }

  /**
   * PharmacyOrderItem deleteMany
   */
  export type PharmacyOrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PharmacyOrderItems to delete
     */
    where?: PharmacyOrderItemWhereInput
    /**
     * Limit how many PharmacyOrderItems to delete.
     */
    limit?: number
  }

  /**
   * PharmacyOrderItem without action
   */
  export type PharmacyOrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacyOrderItem
     */
    select?: PharmacyOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacyOrderItem
     */
    omit?: PharmacyOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacyOrderItemInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    tenantId: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    tenantId: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entityType: number
    entityId: number
    oldValues: number
    newValues: number
    ipAddress: number
    userAgent: number
    tenantId: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    tenantId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    tenantId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    oldValues?: true
    newValues?: true
    ipAddress?: true
    userAgent?: true
    tenantId?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    entityType: string | null
    entityId: string | null
    oldValues: JsonValue | null
    newValues: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    tenantId: string
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    tenantId?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    tenantId?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    tenantId?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    tenantId?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entityType" | "entityId" | "oldValues" | "newValues" | "ipAddress" | "userAgent" | "tenantId" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      entityType: string | null
      entityId: string | null
      oldValues: Prisma.JsonValue | null
      newValues: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      tenantId: string
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly oldValues: FieldRef<"AuditLog", 'Json'>
    readonly newValues: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly tenantId: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Modality
   */

  export type AggregateModality = {
    _count: ModalityCountAggregateOutputType | null
    _min: ModalityMinAggregateOutputType | null
    _max: ModalityMaxAggregateOutputType | null
  }

  export type ModalityMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModalityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModalityCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModalityMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModalityMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModalityCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModalityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modality to aggregate.
     */
    where?: ModalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modalities to fetch.
     */
    orderBy?: ModalityOrderByWithRelationInput | ModalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modalities
    **/
    _count?: true | ModalityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModalityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModalityMaxAggregateInputType
  }

  export type GetModalityAggregateType<T extends ModalityAggregateArgs> = {
        [P in keyof T & keyof AggregateModality]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModality[P]>
      : GetScalarType<T[P], AggregateModality[P]>
  }




  export type ModalityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModalityWhereInput
    orderBy?: ModalityOrderByWithAggregationInput | ModalityOrderByWithAggregationInput[]
    by: ModalityScalarFieldEnum[] | ModalityScalarFieldEnum
    having?: ModalityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModalityCountAggregateInputType | true
    _min?: ModalityMinAggregateInputType
    _max?: ModalityMaxAggregateInputType
  }

  export type ModalityGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ModalityCountAggregateOutputType | null
    _min: ModalityMinAggregateOutputType | null
    _max: ModalityMaxAggregateOutputType | null
  }

  type GetModalityGroupByPayload<T extends ModalityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModalityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModalityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModalityGroupByOutputType[P]>
            : GetScalarType<T[P], ModalityGroupByOutputType[P]>
        }
      >
    >


  export type ModalitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studies?: boolean | Modality$studiesArgs<ExtArgs>
    radiologyOrders?: boolean | Modality$radiologyOrdersArgs<ExtArgs>
    _count?: boolean | ModalityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modality"]>

  export type ModalitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["modality"]>

  export type ModalitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["modality"]>

  export type ModalitySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModalityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["modality"]>
  export type ModalityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studies?: boolean | Modality$studiesArgs<ExtArgs>
    radiologyOrders?: boolean | Modality$radiologyOrdersArgs<ExtArgs>
    _count?: boolean | ModalityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModalityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ModalityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ModalityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Modality"
    objects: {
      studies: Prisma.$StudyPayload<ExtArgs>[]
      radiologyOrders: Prisma.$RadiologyOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["modality"]>
    composites: {}
  }

  type ModalityGetPayload<S extends boolean | null | undefined | ModalityDefaultArgs> = $Result.GetResult<Prisma.$ModalityPayload, S>

  type ModalityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModalityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModalityCountAggregateInputType | true
    }

  export interface ModalityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Modality'], meta: { name: 'Modality' } }
    /**
     * Find zero or one Modality that matches the filter.
     * @param {ModalityFindUniqueArgs} args - Arguments to find a Modality
     * @example
     * // Get one Modality
     * const modality = await prisma.modality.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModalityFindUniqueArgs>(args: SelectSubset<T, ModalityFindUniqueArgs<ExtArgs>>): Prisma__ModalityClient<$Result.GetResult<Prisma.$ModalityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Modality that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModalityFindUniqueOrThrowArgs} args - Arguments to find a Modality
     * @example
     * // Get one Modality
     * const modality = await prisma.modality.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModalityFindUniqueOrThrowArgs>(args: SelectSubset<T, ModalityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModalityClient<$Result.GetResult<Prisma.$ModalityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Modality that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModalityFindFirstArgs} args - Arguments to find a Modality
     * @example
     * // Get one Modality
     * const modality = await prisma.modality.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModalityFindFirstArgs>(args?: SelectSubset<T, ModalityFindFirstArgs<ExtArgs>>): Prisma__ModalityClient<$Result.GetResult<Prisma.$ModalityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Modality that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModalityFindFirstOrThrowArgs} args - Arguments to find a Modality
     * @example
     * // Get one Modality
     * const modality = await prisma.modality.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModalityFindFirstOrThrowArgs>(args?: SelectSubset<T, ModalityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModalityClient<$Result.GetResult<Prisma.$ModalityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Modalities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModalityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modalities
     * const modalities = await prisma.modality.findMany()
     * 
     * // Get first 10 Modalities
     * const modalities = await prisma.modality.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modalityWithIdOnly = await prisma.modality.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModalityFindManyArgs>(args?: SelectSubset<T, ModalityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModalityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Modality.
     * @param {ModalityCreateArgs} args - Arguments to create a Modality.
     * @example
     * // Create one Modality
     * const Modality = await prisma.modality.create({
     *   data: {
     *     // ... data to create a Modality
     *   }
     * })
     * 
     */
    create<T extends ModalityCreateArgs>(args: SelectSubset<T, ModalityCreateArgs<ExtArgs>>): Prisma__ModalityClient<$Result.GetResult<Prisma.$ModalityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Modalities.
     * @param {ModalityCreateManyArgs} args - Arguments to create many Modalities.
     * @example
     * // Create many Modalities
     * const modality = await prisma.modality.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModalityCreateManyArgs>(args?: SelectSubset<T, ModalityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Modalities and returns the data saved in the database.
     * @param {ModalityCreateManyAndReturnArgs} args - Arguments to create many Modalities.
     * @example
     * // Create many Modalities
     * const modality = await prisma.modality.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Modalities and only return the `id`
     * const modalityWithIdOnly = await prisma.modality.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModalityCreateManyAndReturnArgs>(args?: SelectSubset<T, ModalityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModalityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Modality.
     * @param {ModalityDeleteArgs} args - Arguments to delete one Modality.
     * @example
     * // Delete one Modality
     * const Modality = await prisma.modality.delete({
     *   where: {
     *     // ... filter to delete one Modality
     *   }
     * })
     * 
     */
    delete<T extends ModalityDeleteArgs>(args: SelectSubset<T, ModalityDeleteArgs<ExtArgs>>): Prisma__ModalityClient<$Result.GetResult<Prisma.$ModalityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Modality.
     * @param {ModalityUpdateArgs} args - Arguments to update one Modality.
     * @example
     * // Update one Modality
     * const modality = await prisma.modality.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModalityUpdateArgs>(args: SelectSubset<T, ModalityUpdateArgs<ExtArgs>>): Prisma__ModalityClient<$Result.GetResult<Prisma.$ModalityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Modalities.
     * @param {ModalityDeleteManyArgs} args - Arguments to filter Modalities to delete.
     * @example
     * // Delete a few Modalities
     * const { count } = await prisma.modality.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModalityDeleteManyArgs>(args?: SelectSubset<T, ModalityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModalityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modalities
     * const modality = await prisma.modality.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModalityUpdateManyArgs>(args: SelectSubset<T, ModalityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modalities and returns the data updated in the database.
     * @param {ModalityUpdateManyAndReturnArgs} args - Arguments to update many Modalities.
     * @example
     * // Update many Modalities
     * const modality = await prisma.modality.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Modalities and only return the `id`
     * const modalityWithIdOnly = await prisma.modality.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModalityUpdateManyAndReturnArgs>(args: SelectSubset<T, ModalityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModalityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Modality.
     * @param {ModalityUpsertArgs} args - Arguments to update or create a Modality.
     * @example
     * // Update or create a Modality
     * const modality = await prisma.modality.upsert({
     *   create: {
     *     // ... data to create a Modality
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Modality we want to update
     *   }
     * })
     */
    upsert<T extends ModalityUpsertArgs>(args: SelectSubset<T, ModalityUpsertArgs<ExtArgs>>): Prisma__ModalityClient<$Result.GetResult<Prisma.$ModalityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Modalities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModalityCountArgs} args - Arguments to filter Modalities to count.
     * @example
     * // Count the number of Modalities
     * const count = await prisma.modality.count({
     *   where: {
     *     // ... the filter for the Modalities we want to count
     *   }
     * })
    **/
    count<T extends ModalityCountArgs>(
      args?: Subset<T, ModalityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModalityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Modality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModalityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModalityAggregateArgs>(args: Subset<T, ModalityAggregateArgs>): Prisma.PrismaPromise<GetModalityAggregateType<T>>

    /**
     * Group by Modality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModalityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModalityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModalityGroupByArgs['orderBy'] }
        : { orderBy?: ModalityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModalityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModalityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Modality model
   */
  readonly fields: ModalityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Modality.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModalityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    studies<T extends Modality$studiesArgs<ExtArgs> = {}>(args?: Subset<T, Modality$studiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    radiologyOrders<T extends Modality$radiologyOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Modality$radiologyOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiologyOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Modality model
   */
  interface ModalityFieldRefs {
    readonly id: FieldRef<"Modality", 'String'>
    readonly name: FieldRef<"Modality", 'String'>
    readonly description: FieldRef<"Modality", 'String'>
    readonly isActive: FieldRef<"Modality", 'Boolean'>
    readonly createdAt: FieldRef<"Modality", 'DateTime'>
    readonly updatedAt: FieldRef<"Modality", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Modality findUnique
   */
  export type ModalityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modality
     */
    select?: ModalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Modality
     */
    omit?: ModalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModalityInclude<ExtArgs> | null
    /**
     * Filter, which Modality to fetch.
     */
    where: ModalityWhereUniqueInput
  }

  /**
   * Modality findUniqueOrThrow
   */
  export type ModalityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modality
     */
    select?: ModalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Modality
     */
    omit?: ModalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModalityInclude<ExtArgs> | null
    /**
     * Filter, which Modality to fetch.
     */
    where: ModalityWhereUniqueInput
  }

  /**
   * Modality findFirst
   */
  export type ModalityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modality
     */
    select?: ModalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Modality
     */
    omit?: ModalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModalityInclude<ExtArgs> | null
    /**
     * Filter, which Modality to fetch.
     */
    where?: ModalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modalities to fetch.
     */
    orderBy?: ModalityOrderByWithRelationInput | ModalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modalities.
     */
    cursor?: ModalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modalities.
     */
    distinct?: ModalityScalarFieldEnum | ModalityScalarFieldEnum[]
  }

  /**
   * Modality findFirstOrThrow
   */
  export type ModalityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modality
     */
    select?: ModalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Modality
     */
    omit?: ModalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModalityInclude<ExtArgs> | null
    /**
     * Filter, which Modality to fetch.
     */
    where?: ModalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modalities to fetch.
     */
    orderBy?: ModalityOrderByWithRelationInput | ModalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modalities.
     */
    cursor?: ModalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modalities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modalities.
     */
    distinct?: ModalityScalarFieldEnum | ModalityScalarFieldEnum[]
  }

  /**
   * Modality findMany
   */
  export type ModalityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modality
     */
    select?: ModalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Modality
     */
    omit?: ModalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModalityInclude<ExtArgs> | null
    /**
     * Filter, which Modalities to fetch.
     */
    where?: ModalityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modalities to fetch.
     */
    orderBy?: ModalityOrderByWithRelationInput | ModalityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modalities.
     */
    cursor?: ModalityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modalities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modalities.
     */
    skip?: number
    distinct?: ModalityScalarFieldEnum | ModalityScalarFieldEnum[]
  }

  /**
   * Modality create
   */
  export type ModalityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modality
     */
    select?: ModalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Modality
     */
    omit?: ModalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModalityInclude<ExtArgs> | null
    /**
     * The data needed to create a Modality.
     */
    data: XOR<ModalityCreateInput, ModalityUncheckedCreateInput>
  }

  /**
   * Modality createMany
   */
  export type ModalityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modalities.
     */
    data: ModalityCreateManyInput | ModalityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Modality createManyAndReturn
   */
  export type ModalityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modality
     */
    select?: ModalitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Modality
     */
    omit?: ModalityOmit<ExtArgs> | null
    /**
     * The data used to create many Modalities.
     */
    data: ModalityCreateManyInput | ModalityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Modality update
   */
  export type ModalityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modality
     */
    select?: ModalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Modality
     */
    omit?: ModalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModalityInclude<ExtArgs> | null
    /**
     * The data needed to update a Modality.
     */
    data: XOR<ModalityUpdateInput, ModalityUncheckedUpdateInput>
    /**
     * Choose, which Modality to update.
     */
    where: ModalityWhereUniqueInput
  }

  /**
   * Modality updateMany
   */
  export type ModalityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modalities.
     */
    data: XOR<ModalityUpdateManyMutationInput, ModalityUncheckedUpdateManyInput>
    /**
     * Filter which Modalities to update
     */
    where?: ModalityWhereInput
    /**
     * Limit how many Modalities to update.
     */
    limit?: number
  }

  /**
   * Modality updateManyAndReturn
   */
  export type ModalityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modality
     */
    select?: ModalitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Modality
     */
    omit?: ModalityOmit<ExtArgs> | null
    /**
     * The data used to update Modalities.
     */
    data: XOR<ModalityUpdateManyMutationInput, ModalityUncheckedUpdateManyInput>
    /**
     * Filter which Modalities to update
     */
    where?: ModalityWhereInput
    /**
     * Limit how many Modalities to update.
     */
    limit?: number
  }

  /**
   * Modality upsert
   */
  export type ModalityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modality
     */
    select?: ModalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Modality
     */
    omit?: ModalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModalityInclude<ExtArgs> | null
    /**
     * The filter to search for the Modality to update in case it exists.
     */
    where: ModalityWhereUniqueInput
    /**
     * In case the Modality found by the `where` argument doesn't exist, create a new Modality with this data.
     */
    create: XOR<ModalityCreateInput, ModalityUncheckedCreateInput>
    /**
     * In case the Modality was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModalityUpdateInput, ModalityUncheckedUpdateInput>
  }

  /**
   * Modality delete
   */
  export type ModalityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modality
     */
    select?: ModalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Modality
     */
    omit?: ModalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModalityInclude<ExtArgs> | null
    /**
     * Filter which Modality to delete.
     */
    where: ModalityWhereUniqueInput
  }

  /**
   * Modality deleteMany
   */
  export type ModalityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modalities to delete
     */
    where?: ModalityWhereInput
    /**
     * Limit how many Modalities to delete.
     */
    limit?: number
  }

  /**
   * Modality.studies
   */
  export type Modality$studiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    where?: StudyWhereInput
    orderBy?: StudyOrderByWithRelationInput | StudyOrderByWithRelationInput[]
    cursor?: StudyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudyScalarFieldEnum | StudyScalarFieldEnum[]
  }

  /**
   * Modality.radiologyOrders
   */
  export type Modality$radiologyOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyOrder
     */
    select?: RadiologyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyOrder
     */
    omit?: RadiologyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyOrderInclude<ExtArgs> | null
    where?: RadiologyOrderWhereInput
    orderBy?: RadiologyOrderOrderByWithRelationInput | RadiologyOrderOrderByWithRelationInput[]
    cursor?: RadiologyOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RadiologyOrderScalarFieldEnum | RadiologyOrderScalarFieldEnum[]
  }

  /**
   * Modality without action
   */
  export type ModalityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Modality
     */
    select?: ModalitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Modality
     */
    omit?: ModalityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModalityInclude<ExtArgs> | null
  }


  /**
   * Model Study
   */

  export type AggregateStudy = {
    _count: StudyCountAggregateOutputType | null
    _min: StudyMinAggregateOutputType | null
    _max: StudyMaxAggregateOutputType | null
  }

  export type StudyMinAggregateOutputType = {
    id: string | null
    studyId: string | null
    patientId: string | null
    patientName: string | null
    modalityId: string | null
    status: $Enums.StudyStatus | null
    studyDate: Date | null
    priority: $Enums.Priority | null
    description: string | null
    notes: string | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudyMaxAggregateOutputType = {
    id: string | null
    studyId: string | null
    patientId: string | null
    patientName: string | null
    modalityId: string | null
    status: $Enums.StudyStatus | null
    studyDate: Date | null
    priority: $Enums.Priority | null
    description: string | null
    notes: string | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudyCountAggregateOutputType = {
    id: number
    studyId: number
    patientId: number
    patientName: number
    modalityId: number
    status: number
    studyDate: number
    priority: number
    description: number
    notes: number
    isActive: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudyMinAggregateInputType = {
    id?: true
    studyId?: true
    patientId?: true
    patientName?: true
    modalityId?: true
    status?: true
    studyDate?: true
    priority?: true
    description?: true
    notes?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudyMaxAggregateInputType = {
    id?: true
    studyId?: true
    patientId?: true
    patientName?: true
    modalityId?: true
    status?: true
    studyDate?: true
    priority?: true
    description?: true
    notes?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudyCountAggregateInputType = {
    id?: true
    studyId?: true
    patientId?: true
    patientName?: true
    modalityId?: true
    status?: true
    studyDate?: true
    priority?: true
    description?: true
    notes?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Study to aggregate.
     */
    where?: StudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Studies to fetch.
     */
    orderBy?: StudyOrderByWithRelationInput | StudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Studies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Studies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Studies
    **/
    _count?: true | StudyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudyMaxAggregateInputType
  }

  export type GetStudyAggregateType<T extends StudyAggregateArgs> = {
        [P in keyof T & keyof AggregateStudy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudy[P]>
      : GetScalarType<T[P], AggregateStudy[P]>
  }




  export type StudyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyWhereInput
    orderBy?: StudyOrderByWithAggregationInput | StudyOrderByWithAggregationInput[]
    by: StudyScalarFieldEnum[] | StudyScalarFieldEnum
    having?: StudyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudyCountAggregateInputType | true
    _min?: StudyMinAggregateInputType
    _max?: StudyMaxAggregateInputType
  }

  export type StudyGroupByOutputType = {
    id: string
    studyId: string
    patientId: string
    patientName: string
    modalityId: string
    status: $Enums.StudyStatus
    studyDate: Date
    priority: $Enums.Priority | null
    description: string | null
    notes: string | null
    isActive: boolean
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: StudyCountAggregateOutputType | null
    _min: StudyMinAggregateOutputType | null
    _max: StudyMaxAggregateOutputType | null
  }

  type GetStudyGroupByPayload<T extends StudyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudyGroupByOutputType[P]>
            : GetScalarType<T[P], StudyGroupByOutputType[P]>
        }
      >
    >


  export type StudySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studyId?: boolean
    patientId?: boolean
    patientName?: boolean
    modalityId?: boolean
    status?: boolean
    studyDate?: boolean
    priority?: boolean
    description?: boolean
    notes?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    modality?: boolean | ModalityDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    series?: boolean | Study$seriesArgs<ExtArgs>
    radReports?: boolean | Study$radReportsArgs<ExtArgs>
    radiationDoses?: boolean | Study$radiationDosesArgs<ExtArgs>
    radiologyOrders?: boolean | Study$radiologyOrdersArgs<ExtArgs>
    _count?: boolean | StudyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["study"]>

  export type StudySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studyId?: boolean
    patientId?: boolean
    patientName?: boolean
    modalityId?: boolean
    status?: boolean
    studyDate?: boolean
    priority?: boolean
    description?: boolean
    notes?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    modality?: boolean | ModalityDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["study"]>

  export type StudySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studyId?: boolean
    patientId?: boolean
    patientName?: boolean
    modalityId?: boolean
    status?: boolean
    studyDate?: boolean
    priority?: boolean
    description?: boolean
    notes?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    modality?: boolean | ModalityDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["study"]>

  export type StudySelectScalar = {
    id?: boolean
    studyId?: boolean
    patientId?: boolean
    patientName?: boolean
    modalityId?: boolean
    status?: boolean
    studyDate?: boolean
    priority?: boolean
    description?: boolean
    notes?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studyId" | "patientId" | "patientName" | "modalityId" | "status" | "studyDate" | "priority" | "description" | "notes" | "isActive" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["study"]>
  export type StudyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modality?: boolean | ModalityDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    series?: boolean | Study$seriesArgs<ExtArgs>
    radReports?: boolean | Study$radReportsArgs<ExtArgs>
    radiationDoses?: boolean | Study$radiationDosesArgs<ExtArgs>
    radiologyOrders?: boolean | Study$radiologyOrdersArgs<ExtArgs>
    _count?: boolean | StudyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modality?: boolean | ModalityDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type StudyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modality?: boolean | ModalityDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $StudyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Study"
    objects: {
      modality: Prisma.$ModalityPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
      series: Prisma.$SeriesPayload<ExtArgs>[]
      radReports: Prisma.$RadReportPayload<ExtArgs>[]
      radiationDoses: Prisma.$RadiationDosePayload<ExtArgs>[]
      radiologyOrders: Prisma.$RadiologyOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studyId: string
      patientId: string
      patientName: string
      modalityId: string
      status: $Enums.StudyStatus
      studyDate: Date
      priority: $Enums.Priority | null
      description: string | null
      notes: string | null
      isActive: boolean
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["study"]>
    composites: {}
  }

  type StudyGetPayload<S extends boolean | null | undefined | StudyDefaultArgs> = $Result.GetResult<Prisma.$StudyPayload, S>

  type StudyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudyCountAggregateInputType | true
    }

  export interface StudyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Study'], meta: { name: 'Study' } }
    /**
     * Find zero or one Study that matches the filter.
     * @param {StudyFindUniqueArgs} args - Arguments to find a Study
     * @example
     * // Get one Study
     * const study = await prisma.study.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudyFindUniqueArgs>(args: SelectSubset<T, StudyFindUniqueArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Study that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudyFindUniqueOrThrowArgs} args - Arguments to find a Study
     * @example
     * // Get one Study
     * const study = await prisma.study.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudyFindUniqueOrThrowArgs>(args: SelectSubset<T, StudyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyFindFirstArgs} args - Arguments to find a Study
     * @example
     * // Get one Study
     * const study = await prisma.study.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudyFindFirstArgs>(args?: SelectSubset<T, StudyFindFirstArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyFindFirstOrThrowArgs} args - Arguments to find a Study
     * @example
     * // Get one Study
     * const study = await prisma.study.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudyFindFirstOrThrowArgs>(args?: SelectSubset<T, StudyFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Studies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Studies
     * const studies = await prisma.study.findMany()
     * 
     * // Get first 10 Studies
     * const studies = await prisma.study.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studyWithIdOnly = await prisma.study.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudyFindManyArgs>(args?: SelectSubset<T, StudyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Study.
     * @param {StudyCreateArgs} args - Arguments to create a Study.
     * @example
     * // Create one Study
     * const Study = await prisma.study.create({
     *   data: {
     *     // ... data to create a Study
     *   }
     * })
     * 
     */
    create<T extends StudyCreateArgs>(args: SelectSubset<T, StudyCreateArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Studies.
     * @param {StudyCreateManyArgs} args - Arguments to create many Studies.
     * @example
     * // Create many Studies
     * const study = await prisma.study.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudyCreateManyArgs>(args?: SelectSubset<T, StudyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Studies and returns the data saved in the database.
     * @param {StudyCreateManyAndReturnArgs} args - Arguments to create many Studies.
     * @example
     * // Create many Studies
     * const study = await prisma.study.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Studies and only return the `id`
     * const studyWithIdOnly = await prisma.study.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudyCreateManyAndReturnArgs>(args?: SelectSubset<T, StudyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Study.
     * @param {StudyDeleteArgs} args - Arguments to delete one Study.
     * @example
     * // Delete one Study
     * const Study = await prisma.study.delete({
     *   where: {
     *     // ... filter to delete one Study
     *   }
     * })
     * 
     */
    delete<T extends StudyDeleteArgs>(args: SelectSubset<T, StudyDeleteArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Study.
     * @param {StudyUpdateArgs} args - Arguments to update one Study.
     * @example
     * // Update one Study
     * const study = await prisma.study.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudyUpdateArgs>(args: SelectSubset<T, StudyUpdateArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Studies.
     * @param {StudyDeleteManyArgs} args - Arguments to filter Studies to delete.
     * @example
     * // Delete a few Studies
     * const { count } = await prisma.study.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudyDeleteManyArgs>(args?: SelectSubset<T, StudyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Studies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Studies
     * const study = await prisma.study.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudyUpdateManyArgs>(args: SelectSubset<T, StudyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Studies and returns the data updated in the database.
     * @param {StudyUpdateManyAndReturnArgs} args - Arguments to update many Studies.
     * @example
     * // Update many Studies
     * const study = await prisma.study.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Studies and only return the `id`
     * const studyWithIdOnly = await prisma.study.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudyUpdateManyAndReturnArgs>(args: SelectSubset<T, StudyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Study.
     * @param {StudyUpsertArgs} args - Arguments to update or create a Study.
     * @example
     * // Update or create a Study
     * const study = await prisma.study.upsert({
     *   create: {
     *     // ... data to create a Study
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Study we want to update
     *   }
     * })
     */
    upsert<T extends StudyUpsertArgs>(args: SelectSubset<T, StudyUpsertArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Studies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyCountArgs} args - Arguments to filter Studies to count.
     * @example
     * // Count the number of Studies
     * const count = await prisma.study.count({
     *   where: {
     *     // ... the filter for the Studies we want to count
     *   }
     * })
    **/
    count<T extends StudyCountArgs>(
      args?: Subset<T, StudyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Study.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudyAggregateArgs>(args: Subset<T, StudyAggregateArgs>): Prisma.PrismaPromise<GetStudyAggregateType<T>>

    /**
     * Group by Study.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudyGroupByArgs['orderBy'] }
        : { orderBy?: StudyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Study model
   */
  readonly fields: StudyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Study.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    modality<T extends ModalityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModalityDefaultArgs<ExtArgs>>): Prisma__ModalityClient<$Result.GetResult<Prisma.$ModalityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    series<T extends Study$seriesArgs<ExtArgs> = {}>(args?: Subset<T, Study$seriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    radReports<T extends Study$radReportsArgs<ExtArgs> = {}>(args?: Subset<T, Study$radReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    radiationDoses<T extends Study$radiationDosesArgs<ExtArgs> = {}>(args?: Subset<T, Study$radiationDosesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiationDosePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    radiologyOrders<T extends Study$radiologyOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Study$radiologyOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiologyOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Study model
   */
  interface StudyFieldRefs {
    readonly id: FieldRef<"Study", 'String'>
    readonly studyId: FieldRef<"Study", 'String'>
    readonly patientId: FieldRef<"Study", 'String'>
    readonly patientName: FieldRef<"Study", 'String'>
    readonly modalityId: FieldRef<"Study", 'String'>
    readonly status: FieldRef<"Study", 'StudyStatus'>
    readonly studyDate: FieldRef<"Study", 'DateTime'>
    readonly priority: FieldRef<"Study", 'Priority'>
    readonly description: FieldRef<"Study", 'String'>
    readonly notes: FieldRef<"Study", 'String'>
    readonly isActive: FieldRef<"Study", 'Boolean'>
    readonly tenantId: FieldRef<"Study", 'String'>
    readonly createdAt: FieldRef<"Study", 'DateTime'>
    readonly updatedAt: FieldRef<"Study", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Study findUnique
   */
  export type StudyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    /**
     * Filter, which Study to fetch.
     */
    where: StudyWhereUniqueInput
  }

  /**
   * Study findUniqueOrThrow
   */
  export type StudyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    /**
     * Filter, which Study to fetch.
     */
    where: StudyWhereUniqueInput
  }

  /**
   * Study findFirst
   */
  export type StudyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    /**
     * Filter, which Study to fetch.
     */
    where?: StudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Studies to fetch.
     */
    orderBy?: StudyOrderByWithRelationInput | StudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Studies.
     */
    cursor?: StudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Studies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Studies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Studies.
     */
    distinct?: StudyScalarFieldEnum | StudyScalarFieldEnum[]
  }

  /**
   * Study findFirstOrThrow
   */
  export type StudyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    /**
     * Filter, which Study to fetch.
     */
    where?: StudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Studies to fetch.
     */
    orderBy?: StudyOrderByWithRelationInput | StudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Studies.
     */
    cursor?: StudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Studies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Studies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Studies.
     */
    distinct?: StudyScalarFieldEnum | StudyScalarFieldEnum[]
  }

  /**
   * Study findMany
   */
  export type StudyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    /**
     * Filter, which Studies to fetch.
     */
    where?: StudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Studies to fetch.
     */
    orderBy?: StudyOrderByWithRelationInput | StudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Studies.
     */
    cursor?: StudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Studies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Studies.
     */
    skip?: number
    distinct?: StudyScalarFieldEnum | StudyScalarFieldEnum[]
  }

  /**
   * Study create
   */
  export type StudyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    /**
     * The data needed to create a Study.
     */
    data: XOR<StudyCreateInput, StudyUncheckedCreateInput>
  }

  /**
   * Study createMany
   */
  export type StudyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Studies.
     */
    data: StudyCreateManyInput | StudyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Study createManyAndReturn
   */
  export type StudyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * The data used to create many Studies.
     */
    data: StudyCreateManyInput | StudyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Study update
   */
  export type StudyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    /**
     * The data needed to update a Study.
     */
    data: XOR<StudyUpdateInput, StudyUncheckedUpdateInput>
    /**
     * Choose, which Study to update.
     */
    where: StudyWhereUniqueInput
  }

  /**
   * Study updateMany
   */
  export type StudyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Studies.
     */
    data: XOR<StudyUpdateManyMutationInput, StudyUncheckedUpdateManyInput>
    /**
     * Filter which Studies to update
     */
    where?: StudyWhereInput
    /**
     * Limit how many Studies to update.
     */
    limit?: number
  }

  /**
   * Study updateManyAndReturn
   */
  export type StudyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * The data used to update Studies.
     */
    data: XOR<StudyUpdateManyMutationInput, StudyUncheckedUpdateManyInput>
    /**
     * Filter which Studies to update
     */
    where?: StudyWhereInput
    /**
     * Limit how many Studies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Study upsert
   */
  export type StudyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    /**
     * The filter to search for the Study to update in case it exists.
     */
    where: StudyWhereUniqueInput
    /**
     * In case the Study found by the `where` argument doesn't exist, create a new Study with this data.
     */
    create: XOR<StudyCreateInput, StudyUncheckedCreateInput>
    /**
     * In case the Study was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudyUpdateInput, StudyUncheckedUpdateInput>
  }

  /**
   * Study delete
   */
  export type StudyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    /**
     * Filter which Study to delete.
     */
    where: StudyWhereUniqueInput
  }

  /**
   * Study deleteMany
   */
  export type StudyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Studies to delete
     */
    where?: StudyWhereInput
    /**
     * Limit how many Studies to delete.
     */
    limit?: number
  }

  /**
   * Study.series
   */
  export type Study$seriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    where?: SeriesWhereInput
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    cursor?: SeriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Study.radReports
   */
  export type Study$radReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadReport
     */
    select?: RadReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadReport
     */
    omit?: RadReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadReportInclude<ExtArgs> | null
    where?: RadReportWhereInput
    orderBy?: RadReportOrderByWithRelationInput | RadReportOrderByWithRelationInput[]
    cursor?: RadReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RadReportScalarFieldEnum | RadReportScalarFieldEnum[]
  }

  /**
   * Study.radiationDoses
   */
  export type Study$radiationDosesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationDose
     */
    select?: RadiationDoseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationDose
     */
    omit?: RadiationDoseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationDoseInclude<ExtArgs> | null
    where?: RadiationDoseWhereInput
    orderBy?: RadiationDoseOrderByWithRelationInput | RadiationDoseOrderByWithRelationInput[]
    cursor?: RadiationDoseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RadiationDoseScalarFieldEnum | RadiationDoseScalarFieldEnum[]
  }

  /**
   * Study.radiologyOrders
   */
  export type Study$radiologyOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyOrder
     */
    select?: RadiologyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyOrder
     */
    omit?: RadiologyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyOrderInclude<ExtArgs> | null
    where?: RadiologyOrderWhereInput
    orderBy?: RadiologyOrderOrderByWithRelationInput | RadiologyOrderOrderByWithRelationInput[]
    cursor?: RadiologyOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RadiologyOrderScalarFieldEnum | RadiologyOrderScalarFieldEnum[]
  }

  /**
   * Study without action
   */
  export type StudyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
  }


  /**
   * Model Series
   */

  export type AggregateSeries = {
    _count: SeriesCountAggregateOutputType | null
    _avg: SeriesAvgAggregateOutputType | null
    _sum: SeriesSumAggregateOutputType | null
    _min: SeriesMinAggregateOutputType | null
    _max: SeriesMaxAggregateOutputType | null
  }

  export type SeriesAvgAggregateOutputType = {
    number: number | null
    count: number | null
  }

  export type SeriesSumAggregateOutputType = {
    number: number | null
    count: number | null
  }

  export type SeriesMinAggregateOutputType = {
    id: string | null
    seriesUid: string | null
    studyId: string | null
    number: number | null
    description: string | null
    modality: string | null
    bodyPart: string | null
    count: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeriesMaxAggregateOutputType = {
    id: string | null
    seriesUid: string | null
    studyId: string | null
    number: number | null
    description: string | null
    modality: string | null
    bodyPart: string | null
    count: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeriesCountAggregateOutputType = {
    id: number
    seriesUid: number
    studyId: number
    number: number
    description: number
    modality: number
    bodyPart: number
    count: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SeriesAvgAggregateInputType = {
    number?: true
    count?: true
  }

  export type SeriesSumAggregateInputType = {
    number?: true
    count?: true
  }

  export type SeriesMinAggregateInputType = {
    id?: true
    seriesUid?: true
    studyId?: true
    number?: true
    description?: true
    modality?: true
    bodyPart?: true
    count?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeriesMaxAggregateInputType = {
    id?: true
    seriesUid?: true
    studyId?: true
    number?: true
    description?: true
    modality?: true
    bodyPart?: true
    count?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeriesCountAggregateInputType = {
    id?: true
    seriesUid?: true
    studyId?: true
    number?: true
    description?: true
    modality?: true
    bodyPart?: true
    count?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SeriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Series to aggregate.
     */
    where?: SeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Series.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Series
    **/
    _count?: true | SeriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeriesMaxAggregateInputType
  }

  export type GetSeriesAggregateType<T extends SeriesAggregateArgs> = {
        [P in keyof T & keyof AggregateSeries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeries[P]>
      : GetScalarType<T[P], AggregateSeries[P]>
  }




  export type SeriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeriesWhereInput
    orderBy?: SeriesOrderByWithAggregationInput | SeriesOrderByWithAggregationInput[]
    by: SeriesScalarFieldEnum[] | SeriesScalarFieldEnum
    having?: SeriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeriesCountAggregateInputType | true
    _avg?: SeriesAvgAggregateInputType
    _sum?: SeriesSumAggregateInputType
    _min?: SeriesMinAggregateInputType
    _max?: SeriesMaxAggregateInputType
  }

  export type SeriesGroupByOutputType = {
    id: string
    seriesUid: string
    studyId: string
    number: number
    description: string | null
    modality: string
    bodyPart: string | null
    count: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SeriesCountAggregateOutputType | null
    _avg: SeriesAvgAggregateOutputType | null
    _sum: SeriesSumAggregateOutputType | null
    _min: SeriesMinAggregateOutputType | null
    _max: SeriesMaxAggregateOutputType | null
  }

  type GetSeriesGroupByPayload<T extends SeriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeriesGroupByOutputType[P]>
            : GetScalarType<T[P], SeriesGroupByOutputType[P]>
        }
      >
    >


  export type SeriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seriesUid?: boolean
    studyId?: boolean
    number?: boolean
    description?: boolean
    modality?: boolean
    bodyPart?: boolean
    count?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    study?: boolean | StudyDefaultArgs<ExtArgs>
    images?: boolean | Series$imagesArgs<ExtArgs>
    _count?: boolean | SeriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["series"]>

  export type SeriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seriesUid?: boolean
    studyId?: boolean
    number?: boolean
    description?: boolean
    modality?: boolean
    bodyPart?: boolean
    count?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    study?: boolean | StudyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["series"]>

  export type SeriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seriesUid?: boolean
    studyId?: boolean
    number?: boolean
    description?: boolean
    modality?: boolean
    bodyPart?: boolean
    count?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    study?: boolean | StudyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["series"]>

  export type SeriesSelectScalar = {
    id?: boolean
    seriesUid?: boolean
    studyId?: boolean
    number?: boolean
    description?: boolean
    modality?: boolean
    bodyPart?: boolean
    count?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SeriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seriesUid" | "studyId" | "number" | "description" | "modality" | "bodyPart" | "count" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["series"]>
  export type SeriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    study?: boolean | StudyDefaultArgs<ExtArgs>
    images?: boolean | Series$imagesArgs<ExtArgs>
    _count?: boolean | SeriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    study?: boolean | StudyDefaultArgs<ExtArgs>
  }
  export type SeriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    study?: boolean | StudyDefaultArgs<ExtArgs>
  }

  export type $SeriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Series"
    objects: {
      study: Prisma.$StudyPayload<ExtArgs>
      images: Prisma.$ImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seriesUid: string
      studyId: string
      number: number
      description: string | null
      modality: string
      bodyPart: string | null
      count: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["series"]>
    composites: {}
  }

  type SeriesGetPayload<S extends boolean | null | undefined | SeriesDefaultArgs> = $Result.GetResult<Prisma.$SeriesPayload, S>

  type SeriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeriesCountAggregateInputType | true
    }

  export interface SeriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Series'], meta: { name: 'Series' } }
    /**
     * Find zero or one Series that matches the filter.
     * @param {SeriesFindUniqueArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeriesFindUniqueArgs>(args: SelectSubset<T, SeriesFindUniqueArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Series that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeriesFindUniqueOrThrowArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeriesFindUniqueOrThrowArgs>(args: SelectSubset<T, SeriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Series that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesFindFirstArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeriesFindFirstArgs>(args?: SelectSubset<T, SeriesFindFirstArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Series that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesFindFirstOrThrowArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeriesFindFirstOrThrowArgs>(args?: SelectSubset<T, SeriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Series that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Series
     * const series = await prisma.series.findMany()
     * 
     * // Get first 10 Series
     * const series = await prisma.series.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seriesWithIdOnly = await prisma.series.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeriesFindManyArgs>(args?: SelectSubset<T, SeriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Series.
     * @param {SeriesCreateArgs} args - Arguments to create a Series.
     * @example
     * // Create one Series
     * const Series = await prisma.series.create({
     *   data: {
     *     // ... data to create a Series
     *   }
     * })
     * 
     */
    create<T extends SeriesCreateArgs>(args: SelectSubset<T, SeriesCreateArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Series.
     * @param {SeriesCreateManyArgs} args - Arguments to create many Series.
     * @example
     * // Create many Series
     * const series = await prisma.series.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeriesCreateManyArgs>(args?: SelectSubset<T, SeriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Series and returns the data saved in the database.
     * @param {SeriesCreateManyAndReturnArgs} args - Arguments to create many Series.
     * @example
     * // Create many Series
     * const series = await prisma.series.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Series and only return the `id`
     * const seriesWithIdOnly = await prisma.series.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeriesCreateManyAndReturnArgs>(args?: SelectSubset<T, SeriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Series.
     * @param {SeriesDeleteArgs} args - Arguments to delete one Series.
     * @example
     * // Delete one Series
     * const Series = await prisma.series.delete({
     *   where: {
     *     // ... filter to delete one Series
     *   }
     * })
     * 
     */
    delete<T extends SeriesDeleteArgs>(args: SelectSubset<T, SeriesDeleteArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Series.
     * @param {SeriesUpdateArgs} args - Arguments to update one Series.
     * @example
     * // Update one Series
     * const series = await prisma.series.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeriesUpdateArgs>(args: SelectSubset<T, SeriesUpdateArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Series.
     * @param {SeriesDeleteManyArgs} args - Arguments to filter Series to delete.
     * @example
     * // Delete a few Series
     * const { count } = await prisma.series.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeriesDeleteManyArgs>(args?: SelectSubset<T, SeriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Series
     * const series = await prisma.series.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeriesUpdateManyArgs>(args: SelectSubset<T, SeriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Series and returns the data updated in the database.
     * @param {SeriesUpdateManyAndReturnArgs} args - Arguments to update many Series.
     * @example
     * // Update many Series
     * const series = await prisma.series.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Series and only return the `id`
     * const seriesWithIdOnly = await prisma.series.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeriesUpdateManyAndReturnArgs>(args: SelectSubset<T, SeriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Series.
     * @param {SeriesUpsertArgs} args - Arguments to update or create a Series.
     * @example
     * // Update or create a Series
     * const series = await prisma.series.upsert({
     *   create: {
     *     // ... data to create a Series
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Series we want to update
     *   }
     * })
     */
    upsert<T extends SeriesUpsertArgs>(args: SelectSubset<T, SeriesUpsertArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesCountArgs} args - Arguments to filter Series to count.
     * @example
     * // Count the number of Series
     * const count = await prisma.series.count({
     *   where: {
     *     // ... the filter for the Series we want to count
     *   }
     * })
    **/
    count<T extends SeriesCountArgs>(
      args?: Subset<T, SeriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeriesAggregateArgs>(args: Subset<T, SeriesAggregateArgs>): Prisma.PrismaPromise<GetSeriesAggregateType<T>>

    /**
     * Group by Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeriesGroupByArgs['orderBy'] }
        : { orderBy?: SeriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Series model
   */
  readonly fields: SeriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Series.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    study<T extends StudyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudyDefaultArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    images<T extends Series$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Series$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Series model
   */
  interface SeriesFieldRefs {
    readonly id: FieldRef<"Series", 'String'>
    readonly seriesUid: FieldRef<"Series", 'String'>
    readonly studyId: FieldRef<"Series", 'String'>
    readonly number: FieldRef<"Series", 'Int'>
    readonly description: FieldRef<"Series", 'String'>
    readonly modality: FieldRef<"Series", 'String'>
    readonly bodyPart: FieldRef<"Series", 'String'>
    readonly count: FieldRef<"Series", 'Int'>
    readonly isActive: FieldRef<"Series", 'Boolean'>
    readonly createdAt: FieldRef<"Series", 'DateTime'>
    readonly updatedAt: FieldRef<"Series", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Series findUnique
   */
  export type SeriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where: SeriesWhereUniqueInput
  }

  /**
   * Series findUniqueOrThrow
   */
  export type SeriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where: SeriesWhereUniqueInput
  }

  /**
   * Series findFirst
   */
  export type SeriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where?: SeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Series.
     */
    cursor?: SeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Series.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Series.
     */
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Series findFirstOrThrow
   */
  export type SeriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where?: SeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Series.
     */
    cursor?: SeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Series.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Series.
     */
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Series findMany
   */
  export type SeriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where?: SeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Series.
     */
    cursor?: SeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Series.
     */
    skip?: number
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Series create
   */
  export type SeriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * The data needed to create a Series.
     */
    data: XOR<SeriesCreateInput, SeriesUncheckedCreateInput>
  }

  /**
   * Series createMany
   */
  export type SeriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Series.
     */
    data: SeriesCreateManyInput | SeriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Series createManyAndReturn
   */
  export type SeriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * The data used to create many Series.
     */
    data: SeriesCreateManyInput | SeriesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Series update
   */
  export type SeriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * The data needed to update a Series.
     */
    data: XOR<SeriesUpdateInput, SeriesUncheckedUpdateInput>
    /**
     * Choose, which Series to update.
     */
    where: SeriesWhereUniqueInput
  }

  /**
   * Series updateMany
   */
  export type SeriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Series.
     */
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyInput>
    /**
     * Filter which Series to update
     */
    where?: SeriesWhereInput
    /**
     * Limit how many Series to update.
     */
    limit?: number
  }

  /**
   * Series updateManyAndReturn
   */
  export type SeriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * The data used to update Series.
     */
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyInput>
    /**
     * Filter which Series to update
     */
    where?: SeriesWhereInput
    /**
     * Limit how many Series to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Series upsert
   */
  export type SeriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * The filter to search for the Series to update in case it exists.
     */
    where: SeriesWhereUniqueInput
    /**
     * In case the Series found by the `where` argument doesn't exist, create a new Series with this data.
     */
    create: XOR<SeriesCreateInput, SeriesUncheckedCreateInput>
    /**
     * In case the Series was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeriesUpdateInput, SeriesUncheckedUpdateInput>
  }

  /**
   * Series delete
   */
  export type SeriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter which Series to delete.
     */
    where: SeriesWhereUniqueInput
  }

  /**
   * Series deleteMany
   */
  export type SeriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Series to delete
     */
    where?: SeriesWhereInput
    /**
     * Limit how many Series to delete.
     */
    limit?: number
  }

  /**
   * Series.images
   */
  export type Series$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    cursor?: ImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Series without action
   */
  export type SeriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
  }


  /**
   * Model Image
   */

  export type AggregateImage = {
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  export type ImageAvgAggregateOutputType = {
    number: number | null
    size: number | null
    width: number | null
    height: number | null
    windowCenter: number | null
    windowWidth: number | null
  }

  export type ImageSumAggregateOutputType = {
    number: number | null
    size: number | null
    width: number | null
    height: number | null
    windowCenter: number | null
    windowWidth: number | null
  }

  export type ImageMinAggregateOutputType = {
    id: string | null
    sopInstanceUid: string | null
    seriesId: string | null
    number: number | null
    path: string | null
    size: number | null
    contentType: string | null
    width: number | null
    height: number | null
    windowCenter: number | null
    windowWidth: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImageMaxAggregateOutputType = {
    id: string | null
    sopInstanceUid: string | null
    seriesId: string | null
    number: number | null
    path: string | null
    size: number | null
    contentType: string | null
    width: number | null
    height: number | null
    windowCenter: number | null
    windowWidth: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImageCountAggregateOutputType = {
    id: number
    sopInstanceUid: number
    seriesId: number
    number: number
    path: number
    size: number
    contentType: number
    width: number
    height: number
    windowCenter: number
    windowWidth: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ImageAvgAggregateInputType = {
    number?: true
    size?: true
    width?: true
    height?: true
    windowCenter?: true
    windowWidth?: true
  }

  export type ImageSumAggregateInputType = {
    number?: true
    size?: true
    width?: true
    height?: true
    windowCenter?: true
    windowWidth?: true
  }

  export type ImageMinAggregateInputType = {
    id?: true
    sopInstanceUid?: true
    seriesId?: true
    number?: true
    path?: true
    size?: true
    contentType?: true
    width?: true
    height?: true
    windowCenter?: true
    windowWidth?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImageMaxAggregateInputType = {
    id?: true
    sopInstanceUid?: true
    seriesId?: true
    number?: true
    path?: true
    size?: true
    contentType?: true
    width?: true
    height?: true
    windowCenter?: true
    windowWidth?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImageCountAggregateInputType = {
    id?: true
    sopInstanceUid?: true
    seriesId?: true
    number?: true
    path?: true
    size?: true
    contentType?: true
    width?: true
    height?: true
    windowCenter?: true
    windowWidth?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Image to aggregate.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Images
    **/
    _count?: true | ImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageMaxAggregateInputType
  }

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
        [P in keyof T & keyof AggregateImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>
  }




  export type ImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithAggregationInput | ImageOrderByWithAggregationInput[]
    by: ImageScalarFieldEnum[] | ImageScalarFieldEnum
    having?: ImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageCountAggregateInputType | true
    _avg?: ImageAvgAggregateInputType
    _sum?: ImageSumAggregateInputType
    _min?: ImageMinAggregateInputType
    _max?: ImageMaxAggregateInputType
  }

  export type ImageGroupByOutputType = {
    id: string
    sopInstanceUid: string
    seriesId: string
    number: number
    path: string
    size: number
    contentType: string
    width: number
    height: number
    windowCenter: number | null
    windowWidth: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  type GetImageGroupByPayload<T extends ImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageGroupByOutputType[P]>
            : GetScalarType<T[P], ImageGroupByOutputType[P]>
        }
      >
    >


  export type ImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sopInstanceUid?: boolean
    seriesId?: boolean
    number?: boolean
    path?: boolean
    size?: boolean
    contentType?: boolean
    width?: boolean
    height?: boolean
    windowCenter?: boolean
    windowWidth?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    series?: boolean | SeriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>

  export type ImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sopInstanceUid?: boolean
    seriesId?: boolean
    number?: boolean
    path?: boolean
    size?: boolean
    contentType?: boolean
    width?: boolean
    height?: boolean
    windowCenter?: boolean
    windowWidth?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    series?: boolean | SeriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>

  export type ImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sopInstanceUid?: boolean
    seriesId?: boolean
    number?: boolean
    path?: boolean
    size?: boolean
    contentType?: boolean
    width?: boolean
    height?: boolean
    windowCenter?: boolean
    windowWidth?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    series?: boolean | SeriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>

  export type ImageSelectScalar = {
    id?: boolean
    sopInstanceUid?: boolean
    seriesId?: boolean
    number?: boolean
    path?: boolean
    size?: boolean
    contentType?: boolean
    width?: boolean
    height?: boolean
    windowCenter?: boolean
    windowWidth?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sopInstanceUid" | "seriesId" | "number" | "path" | "size" | "contentType" | "width" | "height" | "windowCenter" | "windowWidth" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["image"]>
  export type ImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | SeriesDefaultArgs<ExtArgs>
  }
  export type ImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | SeriesDefaultArgs<ExtArgs>
  }
  export type ImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | SeriesDefaultArgs<ExtArgs>
  }

  export type $ImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Image"
    objects: {
      series: Prisma.$SeriesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sopInstanceUid: string
      seriesId: string
      number: number
      path: string
      size: number
      contentType: string
      width: number
      height: number
      windowCenter: number | null
      windowWidth: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["image"]>
    composites: {}
  }

  type ImageGetPayload<S extends boolean | null | undefined | ImageDefaultArgs> = $Result.GetResult<Prisma.$ImagePayload, S>

  type ImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImageCountAggregateInputType | true
    }

  export interface ImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Image'], meta: { name: 'Image' } }
    /**
     * Find zero or one Image that matches the filter.
     * @param {ImageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImageFindUniqueArgs>(args: SelectSubset<T, ImageFindUniqueArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Image that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImageFindUniqueOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImageFindFirstArgs>(args?: SelectSubset<T, ImageFindFirstArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Image that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageWithIdOnly = await prisma.image.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImageFindManyArgs>(args?: SelectSubset<T, ImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Image.
     * @param {ImageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     * 
     */
    create<T extends ImageCreateArgs>(args: SelectSubset<T, ImageCreateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Images.
     * @param {ImageCreateManyArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImageCreateManyArgs>(args?: SelectSubset<T, ImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Images and returns the data saved in the database.
     * @param {ImageCreateManyAndReturnArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Images and only return the `id`
     * const imageWithIdOnly = await prisma.image.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImageCreateManyAndReturnArgs>(args?: SelectSubset<T, ImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Image.
     * @param {ImageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     * 
     */
    delete<T extends ImageDeleteArgs>(args: SelectSubset<T, ImageDeleteArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Image.
     * @param {ImageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImageUpdateArgs>(args: SelectSubset<T, ImageUpdateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Images.
     * @param {ImageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImageDeleteManyArgs>(args?: SelectSubset<T, ImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImageUpdateManyArgs>(args: SelectSubset<T, ImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images and returns the data updated in the database.
     * @param {ImageUpdateManyAndReturnArgs} args - Arguments to update many Images.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Images and only return the `id`
     * const imageWithIdOnly = await prisma.image.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImageUpdateManyAndReturnArgs>(args: SelectSubset<T, ImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Image.
     * @param {ImageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
     */
    upsert<T extends ImageUpsertArgs>(args: SelectSubset<T, ImageUpsertArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends ImageCountArgs>(
      args?: Subset<T, ImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageAggregateArgs>(args: Subset<T, ImageAggregateArgs>): Prisma.PrismaPromise<GetImageAggregateType<T>>

    /**
     * Group by Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageGroupByArgs['orderBy'] }
        : { orderBy?: ImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Image model
   */
  readonly fields: ImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    series<T extends SeriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeriesDefaultArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Image model
   */
  interface ImageFieldRefs {
    readonly id: FieldRef<"Image", 'String'>
    readonly sopInstanceUid: FieldRef<"Image", 'String'>
    readonly seriesId: FieldRef<"Image", 'String'>
    readonly number: FieldRef<"Image", 'Int'>
    readonly path: FieldRef<"Image", 'String'>
    readonly size: FieldRef<"Image", 'Int'>
    readonly contentType: FieldRef<"Image", 'String'>
    readonly width: FieldRef<"Image", 'Int'>
    readonly height: FieldRef<"Image", 'Int'>
    readonly windowCenter: FieldRef<"Image", 'Float'>
    readonly windowWidth: FieldRef<"Image", 'Float'>
    readonly isActive: FieldRef<"Image", 'Boolean'>
    readonly createdAt: FieldRef<"Image", 'DateTime'>
    readonly updatedAt: FieldRef<"Image", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Image findUnique
   */
  export type ImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findUniqueOrThrow
   */
  export type ImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findFirst
   */
  export type ImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findFirstOrThrow
   */
  export type ImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findMany
   */
  export type ImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image create
   */
  export type ImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to create a Image.
     */
    data: XOR<ImageCreateInput, ImageUncheckedCreateInput>
  }

  /**
   * Image createMany
   */
  export type ImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Image createManyAndReturn
   */
  export type ImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Image update
   */
  export type ImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to update a Image.
     */
    data: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
    /**
     * Choose, which Image to update.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image updateMany
   */
  export type ImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
    /**
     * Limit how many Images to update.
     */
    limit?: number
  }

  /**
   * Image updateManyAndReturn
   */
  export type ImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
    /**
     * Limit how many Images to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Image upsert
   */
  export type ImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The filter to search for the Image to update in case it exists.
     */
    where: ImageWhereUniqueInput
    /**
     * In case the Image found by the `where` argument doesn't exist, create a new Image with this data.
     */
    create: XOR<ImageCreateInput, ImageUncheckedCreateInput>
    /**
     * In case the Image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
  }

  /**
   * Image delete
   */
  export type ImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter which Image to delete.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image deleteMany
   */
  export type ImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Images to delete
     */
    where?: ImageWhereInput
    /**
     * Limit how many Images to delete.
     */
    limit?: number
  }

  /**
   * Image without action
   */
  export type ImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
  }


  /**
   * Model RadReport
   */

  export type AggregateRadReport = {
    _count: RadReportCountAggregateOutputType | null
    _min: RadReportMinAggregateOutputType | null
    _max: RadReportMaxAggregateOutputType | null
  }

  export type RadReportMinAggregateOutputType = {
    id: string | null
    reportId: string | null
    studyId: string | null
    reportTemplateId: string | null
    status: $Enums.ReportStatus | null
    findings: string | null
    impression: string | null
    conclusion: string | null
    reportDateTime: Date | null
    verifiedBy: string | null
    verifiedAt: Date | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RadReportMaxAggregateOutputType = {
    id: string | null
    reportId: string | null
    studyId: string | null
    reportTemplateId: string | null
    status: $Enums.ReportStatus | null
    findings: string | null
    impression: string | null
    conclusion: string | null
    reportDateTime: Date | null
    verifiedBy: string | null
    verifiedAt: Date | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RadReportCountAggregateOutputType = {
    id: number
    reportId: number
    studyId: number
    reportTemplateId: number
    status: number
    findings: number
    impression: number
    conclusion: number
    reportDateTime: number
    verifiedBy: number
    verifiedAt: number
    isActive: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RadReportMinAggregateInputType = {
    id?: true
    reportId?: true
    studyId?: true
    reportTemplateId?: true
    status?: true
    findings?: true
    impression?: true
    conclusion?: true
    reportDateTime?: true
    verifiedBy?: true
    verifiedAt?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RadReportMaxAggregateInputType = {
    id?: true
    reportId?: true
    studyId?: true
    reportTemplateId?: true
    status?: true
    findings?: true
    impression?: true
    conclusion?: true
    reportDateTime?: true
    verifiedBy?: true
    verifiedAt?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RadReportCountAggregateInputType = {
    id?: true
    reportId?: true
    studyId?: true
    reportTemplateId?: true
    status?: true
    findings?: true
    impression?: true
    conclusion?: true
    reportDateTime?: true
    verifiedBy?: true
    verifiedAt?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RadReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RadReport to aggregate.
     */
    where?: RadReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RadReports to fetch.
     */
    orderBy?: RadReportOrderByWithRelationInput | RadReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RadReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RadReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RadReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RadReports
    **/
    _count?: true | RadReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RadReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RadReportMaxAggregateInputType
  }

  export type GetRadReportAggregateType<T extends RadReportAggregateArgs> = {
        [P in keyof T & keyof AggregateRadReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRadReport[P]>
      : GetScalarType<T[P], AggregateRadReport[P]>
  }




  export type RadReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadReportWhereInput
    orderBy?: RadReportOrderByWithAggregationInput | RadReportOrderByWithAggregationInput[]
    by: RadReportScalarFieldEnum[] | RadReportScalarFieldEnum
    having?: RadReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RadReportCountAggregateInputType | true
    _min?: RadReportMinAggregateInputType
    _max?: RadReportMaxAggregateInputType
  }

  export type RadReportGroupByOutputType = {
    id: string
    reportId: string
    studyId: string
    reportTemplateId: string | null
    status: $Enums.ReportStatus
    findings: string | null
    impression: string | null
    conclusion: string | null
    reportDateTime: Date
    verifiedBy: string | null
    verifiedAt: Date | null
    isActive: boolean
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: RadReportCountAggregateOutputType | null
    _min: RadReportMinAggregateOutputType | null
    _max: RadReportMaxAggregateOutputType | null
  }

  type GetRadReportGroupByPayload<T extends RadReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RadReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RadReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RadReportGroupByOutputType[P]>
            : GetScalarType<T[P], RadReportGroupByOutputType[P]>
        }
      >
    >


  export type RadReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportId?: boolean
    studyId?: boolean
    reportTemplateId?: boolean
    status?: boolean
    findings?: boolean
    impression?: boolean
    conclusion?: boolean
    reportDateTime?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    study?: boolean | StudyDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    reportTemplate?: boolean | RadReport$reportTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["radReport"]>

  export type RadReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportId?: boolean
    studyId?: boolean
    reportTemplateId?: boolean
    status?: boolean
    findings?: boolean
    impression?: boolean
    conclusion?: boolean
    reportDateTime?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    study?: boolean | StudyDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    reportTemplate?: boolean | RadReport$reportTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["radReport"]>

  export type RadReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportId?: boolean
    studyId?: boolean
    reportTemplateId?: boolean
    status?: boolean
    findings?: boolean
    impression?: boolean
    conclusion?: boolean
    reportDateTime?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    study?: boolean | StudyDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    reportTemplate?: boolean | RadReport$reportTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["radReport"]>

  export type RadReportSelectScalar = {
    id?: boolean
    reportId?: boolean
    studyId?: boolean
    reportTemplateId?: boolean
    status?: boolean
    findings?: boolean
    impression?: boolean
    conclusion?: boolean
    reportDateTime?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RadReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reportId" | "studyId" | "reportTemplateId" | "status" | "findings" | "impression" | "conclusion" | "reportDateTime" | "verifiedBy" | "verifiedAt" | "isActive" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["radReport"]>
  export type RadReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    study?: boolean | StudyDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    reportTemplate?: boolean | RadReport$reportTemplateArgs<ExtArgs>
  }
  export type RadReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    study?: boolean | StudyDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    reportTemplate?: boolean | RadReport$reportTemplateArgs<ExtArgs>
  }
  export type RadReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    study?: boolean | StudyDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    reportTemplate?: boolean | RadReport$reportTemplateArgs<ExtArgs>
  }

  export type $RadReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RadReport"
    objects: {
      study: Prisma.$StudyPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
      reportTemplate: Prisma.$ReportTemplatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reportId: string
      studyId: string
      reportTemplateId: string | null
      status: $Enums.ReportStatus
      findings: string | null
      impression: string | null
      conclusion: string | null
      reportDateTime: Date
      verifiedBy: string | null
      verifiedAt: Date | null
      isActive: boolean
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["radReport"]>
    composites: {}
  }

  type RadReportGetPayload<S extends boolean | null | undefined | RadReportDefaultArgs> = $Result.GetResult<Prisma.$RadReportPayload, S>

  type RadReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RadReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RadReportCountAggregateInputType | true
    }

  export interface RadReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RadReport'], meta: { name: 'RadReport' } }
    /**
     * Find zero or one RadReport that matches the filter.
     * @param {RadReportFindUniqueArgs} args - Arguments to find a RadReport
     * @example
     * // Get one RadReport
     * const radReport = await prisma.radReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RadReportFindUniqueArgs>(args: SelectSubset<T, RadReportFindUniqueArgs<ExtArgs>>): Prisma__RadReportClient<$Result.GetResult<Prisma.$RadReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RadReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RadReportFindUniqueOrThrowArgs} args - Arguments to find a RadReport
     * @example
     * // Get one RadReport
     * const radReport = await prisma.radReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RadReportFindUniqueOrThrowArgs>(args: SelectSubset<T, RadReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RadReportClient<$Result.GetResult<Prisma.$RadReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RadReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadReportFindFirstArgs} args - Arguments to find a RadReport
     * @example
     * // Get one RadReport
     * const radReport = await prisma.radReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RadReportFindFirstArgs>(args?: SelectSubset<T, RadReportFindFirstArgs<ExtArgs>>): Prisma__RadReportClient<$Result.GetResult<Prisma.$RadReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RadReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadReportFindFirstOrThrowArgs} args - Arguments to find a RadReport
     * @example
     * // Get one RadReport
     * const radReport = await prisma.radReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RadReportFindFirstOrThrowArgs>(args?: SelectSubset<T, RadReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__RadReportClient<$Result.GetResult<Prisma.$RadReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RadReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RadReports
     * const radReports = await prisma.radReport.findMany()
     * 
     * // Get first 10 RadReports
     * const radReports = await prisma.radReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const radReportWithIdOnly = await prisma.radReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RadReportFindManyArgs>(args?: SelectSubset<T, RadReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RadReport.
     * @param {RadReportCreateArgs} args - Arguments to create a RadReport.
     * @example
     * // Create one RadReport
     * const RadReport = await prisma.radReport.create({
     *   data: {
     *     // ... data to create a RadReport
     *   }
     * })
     * 
     */
    create<T extends RadReportCreateArgs>(args: SelectSubset<T, RadReportCreateArgs<ExtArgs>>): Prisma__RadReportClient<$Result.GetResult<Prisma.$RadReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RadReports.
     * @param {RadReportCreateManyArgs} args - Arguments to create many RadReports.
     * @example
     * // Create many RadReports
     * const radReport = await prisma.radReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RadReportCreateManyArgs>(args?: SelectSubset<T, RadReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RadReports and returns the data saved in the database.
     * @param {RadReportCreateManyAndReturnArgs} args - Arguments to create many RadReports.
     * @example
     * // Create many RadReports
     * const radReport = await prisma.radReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RadReports and only return the `id`
     * const radReportWithIdOnly = await prisma.radReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RadReportCreateManyAndReturnArgs>(args?: SelectSubset<T, RadReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RadReport.
     * @param {RadReportDeleteArgs} args - Arguments to delete one RadReport.
     * @example
     * // Delete one RadReport
     * const RadReport = await prisma.radReport.delete({
     *   where: {
     *     // ... filter to delete one RadReport
     *   }
     * })
     * 
     */
    delete<T extends RadReportDeleteArgs>(args: SelectSubset<T, RadReportDeleteArgs<ExtArgs>>): Prisma__RadReportClient<$Result.GetResult<Prisma.$RadReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RadReport.
     * @param {RadReportUpdateArgs} args - Arguments to update one RadReport.
     * @example
     * // Update one RadReport
     * const radReport = await prisma.radReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RadReportUpdateArgs>(args: SelectSubset<T, RadReportUpdateArgs<ExtArgs>>): Prisma__RadReportClient<$Result.GetResult<Prisma.$RadReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RadReports.
     * @param {RadReportDeleteManyArgs} args - Arguments to filter RadReports to delete.
     * @example
     * // Delete a few RadReports
     * const { count } = await prisma.radReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RadReportDeleteManyArgs>(args?: SelectSubset<T, RadReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RadReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RadReports
     * const radReport = await prisma.radReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RadReportUpdateManyArgs>(args: SelectSubset<T, RadReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RadReports and returns the data updated in the database.
     * @param {RadReportUpdateManyAndReturnArgs} args - Arguments to update many RadReports.
     * @example
     * // Update many RadReports
     * const radReport = await prisma.radReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RadReports and only return the `id`
     * const radReportWithIdOnly = await prisma.radReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RadReportUpdateManyAndReturnArgs>(args: SelectSubset<T, RadReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RadReport.
     * @param {RadReportUpsertArgs} args - Arguments to update or create a RadReport.
     * @example
     * // Update or create a RadReport
     * const radReport = await prisma.radReport.upsert({
     *   create: {
     *     // ... data to create a RadReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RadReport we want to update
     *   }
     * })
     */
    upsert<T extends RadReportUpsertArgs>(args: SelectSubset<T, RadReportUpsertArgs<ExtArgs>>): Prisma__RadReportClient<$Result.GetResult<Prisma.$RadReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RadReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadReportCountArgs} args - Arguments to filter RadReports to count.
     * @example
     * // Count the number of RadReports
     * const count = await prisma.radReport.count({
     *   where: {
     *     // ... the filter for the RadReports we want to count
     *   }
     * })
    **/
    count<T extends RadReportCountArgs>(
      args?: Subset<T, RadReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RadReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RadReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RadReportAggregateArgs>(args: Subset<T, RadReportAggregateArgs>): Prisma.PrismaPromise<GetRadReportAggregateType<T>>

    /**
     * Group by RadReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RadReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RadReportGroupByArgs['orderBy'] }
        : { orderBy?: RadReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RadReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRadReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RadReport model
   */
  readonly fields: RadReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RadReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RadReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    study<T extends StudyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudyDefaultArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reportTemplate<T extends RadReport$reportTemplateArgs<ExtArgs> = {}>(args?: Subset<T, RadReport$reportTemplateArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RadReport model
   */
  interface RadReportFieldRefs {
    readonly id: FieldRef<"RadReport", 'String'>
    readonly reportId: FieldRef<"RadReport", 'String'>
    readonly studyId: FieldRef<"RadReport", 'String'>
    readonly reportTemplateId: FieldRef<"RadReport", 'String'>
    readonly status: FieldRef<"RadReport", 'ReportStatus'>
    readonly findings: FieldRef<"RadReport", 'String'>
    readonly impression: FieldRef<"RadReport", 'String'>
    readonly conclusion: FieldRef<"RadReport", 'String'>
    readonly reportDateTime: FieldRef<"RadReport", 'DateTime'>
    readonly verifiedBy: FieldRef<"RadReport", 'String'>
    readonly verifiedAt: FieldRef<"RadReport", 'DateTime'>
    readonly isActive: FieldRef<"RadReport", 'Boolean'>
    readonly tenantId: FieldRef<"RadReport", 'String'>
    readonly createdAt: FieldRef<"RadReport", 'DateTime'>
    readonly updatedAt: FieldRef<"RadReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RadReport findUnique
   */
  export type RadReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadReport
     */
    select?: RadReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadReport
     */
    omit?: RadReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadReportInclude<ExtArgs> | null
    /**
     * Filter, which RadReport to fetch.
     */
    where: RadReportWhereUniqueInput
  }

  /**
   * RadReport findUniqueOrThrow
   */
  export type RadReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadReport
     */
    select?: RadReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadReport
     */
    omit?: RadReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadReportInclude<ExtArgs> | null
    /**
     * Filter, which RadReport to fetch.
     */
    where: RadReportWhereUniqueInput
  }

  /**
   * RadReport findFirst
   */
  export type RadReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadReport
     */
    select?: RadReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadReport
     */
    omit?: RadReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadReportInclude<ExtArgs> | null
    /**
     * Filter, which RadReport to fetch.
     */
    where?: RadReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RadReports to fetch.
     */
    orderBy?: RadReportOrderByWithRelationInput | RadReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RadReports.
     */
    cursor?: RadReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RadReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RadReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RadReports.
     */
    distinct?: RadReportScalarFieldEnum | RadReportScalarFieldEnum[]
  }

  /**
   * RadReport findFirstOrThrow
   */
  export type RadReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadReport
     */
    select?: RadReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadReport
     */
    omit?: RadReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadReportInclude<ExtArgs> | null
    /**
     * Filter, which RadReport to fetch.
     */
    where?: RadReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RadReports to fetch.
     */
    orderBy?: RadReportOrderByWithRelationInput | RadReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RadReports.
     */
    cursor?: RadReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RadReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RadReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RadReports.
     */
    distinct?: RadReportScalarFieldEnum | RadReportScalarFieldEnum[]
  }

  /**
   * RadReport findMany
   */
  export type RadReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadReport
     */
    select?: RadReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadReport
     */
    omit?: RadReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadReportInclude<ExtArgs> | null
    /**
     * Filter, which RadReports to fetch.
     */
    where?: RadReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RadReports to fetch.
     */
    orderBy?: RadReportOrderByWithRelationInput | RadReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RadReports.
     */
    cursor?: RadReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RadReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RadReports.
     */
    skip?: number
    distinct?: RadReportScalarFieldEnum | RadReportScalarFieldEnum[]
  }

  /**
   * RadReport create
   */
  export type RadReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadReport
     */
    select?: RadReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadReport
     */
    omit?: RadReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadReportInclude<ExtArgs> | null
    /**
     * The data needed to create a RadReport.
     */
    data: XOR<RadReportCreateInput, RadReportUncheckedCreateInput>
  }

  /**
   * RadReport createMany
   */
  export type RadReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RadReports.
     */
    data: RadReportCreateManyInput | RadReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RadReport createManyAndReturn
   */
  export type RadReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadReport
     */
    select?: RadReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RadReport
     */
    omit?: RadReportOmit<ExtArgs> | null
    /**
     * The data used to create many RadReports.
     */
    data: RadReportCreateManyInput | RadReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RadReport update
   */
  export type RadReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadReport
     */
    select?: RadReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadReport
     */
    omit?: RadReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadReportInclude<ExtArgs> | null
    /**
     * The data needed to update a RadReport.
     */
    data: XOR<RadReportUpdateInput, RadReportUncheckedUpdateInput>
    /**
     * Choose, which RadReport to update.
     */
    where: RadReportWhereUniqueInput
  }

  /**
   * RadReport updateMany
   */
  export type RadReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RadReports.
     */
    data: XOR<RadReportUpdateManyMutationInput, RadReportUncheckedUpdateManyInput>
    /**
     * Filter which RadReports to update
     */
    where?: RadReportWhereInput
    /**
     * Limit how many RadReports to update.
     */
    limit?: number
  }

  /**
   * RadReport updateManyAndReturn
   */
  export type RadReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadReport
     */
    select?: RadReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RadReport
     */
    omit?: RadReportOmit<ExtArgs> | null
    /**
     * The data used to update RadReports.
     */
    data: XOR<RadReportUpdateManyMutationInput, RadReportUncheckedUpdateManyInput>
    /**
     * Filter which RadReports to update
     */
    where?: RadReportWhereInput
    /**
     * Limit how many RadReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RadReport upsert
   */
  export type RadReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadReport
     */
    select?: RadReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadReport
     */
    omit?: RadReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadReportInclude<ExtArgs> | null
    /**
     * The filter to search for the RadReport to update in case it exists.
     */
    where: RadReportWhereUniqueInput
    /**
     * In case the RadReport found by the `where` argument doesn't exist, create a new RadReport with this data.
     */
    create: XOR<RadReportCreateInput, RadReportUncheckedCreateInput>
    /**
     * In case the RadReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RadReportUpdateInput, RadReportUncheckedUpdateInput>
  }

  /**
   * RadReport delete
   */
  export type RadReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadReport
     */
    select?: RadReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadReport
     */
    omit?: RadReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadReportInclude<ExtArgs> | null
    /**
     * Filter which RadReport to delete.
     */
    where: RadReportWhereUniqueInput
  }

  /**
   * RadReport deleteMany
   */
  export type RadReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RadReports to delete
     */
    where?: RadReportWhereInput
    /**
     * Limit how many RadReports to delete.
     */
    limit?: number
  }

  /**
   * RadReport.reportTemplate
   */
  export type RadReport$reportTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    where?: ReportTemplateWhereInput
  }

  /**
   * RadReport without action
   */
  export type RadReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadReport
     */
    select?: RadReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadReport
     */
    omit?: RadReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadReportInclude<ExtArgs> | null
  }


  /**
   * Model RadiationDose
   */

  export type AggregateRadiationDose = {
    _count: RadiationDoseCountAggregateOutputType | null
    _avg: RadiationDoseAvgAggregateOutputType | null
    _sum: RadiationDoseSumAggregateOutputType | null
    _min: RadiationDoseMinAggregateOutputType | null
    _max: RadiationDoseMaxAggregateOutputType | null
  }

  export type RadiationDoseAvgAggregateOutputType = {
    exposureTime: number | null
    kvp: number | null
    ma: number | null
    doseAreaProduct: number | null
    doseLengthProduct: number | null
    ctdiVol: number | null
    dlp: number | null
    effectiveDose: number | null
  }

  export type RadiationDoseSumAggregateOutputType = {
    exposureTime: number | null
    kvp: number | null
    ma: number | null
    doseAreaProduct: number | null
    doseLengthProduct: number | null
    ctdiVol: number | null
    dlp: number | null
    effectiveDose: number | null
  }

  export type RadiationDoseMinAggregateOutputType = {
    id: string | null
    studyId: string | null
    deviceName: string | null
    deviceType: string | null
    exposureTime: number | null
    kvp: number | null
    ma: number | null
    doseAreaProduct: number | null
    doseLengthProduct: number | null
    ctdiVol: number | null
    dlp: number | null
    effectiveDose: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RadiationDoseMaxAggregateOutputType = {
    id: string | null
    studyId: string | null
    deviceName: string | null
    deviceType: string | null
    exposureTime: number | null
    kvp: number | null
    ma: number | null
    doseAreaProduct: number | null
    doseLengthProduct: number | null
    ctdiVol: number | null
    dlp: number | null
    effectiveDose: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RadiationDoseCountAggregateOutputType = {
    id: number
    studyId: number
    deviceName: number
    deviceType: number
    exposureTime: number
    kvp: number
    ma: number
    doseAreaProduct: number
    doseLengthProduct: number
    ctdiVol: number
    dlp: number
    effectiveDose: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RadiationDoseAvgAggregateInputType = {
    exposureTime?: true
    kvp?: true
    ma?: true
    doseAreaProduct?: true
    doseLengthProduct?: true
    ctdiVol?: true
    dlp?: true
    effectiveDose?: true
  }

  export type RadiationDoseSumAggregateInputType = {
    exposureTime?: true
    kvp?: true
    ma?: true
    doseAreaProduct?: true
    doseLengthProduct?: true
    ctdiVol?: true
    dlp?: true
    effectiveDose?: true
  }

  export type RadiationDoseMinAggregateInputType = {
    id?: true
    studyId?: true
    deviceName?: true
    deviceType?: true
    exposureTime?: true
    kvp?: true
    ma?: true
    doseAreaProduct?: true
    doseLengthProduct?: true
    ctdiVol?: true
    dlp?: true
    effectiveDose?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RadiationDoseMaxAggregateInputType = {
    id?: true
    studyId?: true
    deviceName?: true
    deviceType?: true
    exposureTime?: true
    kvp?: true
    ma?: true
    doseAreaProduct?: true
    doseLengthProduct?: true
    ctdiVol?: true
    dlp?: true
    effectiveDose?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RadiationDoseCountAggregateInputType = {
    id?: true
    studyId?: true
    deviceName?: true
    deviceType?: true
    exposureTime?: true
    kvp?: true
    ma?: true
    doseAreaProduct?: true
    doseLengthProduct?: true
    ctdiVol?: true
    dlp?: true
    effectiveDose?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RadiationDoseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RadiationDose to aggregate.
     */
    where?: RadiationDoseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RadiationDoses to fetch.
     */
    orderBy?: RadiationDoseOrderByWithRelationInput | RadiationDoseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RadiationDoseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RadiationDoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RadiationDoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RadiationDoses
    **/
    _count?: true | RadiationDoseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RadiationDoseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RadiationDoseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RadiationDoseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RadiationDoseMaxAggregateInputType
  }

  export type GetRadiationDoseAggregateType<T extends RadiationDoseAggregateArgs> = {
        [P in keyof T & keyof AggregateRadiationDose]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRadiationDose[P]>
      : GetScalarType<T[P], AggregateRadiationDose[P]>
  }




  export type RadiationDoseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadiationDoseWhereInput
    orderBy?: RadiationDoseOrderByWithAggregationInput | RadiationDoseOrderByWithAggregationInput[]
    by: RadiationDoseScalarFieldEnum[] | RadiationDoseScalarFieldEnum
    having?: RadiationDoseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RadiationDoseCountAggregateInputType | true
    _avg?: RadiationDoseAvgAggregateInputType
    _sum?: RadiationDoseSumAggregateInputType
    _min?: RadiationDoseMinAggregateInputType
    _max?: RadiationDoseMaxAggregateInputType
  }

  export type RadiationDoseGroupByOutputType = {
    id: string
    studyId: string
    deviceName: string | null
    deviceType: string | null
    exposureTime: number | null
    kvp: number | null
    ma: number | null
    doseAreaProduct: number | null
    doseLengthProduct: number | null
    ctdiVol: number | null
    dlp: number | null
    effectiveDose: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: RadiationDoseCountAggregateOutputType | null
    _avg: RadiationDoseAvgAggregateOutputType | null
    _sum: RadiationDoseSumAggregateOutputType | null
    _min: RadiationDoseMinAggregateOutputType | null
    _max: RadiationDoseMaxAggregateOutputType | null
  }

  type GetRadiationDoseGroupByPayload<T extends RadiationDoseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RadiationDoseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RadiationDoseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RadiationDoseGroupByOutputType[P]>
            : GetScalarType<T[P], RadiationDoseGroupByOutputType[P]>
        }
      >
    >


  export type RadiationDoseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studyId?: boolean
    deviceName?: boolean
    deviceType?: boolean
    exposureTime?: boolean
    kvp?: boolean
    ma?: boolean
    doseAreaProduct?: boolean
    doseLengthProduct?: boolean
    ctdiVol?: boolean
    dlp?: boolean
    effectiveDose?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    study?: boolean | StudyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["radiationDose"]>

  export type RadiationDoseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studyId?: boolean
    deviceName?: boolean
    deviceType?: boolean
    exposureTime?: boolean
    kvp?: boolean
    ma?: boolean
    doseAreaProduct?: boolean
    doseLengthProduct?: boolean
    ctdiVol?: boolean
    dlp?: boolean
    effectiveDose?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    study?: boolean | StudyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["radiationDose"]>

  export type RadiationDoseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studyId?: boolean
    deviceName?: boolean
    deviceType?: boolean
    exposureTime?: boolean
    kvp?: boolean
    ma?: boolean
    doseAreaProduct?: boolean
    doseLengthProduct?: boolean
    ctdiVol?: boolean
    dlp?: boolean
    effectiveDose?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    study?: boolean | StudyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["radiationDose"]>

  export type RadiationDoseSelectScalar = {
    id?: boolean
    studyId?: boolean
    deviceName?: boolean
    deviceType?: boolean
    exposureTime?: boolean
    kvp?: boolean
    ma?: boolean
    doseAreaProduct?: boolean
    doseLengthProduct?: boolean
    ctdiVol?: boolean
    dlp?: boolean
    effectiveDose?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RadiationDoseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studyId" | "deviceName" | "deviceType" | "exposureTime" | "kvp" | "ma" | "doseAreaProduct" | "doseLengthProduct" | "ctdiVol" | "dlp" | "effectiveDose" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["radiationDose"]>
  export type RadiationDoseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    study?: boolean | StudyDefaultArgs<ExtArgs>
  }
  export type RadiationDoseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    study?: boolean | StudyDefaultArgs<ExtArgs>
  }
  export type RadiationDoseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    study?: boolean | StudyDefaultArgs<ExtArgs>
  }

  export type $RadiationDosePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RadiationDose"
    objects: {
      study: Prisma.$StudyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studyId: string
      deviceName: string | null
      deviceType: string | null
      exposureTime: number | null
      kvp: number | null
      ma: number | null
      doseAreaProduct: number | null
      doseLengthProduct: number | null
      ctdiVol: number | null
      dlp: number | null
      effectiveDose: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["radiationDose"]>
    composites: {}
  }

  type RadiationDoseGetPayload<S extends boolean | null | undefined | RadiationDoseDefaultArgs> = $Result.GetResult<Prisma.$RadiationDosePayload, S>

  type RadiationDoseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RadiationDoseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RadiationDoseCountAggregateInputType | true
    }

  export interface RadiationDoseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RadiationDose'], meta: { name: 'RadiationDose' } }
    /**
     * Find zero or one RadiationDose that matches the filter.
     * @param {RadiationDoseFindUniqueArgs} args - Arguments to find a RadiationDose
     * @example
     * // Get one RadiationDose
     * const radiationDose = await prisma.radiationDose.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RadiationDoseFindUniqueArgs>(args: SelectSubset<T, RadiationDoseFindUniqueArgs<ExtArgs>>): Prisma__RadiationDoseClient<$Result.GetResult<Prisma.$RadiationDosePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RadiationDose that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RadiationDoseFindUniqueOrThrowArgs} args - Arguments to find a RadiationDose
     * @example
     * // Get one RadiationDose
     * const radiationDose = await prisma.radiationDose.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RadiationDoseFindUniqueOrThrowArgs>(args: SelectSubset<T, RadiationDoseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RadiationDoseClient<$Result.GetResult<Prisma.$RadiationDosePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RadiationDose that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiationDoseFindFirstArgs} args - Arguments to find a RadiationDose
     * @example
     * // Get one RadiationDose
     * const radiationDose = await prisma.radiationDose.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RadiationDoseFindFirstArgs>(args?: SelectSubset<T, RadiationDoseFindFirstArgs<ExtArgs>>): Prisma__RadiationDoseClient<$Result.GetResult<Prisma.$RadiationDosePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RadiationDose that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiationDoseFindFirstOrThrowArgs} args - Arguments to find a RadiationDose
     * @example
     * // Get one RadiationDose
     * const radiationDose = await prisma.radiationDose.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RadiationDoseFindFirstOrThrowArgs>(args?: SelectSubset<T, RadiationDoseFindFirstOrThrowArgs<ExtArgs>>): Prisma__RadiationDoseClient<$Result.GetResult<Prisma.$RadiationDosePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RadiationDoses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiationDoseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RadiationDoses
     * const radiationDoses = await prisma.radiationDose.findMany()
     * 
     * // Get first 10 RadiationDoses
     * const radiationDoses = await prisma.radiationDose.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const radiationDoseWithIdOnly = await prisma.radiationDose.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RadiationDoseFindManyArgs>(args?: SelectSubset<T, RadiationDoseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiationDosePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RadiationDose.
     * @param {RadiationDoseCreateArgs} args - Arguments to create a RadiationDose.
     * @example
     * // Create one RadiationDose
     * const RadiationDose = await prisma.radiationDose.create({
     *   data: {
     *     // ... data to create a RadiationDose
     *   }
     * })
     * 
     */
    create<T extends RadiationDoseCreateArgs>(args: SelectSubset<T, RadiationDoseCreateArgs<ExtArgs>>): Prisma__RadiationDoseClient<$Result.GetResult<Prisma.$RadiationDosePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RadiationDoses.
     * @param {RadiationDoseCreateManyArgs} args - Arguments to create many RadiationDoses.
     * @example
     * // Create many RadiationDoses
     * const radiationDose = await prisma.radiationDose.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RadiationDoseCreateManyArgs>(args?: SelectSubset<T, RadiationDoseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RadiationDoses and returns the data saved in the database.
     * @param {RadiationDoseCreateManyAndReturnArgs} args - Arguments to create many RadiationDoses.
     * @example
     * // Create many RadiationDoses
     * const radiationDose = await prisma.radiationDose.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RadiationDoses and only return the `id`
     * const radiationDoseWithIdOnly = await prisma.radiationDose.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RadiationDoseCreateManyAndReturnArgs>(args?: SelectSubset<T, RadiationDoseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiationDosePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RadiationDose.
     * @param {RadiationDoseDeleteArgs} args - Arguments to delete one RadiationDose.
     * @example
     * // Delete one RadiationDose
     * const RadiationDose = await prisma.radiationDose.delete({
     *   where: {
     *     // ... filter to delete one RadiationDose
     *   }
     * })
     * 
     */
    delete<T extends RadiationDoseDeleteArgs>(args: SelectSubset<T, RadiationDoseDeleteArgs<ExtArgs>>): Prisma__RadiationDoseClient<$Result.GetResult<Prisma.$RadiationDosePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RadiationDose.
     * @param {RadiationDoseUpdateArgs} args - Arguments to update one RadiationDose.
     * @example
     * // Update one RadiationDose
     * const radiationDose = await prisma.radiationDose.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RadiationDoseUpdateArgs>(args: SelectSubset<T, RadiationDoseUpdateArgs<ExtArgs>>): Prisma__RadiationDoseClient<$Result.GetResult<Prisma.$RadiationDosePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RadiationDoses.
     * @param {RadiationDoseDeleteManyArgs} args - Arguments to filter RadiationDoses to delete.
     * @example
     * // Delete a few RadiationDoses
     * const { count } = await prisma.radiationDose.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RadiationDoseDeleteManyArgs>(args?: SelectSubset<T, RadiationDoseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RadiationDoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiationDoseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RadiationDoses
     * const radiationDose = await prisma.radiationDose.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RadiationDoseUpdateManyArgs>(args: SelectSubset<T, RadiationDoseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RadiationDoses and returns the data updated in the database.
     * @param {RadiationDoseUpdateManyAndReturnArgs} args - Arguments to update many RadiationDoses.
     * @example
     * // Update many RadiationDoses
     * const radiationDose = await prisma.radiationDose.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RadiationDoses and only return the `id`
     * const radiationDoseWithIdOnly = await prisma.radiationDose.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RadiationDoseUpdateManyAndReturnArgs>(args: SelectSubset<T, RadiationDoseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiationDosePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RadiationDose.
     * @param {RadiationDoseUpsertArgs} args - Arguments to update or create a RadiationDose.
     * @example
     * // Update or create a RadiationDose
     * const radiationDose = await prisma.radiationDose.upsert({
     *   create: {
     *     // ... data to create a RadiationDose
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RadiationDose we want to update
     *   }
     * })
     */
    upsert<T extends RadiationDoseUpsertArgs>(args: SelectSubset<T, RadiationDoseUpsertArgs<ExtArgs>>): Prisma__RadiationDoseClient<$Result.GetResult<Prisma.$RadiationDosePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RadiationDoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiationDoseCountArgs} args - Arguments to filter RadiationDoses to count.
     * @example
     * // Count the number of RadiationDoses
     * const count = await prisma.radiationDose.count({
     *   where: {
     *     // ... the filter for the RadiationDoses we want to count
     *   }
     * })
    **/
    count<T extends RadiationDoseCountArgs>(
      args?: Subset<T, RadiationDoseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RadiationDoseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RadiationDose.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiationDoseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RadiationDoseAggregateArgs>(args: Subset<T, RadiationDoseAggregateArgs>): Prisma.PrismaPromise<GetRadiationDoseAggregateType<T>>

    /**
     * Group by RadiationDose.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiationDoseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RadiationDoseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RadiationDoseGroupByArgs['orderBy'] }
        : { orderBy?: RadiationDoseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RadiationDoseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRadiationDoseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RadiationDose model
   */
  readonly fields: RadiationDoseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RadiationDose.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RadiationDoseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    study<T extends StudyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudyDefaultArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RadiationDose model
   */
  interface RadiationDoseFieldRefs {
    readonly id: FieldRef<"RadiationDose", 'String'>
    readonly studyId: FieldRef<"RadiationDose", 'String'>
    readonly deviceName: FieldRef<"RadiationDose", 'String'>
    readonly deviceType: FieldRef<"RadiationDose", 'String'>
    readonly exposureTime: FieldRef<"RadiationDose", 'Float'>
    readonly kvp: FieldRef<"RadiationDose", 'Float'>
    readonly ma: FieldRef<"RadiationDose", 'Float'>
    readonly doseAreaProduct: FieldRef<"RadiationDose", 'Float'>
    readonly doseLengthProduct: FieldRef<"RadiationDose", 'Float'>
    readonly ctdiVol: FieldRef<"RadiationDose", 'Float'>
    readonly dlp: FieldRef<"RadiationDose", 'Float'>
    readonly effectiveDose: FieldRef<"RadiationDose", 'Float'>
    readonly isActive: FieldRef<"RadiationDose", 'Boolean'>
    readonly createdAt: FieldRef<"RadiationDose", 'DateTime'>
    readonly updatedAt: FieldRef<"RadiationDose", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RadiationDose findUnique
   */
  export type RadiationDoseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationDose
     */
    select?: RadiationDoseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationDose
     */
    omit?: RadiationDoseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationDoseInclude<ExtArgs> | null
    /**
     * Filter, which RadiationDose to fetch.
     */
    where: RadiationDoseWhereUniqueInput
  }

  /**
   * RadiationDose findUniqueOrThrow
   */
  export type RadiationDoseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationDose
     */
    select?: RadiationDoseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationDose
     */
    omit?: RadiationDoseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationDoseInclude<ExtArgs> | null
    /**
     * Filter, which RadiationDose to fetch.
     */
    where: RadiationDoseWhereUniqueInput
  }

  /**
   * RadiationDose findFirst
   */
  export type RadiationDoseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationDose
     */
    select?: RadiationDoseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationDose
     */
    omit?: RadiationDoseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationDoseInclude<ExtArgs> | null
    /**
     * Filter, which RadiationDose to fetch.
     */
    where?: RadiationDoseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RadiationDoses to fetch.
     */
    orderBy?: RadiationDoseOrderByWithRelationInput | RadiationDoseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RadiationDoses.
     */
    cursor?: RadiationDoseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RadiationDoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RadiationDoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RadiationDoses.
     */
    distinct?: RadiationDoseScalarFieldEnum | RadiationDoseScalarFieldEnum[]
  }

  /**
   * RadiationDose findFirstOrThrow
   */
  export type RadiationDoseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationDose
     */
    select?: RadiationDoseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationDose
     */
    omit?: RadiationDoseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationDoseInclude<ExtArgs> | null
    /**
     * Filter, which RadiationDose to fetch.
     */
    where?: RadiationDoseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RadiationDoses to fetch.
     */
    orderBy?: RadiationDoseOrderByWithRelationInput | RadiationDoseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RadiationDoses.
     */
    cursor?: RadiationDoseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RadiationDoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RadiationDoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RadiationDoses.
     */
    distinct?: RadiationDoseScalarFieldEnum | RadiationDoseScalarFieldEnum[]
  }

  /**
   * RadiationDose findMany
   */
  export type RadiationDoseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationDose
     */
    select?: RadiationDoseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationDose
     */
    omit?: RadiationDoseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationDoseInclude<ExtArgs> | null
    /**
     * Filter, which RadiationDoses to fetch.
     */
    where?: RadiationDoseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RadiationDoses to fetch.
     */
    orderBy?: RadiationDoseOrderByWithRelationInput | RadiationDoseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RadiationDoses.
     */
    cursor?: RadiationDoseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RadiationDoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RadiationDoses.
     */
    skip?: number
    distinct?: RadiationDoseScalarFieldEnum | RadiationDoseScalarFieldEnum[]
  }

  /**
   * RadiationDose create
   */
  export type RadiationDoseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationDose
     */
    select?: RadiationDoseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationDose
     */
    omit?: RadiationDoseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationDoseInclude<ExtArgs> | null
    /**
     * The data needed to create a RadiationDose.
     */
    data: XOR<RadiationDoseCreateInput, RadiationDoseUncheckedCreateInput>
  }

  /**
   * RadiationDose createMany
   */
  export type RadiationDoseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RadiationDoses.
     */
    data: RadiationDoseCreateManyInput | RadiationDoseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RadiationDose createManyAndReturn
   */
  export type RadiationDoseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationDose
     */
    select?: RadiationDoseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationDose
     */
    omit?: RadiationDoseOmit<ExtArgs> | null
    /**
     * The data used to create many RadiationDoses.
     */
    data: RadiationDoseCreateManyInput | RadiationDoseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationDoseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RadiationDose update
   */
  export type RadiationDoseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationDose
     */
    select?: RadiationDoseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationDose
     */
    omit?: RadiationDoseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationDoseInclude<ExtArgs> | null
    /**
     * The data needed to update a RadiationDose.
     */
    data: XOR<RadiationDoseUpdateInput, RadiationDoseUncheckedUpdateInput>
    /**
     * Choose, which RadiationDose to update.
     */
    where: RadiationDoseWhereUniqueInput
  }

  /**
   * RadiationDose updateMany
   */
  export type RadiationDoseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RadiationDoses.
     */
    data: XOR<RadiationDoseUpdateManyMutationInput, RadiationDoseUncheckedUpdateManyInput>
    /**
     * Filter which RadiationDoses to update
     */
    where?: RadiationDoseWhereInput
    /**
     * Limit how many RadiationDoses to update.
     */
    limit?: number
  }

  /**
   * RadiationDose updateManyAndReturn
   */
  export type RadiationDoseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationDose
     */
    select?: RadiationDoseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationDose
     */
    omit?: RadiationDoseOmit<ExtArgs> | null
    /**
     * The data used to update RadiationDoses.
     */
    data: XOR<RadiationDoseUpdateManyMutationInput, RadiationDoseUncheckedUpdateManyInput>
    /**
     * Filter which RadiationDoses to update
     */
    where?: RadiationDoseWhereInput
    /**
     * Limit how many RadiationDoses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationDoseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RadiationDose upsert
   */
  export type RadiationDoseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationDose
     */
    select?: RadiationDoseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationDose
     */
    omit?: RadiationDoseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationDoseInclude<ExtArgs> | null
    /**
     * The filter to search for the RadiationDose to update in case it exists.
     */
    where: RadiationDoseWhereUniqueInput
    /**
     * In case the RadiationDose found by the `where` argument doesn't exist, create a new RadiationDose with this data.
     */
    create: XOR<RadiationDoseCreateInput, RadiationDoseUncheckedCreateInput>
    /**
     * In case the RadiationDose was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RadiationDoseUpdateInput, RadiationDoseUncheckedUpdateInput>
  }

  /**
   * RadiationDose delete
   */
  export type RadiationDoseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationDose
     */
    select?: RadiationDoseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationDose
     */
    omit?: RadiationDoseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationDoseInclude<ExtArgs> | null
    /**
     * Filter which RadiationDose to delete.
     */
    where: RadiationDoseWhereUniqueInput
  }

  /**
   * RadiationDose deleteMany
   */
  export type RadiationDoseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RadiationDoses to delete
     */
    where?: RadiationDoseWhereInput
    /**
     * Limit how many RadiationDoses to delete.
     */
    limit?: number
  }

  /**
   * RadiationDose without action
   */
  export type RadiationDoseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiationDose
     */
    select?: RadiationDoseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiationDose
     */
    omit?: RadiationDoseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiationDoseInclude<ExtArgs> | null
  }


  /**
   * Model ReportTemplate
   */

  export type AggregateReportTemplate = {
    _count: ReportTemplateCountAggregateOutputType | null
    _min: ReportTemplateMinAggregateOutputType | null
    _max: ReportTemplateMaxAggregateOutputType | null
  }

  export type ReportTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    template: string | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    template: string | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    template: number
    isActive: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    template?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    template?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    template?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportTemplate to aggregate.
     */
    where?: ReportTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTemplates to fetch.
     */
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportTemplates
    **/
    _count?: true | ReportTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportTemplateMaxAggregateInputType
  }

  export type GetReportTemplateAggregateType<T extends ReportTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateReportTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportTemplate[P]>
      : GetScalarType<T[P], AggregateReportTemplate[P]>
  }




  export type ReportTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportTemplateWhereInput
    orderBy?: ReportTemplateOrderByWithAggregationInput | ReportTemplateOrderByWithAggregationInput[]
    by: ReportTemplateScalarFieldEnum[] | ReportTemplateScalarFieldEnum
    having?: ReportTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportTemplateCountAggregateInputType | true
    _min?: ReportTemplateMinAggregateInputType
    _max?: ReportTemplateMaxAggregateInputType
  }

  export type ReportTemplateGroupByOutputType = {
    id: string
    name: string
    description: string | null
    template: string
    isActive: boolean
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: ReportTemplateCountAggregateOutputType | null
    _min: ReportTemplateMinAggregateOutputType | null
    _max: ReportTemplateMaxAggregateOutputType | null
  }

  type GetReportTemplateGroupByPayload<T extends ReportTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ReportTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ReportTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    template?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    radReports?: boolean | ReportTemplate$radReportsArgs<ExtArgs>
    _count?: boolean | ReportTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportTemplate"]>

  export type ReportTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    template?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportTemplate"]>

  export type ReportTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    template?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportTemplate"]>

  export type ReportTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    template?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReportTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "template" | "isActive" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["reportTemplate"]>
  export type ReportTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    radReports?: boolean | ReportTemplate$radReportsArgs<ExtArgs>
    _count?: boolean | ReportTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReportTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ReportTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ReportTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportTemplate"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      radReports: Prisma.$RadReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      template: string
      isActive: boolean
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reportTemplate"]>
    composites: {}
  }

  type ReportTemplateGetPayload<S extends boolean | null | undefined | ReportTemplateDefaultArgs> = $Result.GetResult<Prisma.$ReportTemplatePayload, S>

  type ReportTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportTemplateCountAggregateInputType | true
    }

  export interface ReportTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportTemplate'], meta: { name: 'ReportTemplate' } }
    /**
     * Find zero or one ReportTemplate that matches the filter.
     * @param {ReportTemplateFindUniqueArgs} args - Arguments to find a ReportTemplate
     * @example
     * // Get one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportTemplateFindUniqueArgs>(args: SelectSubset<T, ReportTemplateFindUniqueArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReportTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportTemplateFindUniqueOrThrowArgs} args - Arguments to find a ReportTemplate
     * @example
     * // Get one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateFindFirstArgs} args - Arguments to find a ReportTemplate
     * @example
     * // Get one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportTemplateFindFirstArgs>(args?: SelectSubset<T, ReportTemplateFindFirstArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateFindFirstOrThrowArgs} args - Arguments to find a ReportTemplate
     * @example
     * // Get one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReportTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportTemplates
     * const reportTemplates = await prisma.reportTemplate.findMany()
     * 
     * // Get first 10 ReportTemplates
     * const reportTemplates = await prisma.reportTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportTemplateWithIdOnly = await prisma.reportTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportTemplateFindManyArgs>(args?: SelectSubset<T, ReportTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReportTemplate.
     * @param {ReportTemplateCreateArgs} args - Arguments to create a ReportTemplate.
     * @example
     * // Create one ReportTemplate
     * const ReportTemplate = await prisma.reportTemplate.create({
     *   data: {
     *     // ... data to create a ReportTemplate
     *   }
     * })
     * 
     */
    create<T extends ReportTemplateCreateArgs>(args: SelectSubset<T, ReportTemplateCreateArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReportTemplates.
     * @param {ReportTemplateCreateManyArgs} args - Arguments to create many ReportTemplates.
     * @example
     * // Create many ReportTemplates
     * const reportTemplate = await prisma.reportTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportTemplateCreateManyArgs>(args?: SelectSubset<T, ReportTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportTemplates and returns the data saved in the database.
     * @param {ReportTemplateCreateManyAndReturnArgs} args - Arguments to create many ReportTemplates.
     * @example
     * // Create many ReportTemplates
     * const reportTemplate = await prisma.reportTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportTemplates and only return the `id`
     * const reportTemplateWithIdOnly = await prisma.reportTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReportTemplate.
     * @param {ReportTemplateDeleteArgs} args - Arguments to delete one ReportTemplate.
     * @example
     * // Delete one ReportTemplate
     * const ReportTemplate = await prisma.reportTemplate.delete({
     *   where: {
     *     // ... filter to delete one ReportTemplate
     *   }
     * })
     * 
     */
    delete<T extends ReportTemplateDeleteArgs>(args: SelectSubset<T, ReportTemplateDeleteArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReportTemplate.
     * @param {ReportTemplateUpdateArgs} args - Arguments to update one ReportTemplate.
     * @example
     * // Update one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportTemplateUpdateArgs>(args: SelectSubset<T, ReportTemplateUpdateArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReportTemplates.
     * @param {ReportTemplateDeleteManyArgs} args - Arguments to filter ReportTemplates to delete.
     * @example
     * // Delete a few ReportTemplates
     * const { count } = await prisma.reportTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportTemplateDeleteManyArgs>(args?: SelectSubset<T, ReportTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportTemplates
     * const reportTemplate = await prisma.reportTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportTemplateUpdateManyArgs>(args: SelectSubset<T, ReportTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportTemplates and returns the data updated in the database.
     * @param {ReportTemplateUpdateManyAndReturnArgs} args - Arguments to update many ReportTemplates.
     * @example
     * // Update many ReportTemplates
     * const reportTemplate = await prisma.reportTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReportTemplates and only return the `id`
     * const reportTemplateWithIdOnly = await prisma.reportTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReportTemplate.
     * @param {ReportTemplateUpsertArgs} args - Arguments to update or create a ReportTemplate.
     * @example
     * // Update or create a ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.upsert({
     *   create: {
     *     // ... data to create a ReportTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportTemplate we want to update
     *   }
     * })
     */
    upsert<T extends ReportTemplateUpsertArgs>(args: SelectSubset<T, ReportTemplateUpsertArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReportTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateCountArgs} args - Arguments to filter ReportTemplates to count.
     * @example
     * // Count the number of ReportTemplates
     * const count = await prisma.reportTemplate.count({
     *   where: {
     *     // ... the filter for the ReportTemplates we want to count
     *   }
     * })
    **/
    count<T extends ReportTemplateCountArgs>(
      args?: Subset<T, ReportTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportTemplateAggregateArgs>(args: Subset<T, ReportTemplateAggregateArgs>): Prisma.PrismaPromise<GetReportTemplateAggregateType<T>>

    /**
     * Group by ReportTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ReportTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportTemplate model
   */
  readonly fields: ReportTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    radReports<T extends ReportTemplate$radReportsArgs<ExtArgs> = {}>(args?: Subset<T, ReportTemplate$radReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportTemplate model
   */
  interface ReportTemplateFieldRefs {
    readonly id: FieldRef<"ReportTemplate", 'String'>
    readonly name: FieldRef<"ReportTemplate", 'String'>
    readonly description: FieldRef<"ReportTemplate", 'String'>
    readonly template: FieldRef<"ReportTemplate", 'String'>
    readonly isActive: FieldRef<"ReportTemplate", 'Boolean'>
    readonly tenantId: FieldRef<"ReportTemplate", 'String'>
    readonly createdAt: FieldRef<"ReportTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"ReportTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportTemplate findUnique
   */
  export type ReportTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplate to fetch.
     */
    where: ReportTemplateWhereUniqueInput
  }

  /**
   * ReportTemplate findUniqueOrThrow
   */
  export type ReportTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplate to fetch.
     */
    where: ReportTemplateWhereUniqueInput
  }

  /**
   * ReportTemplate findFirst
   */
  export type ReportTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplate to fetch.
     */
    where?: ReportTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTemplates to fetch.
     */
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportTemplates.
     */
    cursor?: ReportTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportTemplates.
     */
    distinct?: ReportTemplateScalarFieldEnum | ReportTemplateScalarFieldEnum[]
  }

  /**
   * ReportTemplate findFirstOrThrow
   */
  export type ReportTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplate to fetch.
     */
    where?: ReportTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTemplates to fetch.
     */
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportTemplates.
     */
    cursor?: ReportTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportTemplates.
     */
    distinct?: ReportTemplateScalarFieldEnum | ReportTemplateScalarFieldEnum[]
  }

  /**
   * ReportTemplate findMany
   */
  export type ReportTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplates to fetch.
     */
    where?: ReportTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTemplates to fetch.
     */
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportTemplates.
     */
    cursor?: ReportTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTemplates.
     */
    skip?: number
    distinct?: ReportTemplateScalarFieldEnum | ReportTemplateScalarFieldEnum[]
  }

  /**
   * ReportTemplate create
   */
  export type ReportTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportTemplate.
     */
    data: XOR<ReportTemplateCreateInput, ReportTemplateUncheckedCreateInput>
  }

  /**
   * ReportTemplate createMany
   */
  export type ReportTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportTemplates.
     */
    data: ReportTemplateCreateManyInput | ReportTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportTemplate createManyAndReturn
   */
  export type ReportTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many ReportTemplates.
     */
    data: ReportTemplateCreateManyInput | ReportTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportTemplate update
   */
  export type ReportTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportTemplate.
     */
    data: XOR<ReportTemplateUpdateInput, ReportTemplateUncheckedUpdateInput>
    /**
     * Choose, which ReportTemplate to update.
     */
    where: ReportTemplateWhereUniqueInput
  }

  /**
   * ReportTemplate updateMany
   */
  export type ReportTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportTemplates.
     */
    data: XOR<ReportTemplateUpdateManyMutationInput, ReportTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ReportTemplates to update
     */
    where?: ReportTemplateWhereInput
    /**
     * Limit how many ReportTemplates to update.
     */
    limit?: number
  }

  /**
   * ReportTemplate updateManyAndReturn
   */
  export type ReportTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * The data used to update ReportTemplates.
     */
    data: XOR<ReportTemplateUpdateManyMutationInput, ReportTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ReportTemplates to update
     */
    where?: ReportTemplateWhereInput
    /**
     * Limit how many ReportTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportTemplate upsert
   */
  export type ReportTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportTemplate to update in case it exists.
     */
    where: ReportTemplateWhereUniqueInput
    /**
     * In case the ReportTemplate found by the `where` argument doesn't exist, create a new ReportTemplate with this data.
     */
    create: XOR<ReportTemplateCreateInput, ReportTemplateUncheckedCreateInput>
    /**
     * In case the ReportTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportTemplateUpdateInput, ReportTemplateUncheckedUpdateInput>
  }

  /**
   * ReportTemplate delete
   */
  export type ReportTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter which ReportTemplate to delete.
     */
    where: ReportTemplateWhereUniqueInput
  }

  /**
   * ReportTemplate deleteMany
   */
  export type ReportTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportTemplates to delete
     */
    where?: ReportTemplateWhereInput
    /**
     * Limit how many ReportTemplates to delete.
     */
    limit?: number
  }

  /**
   * ReportTemplate.radReports
   */
  export type ReportTemplate$radReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadReport
     */
    select?: RadReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadReport
     */
    omit?: RadReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadReportInclude<ExtArgs> | null
    where?: RadReportWhereInput
    orderBy?: RadReportOrderByWithRelationInput | RadReportOrderByWithRelationInput[]
    cursor?: RadReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RadReportScalarFieldEnum | RadReportScalarFieldEnum[]
  }

  /**
   * ReportTemplate without action
   */
  export type ReportTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
  }


  /**
   * Model TelemedicineConsultation
   */

  export type AggregateTelemedicineConsultation = {
    _count: TelemedicineConsultationCountAggregateOutputType | null
    _avg: TelemedicineConsultationAvgAggregateOutputType | null
    _sum: TelemedicineConsultationSumAggregateOutputType | null
    _min: TelemedicineConsultationMinAggregateOutputType | null
    _max: TelemedicineConsultationMaxAggregateOutputType | null
  }

  export type TelemedicineConsultationAvgAggregateOutputType = {
    duration: number | null
  }

  export type TelemedicineConsultationSumAggregateOutputType = {
    duration: number | null
  }

  export type TelemedicineConsultationMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    status: $Enums.TelemedicineStatus | null
    scheduledAt: Date | null
    startedAt: Date | null
    endedAt: Date | null
    duration: number | null
    consultationType: $Enums.ConsultationType | null
    reason: string | null
    notes: string | null
    prescription: string | null
    followUpRequired: boolean | null
    followUpDate: Date | null
    isEmergency: boolean | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TelemedicineConsultationMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    status: $Enums.TelemedicineStatus | null
    scheduledAt: Date | null
    startedAt: Date | null
    endedAt: Date | null
    duration: number | null
    consultationType: $Enums.ConsultationType | null
    reason: string | null
    notes: string | null
    prescription: string | null
    followUpRequired: boolean | null
    followUpDate: Date | null
    isEmergency: boolean | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TelemedicineConsultationCountAggregateOutputType = {
    id: number
    patientId: number
    doctorId: number
    status: number
    scheduledAt: number
    startedAt: number
    endedAt: number
    duration: number
    consultationType: number
    reason: number
    notes: number
    prescription: number
    followUpRequired: number
    followUpDate: number
    isEmergency: number
    isActive: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TelemedicineConsultationAvgAggregateInputType = {
    duration?: true
  }

  export type TelemedicineConsultationSumAggregateInputType = {
    duration?: true
  }

  export type TelemedicineConsultationMinAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    endedAt?: true
    duration?: true
    consultationType?: true
    reason?: true
    notes?: true
    prescription?: true
    followUpRequired?: true
    followUpDate?: true
    isEmergency?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TelemedicineConsultationMaxAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    endedAt?: true
    duration?: true
    consultationType?: true
    reason?: true
    notes?: true
    prescription?: true
    followUpRequired?: true
    followUpDate?: true
    isEmergency?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TelemedicineConsultationCountAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    endedAt?: true
    duration?: true
    consultationType?: true
    reason?: true
    notes?: true
    prescription?: true
    followUpRequired?: true
    followUpDate?: true
    isEmergency?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TelemedicineConsultationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelemedicineConsultation to aggregate.
     */
    where?: TelemedicineConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelemedicineConsultations to fetch.
     */
    orderBy?: TelemedicineConsultationOrderByWithRelationInput | TelemedicineConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TelemedicineConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelemedicineConsultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelemedicineConsultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TelemedicineConsultations
    **/
    _count?: true | TelemedicineConsultationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TelemedicineConsultationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TelemedicineConsultationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TelemedicineConsultationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TelemedicineConsultationMaxAggregateInputType
  }

  export type GetTelemedicineConsultationAggregateType<T extends TelemedicineConsultationAggregateArgs> = {
        [P in keyof T & keyof AggregateTelemedicineConsultation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTelemedicineConsultation[P]>
      : GetScalarType<T[P], AggregateTelemedicineConsultation[P]>
  }




  export type TelemedicineConsultationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelemedicineConsultationWhereInput
    orderBy?: TelemedicineConsultationOrderByWithAggregationInput | TelemedicineConsultationOrderByWithAggregationInput[]
    by: TelemedicineConsultationScalarFieldEnum[] | TelemedicineConsultationScalarFieldEnum
    having?: TelemedicineConsultationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TelemedicineConsultationCountAggregateInputType | true
    _avg?: TelemedicineConsultationAvgAggregateInputType
    _sum?: TelemedicineConsultationSumAggregateInputType
    _min?: TelemedicineConsultationMinAggregateInputType
    _max?: TelemedicineConsultationMaxAggregateInputType
  }

  export type TelemedicineConsultationGroupByOutputType = {
    id: string
    patientId: string
    doctorId: string | null
    status: $Enums.TelemedicineStatus
    scheduledAt: Date
    startedAt: Date | null
    endedAt: Date | null
    duration: number | null
    consultationType: $Enums.ConsultationType
    reason: string | null
    notes: string | null
    prescription: string | null
    followUpRequired: boolean
    followUpDate: Date | null
    isEmergency: boolean
    isActive: boolean
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: TelemedicineConsultationCountAggregateOutputType | null
    _avg: TelemedicineConsultationAvgAggregateOutputType | null
    _sum: TelemedicineConsultationSumAggregateOutputType | null
    _min: TelemedicineConsultationMinAggregateOutputType | null
    _max: TelemedicineConsultationMaxAggregateOutputType | null
  }

  type GetTelemedicineConsultationGroupByPayload<T extends TelemedicineConsultationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TelemedicineConsultationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TelemedicineConsultationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TelemedicineConsultationGroupByOutputType[P]>
            : GetScalarType<T[P], TelemedicineConsultationGroupByOutputType[P]>
        }
      >
    >


  export type TelemedicineConsultationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    consultationType?: boolean
    reason?: boolean
    notes?: boolean
    prescription?: boolean
    followUpRequired?: boolean
    followUpDate?: boolean
    isEmergency?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | TelemedicineConsultation$doctorArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    videoRoom?: boolean | TelemedicineConsultation$videoRoomArgs<ExtArgs>
    labOrders?: boolean | TelemedicineConsultation$labOrdersArgs<ExtArgs>
    radiologyOrders?: boolean | TelemedicineConsultation$radiologyOrdersArgs<ExtArgs>
    _count?: boolean | TelemedicineConsultationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telemedicineConsultation"]>

  export type TelemedicineConsultationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    consultationType?: boolean
    reason?: boolean
    notes?: boolean
    prescription?: boolean
    followUpRequired?: boolean
    followUpDate?: boolean
    isEmergency?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | TelemedicineConsultation$doctorArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telemedicineConsultation"]>

  export type TelemedicineConsultationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    consultationType?: boolean
    reason?: boolean
    notes?: boolean
    prescription?: boolean
    followUpRequired?: boolean
    followUpDate?: boolean
    isEmergency?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | TelemedicineConsultation$doctorArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telemedicineConsultation"]>

  export type TelemedicineConsultationSelectScalar = {
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    endedAt?: boolean
    duration?: boolean
    consultationType?: boolean
    reason?: boolean
    notes?: boolean
    prescription?: boolean
    followUpRequired?: boolean
    followUpDate?: boolean
    isEmergency?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TelemedicineConsultationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "doctorId" | "status" | "scheduledAt" | "startedAt" | "endedAt" | "duration" | "consultationType" | "reason" | "notes" | "prescription" | "followUpRequired" | "followUpDate" | "isEmergency" | "isActive" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["telemedicineConsultation"]>
  export type TelemedicineConsultationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | TelemedicineConsultation$doctorArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    videoRoom?: boolean | TelemedicineConsultation$videoRoomArgs<ExtArgs>
    labOrders?: boolean | TelemedicineConsultation$labOrdersArgs<ExtArgs>
    radiologyOrders?: boolean | TelemedicineConsultation$radiologyOrdersArgs<ExtArgs>
    _count?: boolean | TelemedicineConsultationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TelemedicineConsultationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | TelemedicineConsultation$doctorArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TelemedicineConsultationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | TelemedicineConsultation$doctorArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TelemedicineConsultationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TelemedicineConsultation"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      doctor: Prisma.$UserPayload<ExtArgs> | null
      tenant: Prisma.$TenantPayload<ExtArgs>
      videoRoom: Prisma.$VideoRoomPayload<ExtArgs> | null
      labOrders: Prisma.$LabOrderPayload<ExtArgs>[]
      radiologyOrders: Prisma.$RadiologyOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      doctorId: string | null
      status: $Enums.TelemedicineStatus
      scheduledAt: Date
      startedAt: Date | null
      endedAt: Date | null
      duration: number | null
      consultationType: $Enums.ConsultationType
      reason: string | null
      notes: string | null
      prescription: string | null
      followUpRequired: boolean
      followUpDate: Date | null
      isEmergency: boolean
      isActive: boolean
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["telemedicineConsultation"]>
    composites: {}
  }

  type TelemedicineConsultationGetPayload<S extends boolean | null | undefined | TelemedicineConsultationDefaultArgs> = $Result.GetResult<Prisma.$TelemedicineConsultationPayload, S>

  type TelemedicineConsultationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TelemedicineConsultationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TelemedicineConsultationCountAggregateInputType | true
    }

  export interface TelemedicineConsultationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TelemedicineConsultation'], meta: { name: 'TelemedicineConsultation' } }
    /**
     * Find zero or one TelemedicineConsultation that matches the filter.
     * @param {TelemedicineConsultationFindUniqueArgs} args - Arguments to find a TelemedicineConsultation
     * @example
     * // Get one TelemedicineConsultation
     * const telemedicineConsultation = await prisma.telemedicineConsultation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TelemedicineConsultationFindUniqueArgs>(args: SelectSubset<T, TelemedicineConsultationFindUniqueArgs<ExtArgs>>): Prisma__TelemedicineConsultationClient<$Result.GetResult<Prisma.$TelemedicineConsultationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TelemedicineConsultation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TelemedicineConsultationFindUniqueOrThrowArgs} args - Arguments to find a TelemedicineConsultation
     * @example
     * // Get one TelemedicineConsultation
     * const telemedicineConsultation = await prisma.telemedicineConsultation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TelemedicineConsultationFindUniqueOrThrowArgs>(args: SelectSubset<T, TelemedicineConsultationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TelemedicineConsultationClient<$Result.GetResult<Prisma.$TelemedicineConsultationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TelemedicineConsultation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelemedicineConsultationFindFirstArgs} args - Arguments to find a TelemedicineConsultation
     * @example
     * // Get one TelemedicineConsultation
     * const telemedicineConsultation = await prisma.telemedicineConsultation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TelemedicineConsultationFindFirstArgs>(args?: SelectSubset<T, TelemedicineConsultationFindFirstArgs<ExtArgs>>): Prisma__TelemedicineConsultationClient<$Result.GetResult<Prisma.$TelemedicineConsultationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TelemedicineConsultation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelemedicineConsultationFindFirstOrThrowArgs} args - Arguments to find a TelemedicineConsultation
     * @example
     * // Get one TelemedicineConsultation
     * const telemedicineConsultation = await prisma.telemedicineConsultation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TelemedicineConsultationFindFirstOrThrowArgs>(args?: SelectSubset<T, TelemedicineConsultationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TelemedicineConsultationClient<$Result.GetResult<Prisma.$TelemedicineConsultationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TelemedicineConsultations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelemedicineConsultationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TelemedicineConsultations
     * const telemedicineConsultations = await prisma.telemedicineConsultation.findMany()
     * 
     * // Get first 10 TelemedicineConsultations
     * const telemedicineConsultations = await prisma.telemedicineConsultation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const telemedicineConsultationWithIdOnly = await prisma.telemedicineConsultation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TelemedicineConsultationFindManyArgs>(args?: SelectSubset<T, TelemedicineConsultationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelemedicineConsultationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TelemedicineConsultation.
     * @param {TelemedicineConsultationCreateArgs} args - Arguments to create a TelemedicineConsultation.
     * @example
     * // Create one TelemedicineConsultation
     * const TelemedicineConsultation = await prisma.telemedicineConsultation.create({
     *   data: {
     *     // ... data to create a TelemedicineConsultation
     *   }
     * })
     * 
     */
    create<T extends TelemedicineConsultationCreateArgs>(args: SelectSubset<T, TelemedicineConsultationCreateArgs<ExtArgs>>): Prisma__TelemedicineConsultationClient<$Result.GetResult<Prisma.$TelemedicineConsultationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TelemedicineConsultations.
     * @param {TelemedicineConsultationCreateManyArgs} args - Arguments to create many TelemedicineConsultations.
     * @example
     * // Create many TelemedicineConsultations
     * const telemedicineConsultation = await prisma.telemedicineConsultation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TelemedicineConsultationCreateManyArgs>(args?: SelectSubset<T, TelemedicineConsultationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TelemedicineConsultations and returns the data saved in the database.
     * @param {TelemedicineConsultationCreateManyAndReturnArgs} args - Arguments to create many TelemedicineConsultations.
     * @example
     * // Create many TelemedicineConsultations
     * const telemedicineConsultation = await prisma.telemedicineConsultation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TelemedicineConsultations and only return the `id`
     * const telemedicineConsultationWithIdOnly = await prisma.telemedicineConsultation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TelemedicineConsultationCreateManyAndReturnArgs>(args?: SelectSubset<T, TelemedicineConsultationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelemedicineConsultationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TelemedicineConsultation.
     * @param {TelemedicineConsultationDeleteArgs} args - Arguments to delete one TelemedicineConsultation.
     * @example
     * // Delete one TelemedicineConsultation
     * const TelemedicineConsultation = await prisma.telemedicineConsultation.delete({
     *   where: {
     *     // ... filter to delete one TelemedicineConsultation
     *   }
     * })
     * 
     */
    delete<T extends TelemedicineConsultationDeleteArgs>(args: SelectSubset<T, TelemedicineConsultationDeleteArgs<ExtArgs>>): Prisma__TelemedicineConsultationClient<$Result.GetResult<Prisma.$TelemedicineConsultationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TelemedicineConsultation.
     * @param {TelemedicineConsultationUpdateArgs} args - Arguments to update one TelemedicineConsultation.
     * @example
     * // Update one TelemedicineConsultation
     * const telemedicineConsultation = await prisma.telemedicineConsultation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TelemedicineConsultationUpdateArgs>(args: SelectSubset<T, TelemedicineConsultationUpdateArgs<ExtArgs>>): Prisma__TelemedicineConsultationClient<$Result.GetResult<Prisma.$TelemedicineConsultationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TelemedicineConsultations.
     * @param {TelemedicineConsultationDeleteManyArgs} args - Arguments to filter TelemedicineConsultations to delete.
     * @example
     * // Delete a few TelemedicineConsultations
     * const { count } = await prisma.telemedicineConsultation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TelemedicineConsultationDeleteManyArgs>(args?: SelectSubset<T, TelemedicineConsultationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelemedicineConsultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelemedicineConsultationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TelemedicineConsultations
     * const telemedicineConsultation = await prisma.telemedicineConsultation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TelemedicineConsultationUpdateManyArgs>(args: SelectSubset<T, TelemedicineConsultationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelemedicineConsultations and returns the data updated in the database.
     * @param {TelemedicineConsultationUpdateManyAndReturnArgs} args - Arguments to update many TelemedicineConsultations.
     * @example
     * // Update many TelemedicineConsultations
     * const telemedicineConsultation = await prisma.telemedicineConsultation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TelemedicineConsultations and only return the `id`
     * const telemedicineConsultationWithIdOnly = await prisma.telemedicineConsultation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TelemedicineConsultationUpdateManyAndReturnArgs>(args: SelectSubset<T, TelemedicineConsultationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelemedicineConsultationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TelemedicineConsultation.
     * @param {TelemedicineConsultationUpsertArgs} args - Arguments to update or create a TelemedicineConsultation.
     * @example
     * // Update or create a TelemedicineConsultation
     * const telemedicineConsultation = await prisma.telemedicineConsultation.upsert({
     *   create: {
     *     // ... data to create a TelemedicineConsultation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TelemedicineConsultation we want to update
     *   }
     * })
     */
    upsert<T extends TelemedicineConsultationUpsertArgs>(args: SelectSubset<T, TelemedicineConsultationUpsertArgs<ExtArgs>>): Prisma__TelemedicineConsultationClient<$Result.GetResult<Prisma.$TelemedicineConsultationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TelemedicineConsultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelemedicineConsultationCountArgs} args - Arguments to filter TelemedicineConsultations to count.
     * @example
     * // Count the number of TelemedicineConsultations
     * const count = await prisma.telemedicineConsultation.count({
     *   where: {
     *     // ... the filter for the TelemedicineConsultations we want to count
     *   }
     * })
    **/
    count<T extends TelemedicineConsultationCountArgs>(
      args?: Subset<T, TelemedicineConsultationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TelemedicineConsultationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TelemedicineConsultation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelemedicineConsultationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TelemedicineConsultationAggregateArgs>(args: Subset<T, TelemedicineConsultationAggregateArgs>): Prisma.PrismaPromise<GetTelemedicineConsultationAggregateType<T>>

    /**
     * Group by TelemedicineConsultation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelemedicineConsultationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TelemedicineConsultationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TelemedicineConsultationGroupByArgs['orderBy'] }
        : { orderBy?: TelemedicineConsultationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TelemedicineConsultationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTelemedicineConsultationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TelemedicineConsultation model
   */
  readonly fields: TelemedicineConsultationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TelemedicineConsultation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TelemedicineConsultationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends TelemedicineConsultation$doctorArgs<ExtArgs> = {}>(args?: Subset<T, TelemedicineConsultation$doctorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    videoRoom<T extends TelemedicineConsultation$videoRoomArgs<ExtArgs> = {}>(args?: Subset<T, TelemedicineConsultation$videoRoomArgs<ExtArgs>>): Prisma__VideoRoomClient<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    labOrders<T extends TelemedicineConsultation$labOrdersArgs<ExtArgs> = {}>(args?: Subset<T, TelemedicineConsultation$labOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    radiologyOrders<T extends TelemedicineConsultation$radiologyOrdersArgs<ExtArgs> = {}>(args?: Subset<T, TelemedicineConsultation$radiologyOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiologyOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TelemedicineConsultation model
   */
  interface TelemedicineConsultationFieldRefs {
    readonly id: FieldRef<"TelemedicineConsultation", 'String'>
    readonly patientId: FieldRef<"TelemedicineConsultation", 'String'>
    readonly doctorId: FieldRef<"TelemedicineConsultation", 'String'>
    readonly status: FieldRef<"TelemedicineConsultation", 'TelemedicineStatus'>
    readonly scheduledAt: FieldRef<"TelemedicineConsultation", 'DateTime'>
    readonly startedAt: FieldRef<"TelemedicineConsultation", 'DateTime'>
    readonly endedAt: FieldRef<"TelemedicineConsultation", 'DateTime'>
    readonly duration: FieldRef<"TelemedicineConsultation", 'Int'>
    readonly consultationType: FieldRef<"TelemedicineConsultation", 'ConsultationType'>
    readonly reason: FieldRef<"TelemedicineConsultation", 'String'>
    readonly notes: FieldRef<"TelemedicineConsultation", 'String'>
    readonly prescription: FieldRef<"TelemedicineConsultation", 'String'>
    readonly followUpRequired: FieldRef<"TelemedicineConsultation", 'Boolean'>
    readonly followUpDate: FieldRef<"TelemedicineConsultation", 'DateTime'>
    readonly isEmergency: FieldRef<"TelemedicineConsultation", 'Boolean'>
    readonly isActive: FieldRef<"TelemedicineConsultation", 'Boolean'>
    readonly tenantId: FieldRef<"TelemedicineConsultation", 'String'>
    readonly createdAt: FieldRef<"TelemedicineConsultation", 'DateTime'>
    readonly updatedAt: FieldRef<"TelemedicineConsultation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TelemedicineConsultation findUnique
   */
  export type TelemedicineConsultationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelemedicineConsultation
     */
    select?: TelemedicineConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelemedicineConsultation
     */
    omit?: TelemedicineConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemedicineConsultationInclude<ExtArgs> | null
    /**
     * Filter, which TelemedicineConsultation to fetch.
     */
    where: TelemedicineConsultationWhereUniqueInput
  }

  /**
   * TelemedicineConsultation findUniqueOrThrow
   */
  export type TelemedicineConsultationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelemedicineConsultation
     */
    select?: TelemedicineConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelemedicineConsultation
     */
    omit?: TelemedicineConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemedicineConsultationInclude<ExtArgs> | null
    /**
     * Filter, which TelemedicineConsultation to fetch.
     */
    where: TelemedicineConsultationWhereUniqueInput
  }

  /**
   * TelemedicineConsultation findFirst
   */
  export type TelemedicineConsultationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelemedicineConsultation
     */
    select?: TelemedicineConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelemedicineConsultation
     */
    omit?: TelemedicineConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemedicineConsultationInclude<ExtArgs> | null
    /**
     * Filter, which TelemedicineConsultation to fetch.
     */
    where?: TelemedicineConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelemedicineConsultations to fetch.
     */
    orderBy?: TelemedicineConsultationOrderByWithRelationInput | TelemedicineConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelemedicineConsultations.
     */
    cursor?: TelemedicineConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelemedicineConsultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelemedicineConsultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelemedicineConsultations.
     */
    distinct?: TelemedicineConsultationScalarFieldEnum | TelemedicineConsultationScalarFieldEnum[]
  }

  /**
   * TelemedicineConsultation findFirstOrThrow
   */
  export type TelemedicineConsultationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelemedicineConsultation
     */
    select?: TelemedicineConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelemedicineConsultation
     */
    omit?: TelemedicineConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemedicineConsultationInclude<ExtArgs> | null
    /**
     * Filter, which TelemedicineConsultation to fetch.
     */
    where?: TelemedicineConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelemedicineConsultations to fetch.
     */
    orderBy?: TelemedicineConsultationOrderByWithRelationInput | TelemedicineConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelemedicineConsultations.
     */
    cursor?: TelemedicineConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelemedicineConsultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelemedicineConsultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelemedicineConsultations.
     */
    distinct?: TelemedicineConsultationScalarFieldEnum | TelemedicineConsultationScalarFieldEnum[]
  }

  /**
   * TelemedicineConsultation findMany
   */
  export type TelemedicineConsultationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelemedicineConsultation
     */
    select?: TelemedicineConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelemedicineConsultation
     */
    omit?: TelemedicineConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemedicineConsultationInclude<ExtArgs> | null
    /**
     * Filter, which TelemedicineConsultations to fetch.
     */
    where?: TelemedicineConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelemedicineConsultations to fetch.
     */
    orderBy?: TelemedicineConsultationOrderByWithRelationInput | TelemedicineConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TelemedicineConsultations.
     */
    cursor?: TelemedicineConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelemedicineConsultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelemedicineConsultations.
     */
    skip?: number
    distinct?: TelemedicineConsultationScalarFieldEnum | TelemedicineConsultationScalarFieldEnum[]
  }

  /**
   * TelemedicineConsultation create
   */
  export type TelemedicineConsultationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelemedicineConsultation
     */
    select?: TelemedicineConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelemedicineConsultation
     */
    omit?: TelemedicineConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemedicineConsultationInclude<ExtArgs> | null
    /**
     * The data needed to create a TelemedicineConsultation.
     */
    data: XOR<TelemedicineConsultationCreateInput, TelemedicineConsultationUncheckedCreateInput>
  }

  /**
   * TelemedicineConsultation createMany
   */
  export type TelemedicineConsultationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TelemedicineConsultations.
     */
    data: TelemedicineConsultationCreateManyInput | TelemedicineConsultationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TelemedicineConsultation createManyAndReturn
   */
  export type TelemedicineConsultationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelemedicineConsultation
     */
    select?: TelemedicineConsultationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TelemedicineConsultation
     */
    omit?: TelemedicineConsultationOmit<ExtArgs> | null
    /**
     * The data used to create many TelemedicineConsultations.
     */
    data: TelemedicineConsultationCreateManyInput | TelemedicineConsultationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemedicineConsultationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TelemedicineConsultation update
   */
  export type TelemedicineConsultationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelemedicineConsultation
     */
    select?: TelemedicineConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelemedicineConsultation
     */
    omit?: TelemedicineConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemedicineConsultationInclude<ExtArgs> | null
    /**
     * The data needed to update a TelemedicineConsultation.
     */
    data: XOR<TelemedicineConsultationUpdateInput, TelemedicineConsultationUncheckedUpdateInput>
    /**
     * Choose, which TelemedicineConsultation to update.
     */
    where: TelemedicineConsultationWhereUniqueInput
  }

  /**
   * TelemedicineConsultation updateMany
   */
  export type TelemedicineConsultationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TelemedicineConsultations.
     */
    data: XOR<TelemedicineConsultationUpdateManyMutationInput, TelemedicineConsultationUncheckedUpdateManyInput>
    /**
     * Filter which TelemedicineConsultations to update
     */
    where?: TelemedicineConsultationWhereInput
    /**
     * Limit how many TelemedicineConsultations to update.
     */
    limit?: number
  }

  /**
   * TelemedicineConsultation updateManyAndReturn
   */
  export type TelemedicineConsultationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelemedicineConsultation
     */
    select?: TelemedicineConsultationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TelemedicineConsultation
     */
    omit?: TelemedicineConsultationOmit<ExtArgs> | null
    /**
     * The data used to update TelemedicineConsultations.
     */
    data: XOR<TelemedicineConsultationUpdateManyMutationInput, TelemedicineConsultationUncheckedUpdateManyInput>
    /**
     * Filter which TelemedicineConsultations to update
     */
    where?: TelemedicineConsultationWhereInput
    /**
     * Limit how many TelemedicineConsultations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemedicineConsultationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TelemedicineConsultation upsert
   */
  export type TelemedicineConsultationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelemedicineConsultation
     */
    select?: TelemedicineConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelemedicineConsultation
     */
    omit?: TelemedicineConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemedicineConsultationInclude<ExtArgs> | null
    /**
     * The filter to search for the TelemedicineConsultation to update in case it exists.
     */
    where: TelemedicineConsultationWhereUniqueInput
    /**
     * In case the TelemedicineConsultation found by the `where` argument doesn't exist, create a new TelemedicineConsultation with this data.
     */
    create: XOR<TelemedicineConsultationCreateInput, TelemedicineConsultationUncheckedCreateInput>
    /**
     * In case the TelemedicineConsultation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TelemedicineConsultationUpdateInput, TelemedicineConsultationUncheckedUpdateInput>
  }

  /**
   * TelemedicineConsultation delete
   */
  export type TelemedicineConsultationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelemedicineConsultation
     */
    select?: TelemedicineConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelemedicineConsultation
     */
    omit?: TelemedicineConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemedicineConsultationInclude<ExtArgs> | null
    /**
     * Filter which TelemedicineConsultation to delete.
     */
    where: TelemedicineConsultationWhereUniqueInput
  }

  /**
   * TelemedicineConsultation deleteMany
   */
  export type TelemedicineConsultationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelemedicineConsultations to delete
     */
    where?: TelemedicineConsultationWhereInput
    /**
     * Limit how many TelemedicineConsultations to delete.
     */
    limit?: number
  }

  /**
   * TelemedicineConsultation.doctor
   */
  export type TelemedicineConsultation$doctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TelemedicineConsultation.videoRoom
   */
  export type TelemedicineConsultation$videoRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRoom
     */
    omit?: VideoRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    where?: VideoRoomWhereInput
  }

  /**
   * TelemedicineConsultation.labOrders
   */
  export type TelemedicineConsultation$labOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabOrder
     */
    select?: LabOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabOrder
     */
    omit?: LabOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabOrderInclude<ExtArgs> | null
    where?: LabOrderWhereInput
    orderBy?: LabOrderOrderByWithRelationInput | LabOrderOrderByWithRelationInput[]
    cursor?: LabOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabOrderScalarFieldEnum | LabOrderScalarFieldEnum[]
  }

  /**
   * TelemedicineConsultation.radiologyOrders
   */
  export type TelemedicineConsultation$radiologyOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyOrder
     */
    select?: RadiologyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyOrder
     */
    omit?: RadiologyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyOrderInclude<ExtArgs> | null
    where?: RadiologyOrderWhereInput
    orderBy?: RadiologyOrderOrderByWithRelationInput | RadiologyOrderOrderByWithRelationInput[]
    cursor?: RadiologyOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RadiologyOrderScalarFieldEnum | RadiologyOrderScalarFieldEnum[]
  }

  /**
   * TelemedicineConsultation without action
   */
  export type TelemedicineConsultationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelemedicineConsultation
     */
    select?: TelemedicineConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelemedicineConsultation
     */
    omit?: TelemedicineConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelemedicineConsultationInclude<ExtArgs> | null
  }


  /**
   * Model VideoRoom
   */

  export type AggregateVideoRoom = {
    _count: VideoRoomCountAggregateOutputType | null
    _avg: VideoRoomAvgAggregateOutputType | null
    _sum: VideoRoomSumAggregateOutputType | null
    _min: VideoRoomMinAggregateOutputType | null
    _max: VideoRoomMaxAggregateOutputType | null
  }

  export type VideoRoomAvgAggregateOutputType = {
    maxParticipants: number | null
  }

  export type VideoRoomSumAggregateOutputType = {
    maxParticipants: number | null
  }

  export type VideoRoomMinAggregateOutputType = {
    id: string | null
    consultationId: string | null
    roomId: string | null
    status: $Enums.VideoRoomStatus | null
    startedAt: Date | null
    endedAt: Date | null
    maxParticipants: number | null
    recordingEnabled: boolean | null
    recordingUrl: string | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoRoomMaxAggregateOutputType = {
    id: string | null
    consultationId: string | null
    roomId: string | null
    status: $Enums.VideoRoomStatus | null
    startedAt: Date | null
    endedAt: Date | null
    maxParticipants: number | null
    recordingEnabled: boolean | null
    recordingUrl: string | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoRoomCountAggregateOutputType = {
    id: number
    consultationId: number
    roomId: number
    status: number
    startedAt: number
    endedAt: number
    maxParticipants: number
    recordingEnabled: number
    recordingUrl: number
    isActive: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VideoRoomAvgAggregateInputType = {
    maxParticipants?: true
  }

  export type VideoRoomSumAggregateInputType = {
    maxParticipants?: true
  }

  export type VideoRoomMinAggregateInputType = {
    id?: true
    consultationId?: true
    roomId?: true
    status?: true
    startedAt?: true
    endedAt?: true
    maxParticipants?: true
    recordingEnabled?: true
    recordingUrl?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoRoomMaxAggregateInputType = {
    id?: true
    consultationId?: true
    roomId?: true
    status?: true
    startedAt?: true
    endedAt?: true
    maxParticipants?: true
    recordingEnabled?: true
    recordingUrl?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoRoomCountAggregateInputType = {
    id?: true
    consultationId?: true
    roomId?: true
    status?: true
    startedAt?: true
    endedAt?: true
    maxParticipants?: true
    recordingEnabled?: true
    recordingUrl?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VideoRoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoRoom to aggregate.
     */
    where?: VideoRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoRooms to fetch.
     */
    orderBy?: VideoRoomOrderByWithRelationInput | VideoRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoRooms
    **/
    _count?: true | VideoRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoRoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoRoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoRoomMaxAggregateInputType
  }

  export type GetVideoRoomAggregateType<T extends VideoRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoRoom[P]>
      : GetScalarType<T[P], AggregateVideoRoom[P]>
  }




  export type VideoRoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoRoomWhereInput
    orderBy?: VideoRoomOrderByWithAggregationInput | VideoRoomOrderByWithAggregationInput[]
    by: VideoRoomScalarFieldEnum[] | VideoRoomScalarFieldEnum
    having?: VideoRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoRoomCountAggregateInputType | true
    _avg?: VideoRoomAvgAggregateInputType
    _sum?: VideoRoomSumAggregateInputType
    _min?: VideoRoomMinAggregateInputType
    _max?: VideoRoomMaxAggregateInputType
  }

  export type VideoRoomGroupByOutputType = {
    id: string
    consultationId: string
    roomId: string
    status: $Enums.VideoRoomStatus
    startedAt: Date | null
    endedAt: Date | null
    maxParticipants: number
    recordingEnabled: boolean
    recordingUrl: string | null
    isActive: boolean
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: VideoRoomCountAggregateOutputType | null
    _avg: VideoRoomAvgAggregateOutputType | null
    _sum: VideoRoomSumAggregateOutputType | null
    _min: VideoRoomMinAggregateOutputType | null
    _max: VideoRoomMaxAggregateOutputType | null
  }

  type GetVideoRoomGroupByPayload<T extends VideoRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoRoomGroupByOutputType[P]>
            : GetScalarType<T[P], VideoRoomGroupByOutputType[P]>
        }
      >
    >


  export type VideoRoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationId?: boolean
    roomId?: boolean
    status?: boolean
    startedAt?: boolean
    endedAt?: boolean
    maxParticipants?: boolean
    recordingEnabled?: boolean
    recordingUrl?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consultation?: boolean | TelemedicineConsultationDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    participants?: boolean | VideoRoom$participantsArgs<ExtArgs>
    recordings?: boolean | VideoRoom$recordingsArgs<ExtArgs>
    _count?: boolean | VideoRoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoRoom"]>

  export type VideoRoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationId?: boolean
    roomId?: boolean
    status?: boolean
    startedAt?: boolean
    endedAt?: boolean
    maxParticipants?: boolean
    recordingEnabled?: boolean
    recordingUrl?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consultation?: boolean | TelemedicineConsultationDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoRoom"]>

  export type VideoRoomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationId?: boolean
    roomId?: boolean
    status?: boolean
    startedAt?: boolean
    endedAt?: boolean
    maxParticipants?: boolean
    recordingEnabled?: boolean
    recordingUrl?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    consultation?: boolean | TelemedicineConsultationDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoRoom"]>

  export type VideoRoomSelectScalar = {
    id?: boolean
    consultationId?: boolean
    roomId?: boolean
    status?: boolean
    startedAt?: boolean
    endedAt?: boolean
    maxParticipants?: boolean
    recordingEnabled?: boolean
    recordingUrl?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VideoRoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "consultationId" | "roomId" | "status" | "startedAt" | "endedAt" | "maxParticipants" | "recordingEnabled" | "recordingUrl" | "isActive" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["videoRoom"]>
  export type VideoRoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultation?: boolean | TelemedicineConsultationDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    participants?: boolean | VideoRoom$participantsArgs<ExtArgs>
    recordings?: boolean | VideoRoom$recordingsArgs<ExtArgs>
    _count?: boolean | VideoRoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VideoRoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultation?: boolean | TelemedicineConsultationDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type VideoRoomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultation?: boolean | TelemedicineConsultationDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $VideoRoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoRoom"
    objects: {
      consultation: Prisma.$TelemedicineConsultationPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
      participants: Prisma.$VideoParticipantPayload<ExtArgs>[]
      recordings: Prisma.$VideoRecordingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      consultationId: string
      roomId: string
      status: $Enums.VideoRoomStatus
      startedAt: Date | null
      endedAt: Date | null
      maxParticipants: number
      recordingEnabled: boolean
      recordingUrl: string | null
      isActive: boolean
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["videoRoom"]>
    composites: {}
  }

  type VideoRoomGetPayload<S extends boolean | null | undefined | VideoRoomDefaultArgs> = $Result.GetResult<Prisma.$VideoRoomPayload, S>

  type VideoRoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideoRoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideoRoomCountAggregateInputType | true
    }

  export interface VideoRoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoRoom'], meta: { name: 'VideoRoom' } }
    /**
     * Find zero or one VideoRoom that matches the filter.
     * @param {VideoRoomFindUniqueArgs} args - Arguments to find a VideoRoom
     * @example
     * // Get one VideoRoom
     * const videoRoom = await prisma.videoRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoRoomFindUniqueArgs>(args: SelectSubset<T, VideoRoomFindUniqueArgs<ExtArgs>>): Prisma__VideoRoomClient<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VideoRoom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideoRoomFindUniqueOrThrowArgs} args - Arguments to find a VideoRoom
     * @example
     * // Get one VideoRoom
     * const videoRoom = await prisma.videoRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoRoomFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoRoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoRoomClient<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRoomFindFirstArgs} args - Arguments to find a VideoRoom
     * @example
     * // Get one VideoRoom
     * const videoRoom = await prisma.videoRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoRoomFindFirstArgs>(args?: SelectSubset<T, VideoRoomFindFirstArgs<ExtArgs>>): Prisma__VideoRoomClient<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoRoom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRoomFindFirstOrThrowArgs} args - Arguments to find a VideoRoom
     * @example
     * // Get one VideoRoom
     * const videoRoom = await prisma.videoRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoRoomFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoRoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoRoomClient<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VideoRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoRooms
     * const videoRooms = await prisma.videoRoom.findMany()
     * 
     * // Get first 10 VideoRooms
     * const videoRooms = await prisma.videoRoom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoRoomWithIdOnly = await prisma.videoRoom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoRoomFindManyArgs>(args?: SelectSubset<T, VideoRoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VideoRoom.
     * @param {VideoRoomCreateArgs} args - Arguments to create a VideoRoom.
     * @example
     * // Create one VideoRoom
     * const VideoRoom = await prisma.videoRoom.create({
     *   data: {
     *     // ... data to create a VideoRoom
     *   }
     * })
     * 
     */
    create<T extends VideoRoomCreateArgs>(args: SelectSubset<T, VideoRoomCreateArgs<ExtArgs>>): Prisma__VideoRoomClient<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VideoRooms.
     * @param {VideoRoomCreateManyArgs} args - Arguments to create many VideoRooms.
     * @example
     * // Create many VideoRooms
     * const videoRoom = await prisma.videoRoom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoRoomCreateManyArgs>(args?: SelectSubset<T, VideoRoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoRooms and returns the data saved in the database.
     * @param {VideoRoomCreateManyAndReturnArgs} args - Arguments to create many VideoRooms.
     * @example
     * // Create many VideoRooms
     * const videoRoom = await prisma.videoRoom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoRooms and only return the `id`
     * const videoRoomWithIdOnly = await prisma.videoRoom.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoRoomCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoRoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VideoRoom.
     * @param {VideoRoomDeleteArgs} args - Arguments to delete one VideoRoom.
     * @example
     * // Delete one VideoRoom
     * const VideoRoom = await prisma.videoRoom.delete({
     *   where: {
     *     // ... filter to delete one VideoRoom
     *   }
     * })
     * 
     */
    delete<T extends VideoRoomDeleteArgs>(args: SelectSubset<T, VideoRoomDeleteArgs<ExtArgs>>): Prisma__VideoRoomClient<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VideoRoom.
     * @param {VideoRoomUpdateArgs} args - Arguments to update one VideoRoom.
     * @example
     * // Update one VideoRoom
     * const videoRoom = await prisma.videoRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoRoomUpdateArgs>(args: SelectSubset<T, VideoRoomUpdateArgs<ExtArgs>>): Prisma__VideoRoomClient<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VideoRooms.
     * @param {VideoRoomDeleteManyArgs} args - Arguments to filter VideoRooms to delete.
     * @example
     * // Delete a few VideoRooms
     * const { count } = await prisma.videoRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoRoomDeleteManyArgs>(args?: SelectSubset<T, VideoRoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoRooms
     * const videoRoom = await prisma.videoRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoRoomUpdateManyArgs>(args: SelectSubset<T, VideoRoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoRooms and returns the data updated in the database.
     * @param {VideoRoomUpdateManyAndReturnArgs} args - Arguments to update many VideoRooms.
     * @example
     * // Update many VideoRooms
     * const videoRoom = await prisma.videoRoom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VideoRooms and only return the `id`
     * const videoRoomWithIdOnly = await prisma.videoRoom.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VideoRoomUpdateManyAndReturnArgs>(args: SelectSubset<T, VideoRoomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VideoRoom.
     * @param {VideoRoomUpsertArgs} args - Arguments to update or create a VideoRoom.
     * @example
     * // Update or create a VideoRoom
     * const videoRoom = await prisma.videoRoom.upsert({
     *   create: {
     *     // ... data to create a VideoRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoRoom we want to update
     *   }
     * })
     */
    upsert<T extends VideoRoomUpsertArgs>(args: SelectSubset<T, VideoRoomUpsertArgs<ExtArgs>>): Prisma__VideoRoomClient<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VideoRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRoomCountArgs} args - Arguments to filter VideoRooms to count.
     * @example
     * // Count the number of VideoRooms
     * const count = await prisma.videoRoom.count({
     *   where: {
     *     // ... the filter for the VideoRooms we want to count
     *   }
     * })
    **/
    count<T extends VideoRoomCountArgs>(
      args?: Subset<T, VideoRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoRoomAggregateArgs>(args: Subset<T, VideoRoomAggregateArgs>): Prisma.PrismaPromise<GetVideoRoomAggregateType<T>>

    /**
     * Group by VideoRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoRoomGroupByArgs['orderBy'] }
        : { orderBy?: VideoRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoRoom model
   */
  readonly fields: VideoRoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoRoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consultation<T extends TelemedicineConsultationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TelemedicineConsultationDefaultArgs<ExtArgs>>): Prisma__TelemedicineConsultationClient<$Result.GetResult<Prisma.$TelemedicineConsultationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    participants<T extends VideoRoom$participantsArgs<ExtArgs> = {}>(args?: Subset<T, VideoRoom$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recordings<T extends VideoRoom$recordingsArgs<ExtArgs> = {}>(args?: Subset<T, VideoRoom$recordingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoRecordingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoRoom model
   */
  interface VideoRoomFieldRefs {
    readonly id: FieldRef<"VideoRoom", 'String'>
    readonly consultationId: FieldRef<"VideoRoom", 'String'>
    readonly roomId: FieldRef<"VideoRoom", 'String'>
    readonly status: FieldRef<"VideoRoom", 'VideoRoomStatus'>
    readonly startedAt: FieldRef<"VideoRoom", 'DateTime'>
    readonly endedAt: FieldRef<"VideoRoom", 'DateTime'>
    readonly maxParticipants: FieldRef<"VideoRoom", 'Int'>
    readonly recordingEnabled: FieldRef<"VideoRoom", 'Boolean'>
    readonly recordingUrl: FieldRef<"VideoRoom", 'String'>
    readonly isActive: FieldRef<"VideoRoom", 'Boolean'>
    readonly tenantId: FieldRef<"VideoRoom", 'String'>
    readonly createdAt: FieldRef<"VideoRoom", 'DateTime'>
    readonly updatedAt: FieldRef<"VideoRoom", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VideoRoom findUnique
   */
  export type VideoRoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRoom
     */
    omit?: VideoRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    /**
     * Filter, which VideoRoom to fetch.
     */
    where: VideoRoomWhereUniqueInput
  }

  /**
   * VideoRoom findUniqueOrThrow
   */
  export type VideoRoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRoom
     */
    omit?: VideoRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    /**
     * Filter, which VideoRoom to fetch.
     */
    where: VideoRoomWhereUniqueInput
  }

  /**
   * VideoRoom findFirst
   */
  export type VideoRoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRoom
     */
    omit?: VideoRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    /**
     * Filter, which VideoRoom to fetch.
     */
    where?: VideoRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoRooms to fetch.
     */
    orderBy?: VideoRoomOrderByWithRelationInput | VideoRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoRooms.
     */
    cursor?: VideoRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoRooms.
     */
    distinct?: VideoRoomScalarFieldEnum | VideoRoomScalarFieldEnum[]
  }

  /**
   * VideoRoom findFirstOrThrow
   */
  export type VideoRoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRoom
     */
    omit?: VideoRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    /**
     * Filter, which VideoRoom to fetch.
     */
    where?: VideoRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoRooms to fetch.
     */
    orderBy?: VideoRoomOrderByWithRelationInput | VideoRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoRooms.
     */
    cursor?: VideoRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoRooms.
     */
    distinct?: VideoRoomScalarFieldEnum | VideoRoomScalarFieldEnum[]
  }

  /**
   * VideoRoom findMany
   */
  export type VideoRoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRoom
     */
    omit?: VideoRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    /**
     * Filter, which VideoRooms to fetch.
     */
    where?: VideoRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoRooms to fetch.
     */
    orderBy?: VideoRoomOrderByWithRelationInput | VideoRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoRooms.
     */
    cursor?: VideoRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoRooms.
     */
    skip?: number
    distinct?: VideoRoomScalarFieldEnum | VideoRoomScalarFieldEnum[]
  }

  /**
   * VideoRoom create
   */
  export type VideoRoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRoom
     */
    omit?: VideoRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoRoom.
     */
    data: XOR<VideoRoomCreateInput, VideoRoomUncheckedCreateInput>
  }

  /**
   * VideoRoom createMany
   */
  export type VideoRoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoRooms.
     */
    data: VideoRoomCreateManyInput | VideoRoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoRoom createManyAndReturn
   */
  export type VideoRoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRoom
     */
    omit?: VideoRoomOmit<ExtArgs> | null
    /**
     * The data used to create many VideoRooms.
     */
    data: VideoRoomCreateManyInput | VideoRoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoRoom update
   */
  export type VideoRoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRoom
     */
    omit?: VideoRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoRoom.
     */
    data: XOR<VideoRoomUpdateInput, VideoRoomUncheckedUpdateInput>
    /**
     * Choose, which VideoRoom to update.
     */
    where: VideoRoomWhereUniqueInput
  }

  /**
   * VideoRoom updateMany
   */
  export type VideoRoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoRooms.
     */
    data: XOR<VideoRoomUpdateManyMutationInput, VideoRoomUncheckedUpdateManyInput>
    /**
     * Filter which VideoRooms to update
     */
    where?: VideoRoomWhereInput
    /**
     * Limit how many VideoRooms to update.
     */
    limit?: number
  }

  /**
   * VideoRoom updateManyAndReturn
   */
  export type VideoRoomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRoom
     */
    omit?: VideoRoomOmit<ExtArgs> | null
    /**
     * The data used to update VideoRooms.
     */
    data: XOR<VideoRoomUpdateManyMutationInput, VideoRoomUncheckedUpdateManyInput>
    /**
     * Filter which VideoRooms to update
     */
    where?: VideoRoomWhereInput
    /**
     * Limit how many VideoRooms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoRoom upsert
   */
  export type VideoRoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRoom
     */
    omit?: VideoRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoRoom to update in case it exists.
     */
    where: VideoRoomWhereUniqueInput
    /**
     * In case the VideoRoom found by the `where` argument doesn't exist, create a new VideoRoom with this data.
     */
    create: XOR<VideoRoomCreateInput, VideoRoomUncheckedCreateInput>
    /**
     * In case the VideoRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoRoomUpdateInput, VideoRoomUncheckedUpdateInput>
  }

  /**
   * VideoRoom delete
   */
  export type VideoRoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRoom
     */
    omit?: VideoRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
    /**
     * Filter which VideoRoom to delete.
     */
    where: VideoRoomWhereUniqueInput
  }

  /**
   * VideoRoom deleteMany
   */
  export type VideoRoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoRooms to delete
     */
    where?: VideoRoomWhereInput
    /**
     * Limit how many VideoRooms to delete.
     */
    limit?: number
  }

  /**
   * VideoRoom.participants
   */
  export type VideoRoom$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoParticipant
     */
    omit?: VideoParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
    where?: VideoParticipantWhereInput
    orderBy?: VideoParticipantOrderByWithRelationInput | VideoParticipantOrderByWithRelationInput[]
    cursor?: VideoParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoParticipantScalarFieldEnum | VideoParticipantScalarFieldEnum[]
  }

  /**
   * VideoRoom.recordings
   */
  export type VideoRoom$recordingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRecording
     */
    select?: VideoRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRecording
     */
    omit?: VideoRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRecordingInclude<ExtArgs> | null
    where?: VideoRecordingWhereInput
    orderBy?: VideoRecordingOrderByWithRelationInput | VideoRecordingOrderByWithRelationInput[]
    cursor?: VideoRecordingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoRecordingScalarFieldEnum | VideoRecordingScalarFieldEnum[]
  }

  /**
   * VideoRoom without action
   */
  export type VideoRoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRoom
     */
    select?: VideoRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRoom
     */
    omit?: VideoRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRoomInclude<ExtArgs> | null
  }


  /**
   * Model VideoParticipant
   */

  export type AggregateVideoParticipant = {
    _count: VideoParticipantCountAggregateOutputType | null
    _min: VideoParticipantMinAggregateOutputType | null
    _max: VideoParticipantMaxAggregateOutputType | null
  }

  export type VideoParticipantMinAggregateOutputType = {
    id: string | null
    roomId: string | null
    userId: string | null
    participantType: $Enums.ParticipantType | null
    joinedAt: Date | null
    leftAt: Date | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoParticipantMaxAggregateOutputType = {
    id: string | null
    roomId: string | null
    userId: string | null
    participantType: $Enums.ParticipantType | null
    joinedAt: Date | null
    leftAt: Date | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoParticipantCountAggregateOutputType = {
    id: number
    roomId: number
    userId: number
    participantType: number
    joinedAt: number
    leftAt: number
    isActive: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VideoParticipantMinAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    participantType?: true
    joinedAt?: true
    leftAt?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoParticipantMaxAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    participantType?: true
    joinedAt?: true
    leftAt?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoParticipantCountAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    participantType?: true
    joinedAt?: true
    leftAt?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VideoParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoParticipant to aggregate.
     */
    where?: VideoParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoParticipants to fetch.
     */
    orderBy?: VideoParticipantOrderByWithRelationInput | VideoParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoParticipants
    **/
    _count?: true | VideoParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoParticipantMaxAggregateInputType
  }

  export type GetVideoParticipantAggregateType<T extends VideoParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoParticipant[P]>
      : GetScalarType<T[P], AggregateVideoParticipant[P]>
  }




  export type VideoParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoParticipantWhereInput
    orderBy?: VideoParticipantOrderByWithAggregationInput | VideoParticipantOrderByWithAggregationInput[]
    by: VideoParticipantScalarFieldEnum[] | VideoParticipantScalarFieldEnum
    having?: VideoParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoParticipantCountAggregateInputType | true
    _min?: VideoParticipantMinAggregateInputType
    _max?: VideoParticipantMaxAggregateInputType
  }

  export type VideoParticipantGroupByOutputType = {
    id: string
    roomId: string
    userId: string
    participantType: $Enums.ParticipantType
    joinedAt: Date | null
    leftAt: Date | null
    isActive: boolean
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: VideoParticipantCountAggregateOutputType | null
    _min: VideoParticipantMinAggregateOutputType | null
    _max: VideoParticipantMaxAggregateOutputType | null
  }

  type GetVideoParticipantGroupByPayload<T extends VideoParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], VideoParticipantGroupByOutputType[P]>
        }
      >
    >


  export type VideoParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    participantType?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | VideoRoomDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoParticipant"]>

  export type VideoParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    participantType?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | VideoRoomDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoParticipant"]>

  export type VideoParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    participantType?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | VideoRoomDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoParticipant"]>

  export type VideoParticipantSelectScalar = {
    id?: boolean
    roomId?: boolean
    userId?: boolean
    participantType?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VideoParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomId" | "userId" | "participantType" | "joinedAt" | "leftAt" | "isActive" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["videoParticipant"]>
  export type VideoParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | VideoRoomDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type VideoParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | VideoRoomDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type VideoParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | VideoRoomDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $VideoParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoParticipant"
    objects: {
      room: Prisma.$VideoRoomPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomId: string
      userId: string
      participantType: $Enums.ParticipantType
      joinedAt: Date | null
      leftAt: Date | null
      isActive: boolean
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["videoParticipant"]>
    composites: {}
  }

  type VideoParticipantGetPayload<S extends boolean | null | undefined | VideoParticipantDefaultArgs> = $Result.GetResult<Prisma.$VideoParticipantPayload, S>

  type VideoParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideoParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideoParticipantCountAggregateInputType | true
    }

  export interface VideoParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoParticipant'], meta: { name: 'VideoParticipant' } }
    /**
     * Find zero or one VideoParticipant that matches the filter.
     * @param {VideoParticipantFindUniqueArgs} args - Arguments to find a VideoParticipant
     * @example
     * // Get one VideoParticipant
     * const videoParticipant = await prisma.videoParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoParticipantFindUniqueArgs>(args: SelectSubset<T, VideoParticipantFindUniqueArgs<ExtArgs>>): Prisma__VideoParticipantClient<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VideoParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideoParticipantFindUniqueOrThrowArgs} args - Arguments to find a VideoParticipant
     * @example
     * // Get one VideoParticipant
     * const videoParticipant = await prisma.videoParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoParticipantClient<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoParticipantFindFirstArgs} args - Arguments to find a VideoParticipant
     * @example
     * // Get one VideoParticipant
     * const videoParticipant = await prisma.videoParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoParticipantFindFirstArgs>(args?: SelectSubset<T, VideoParticipantFindFirstArgs<ExtArgs>>): Prisma__VideoParticipantClient<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoParticipantFindFirstOrThrowArgs} args - Arguments to find a VideoParticipant
     * @example
     * // Get one VideoParticipant
     * const videoParticipant = await prisma.videoParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoParticipantClient<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VideoParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoParticipants
     * const videoParticipants = await prisma.videoParticipant.findMany()
     * 
     * // Get first 10 VideoParticipants
     * const videoParticipants = await prisma.videoParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoParticipantWithIdOnly = await prisma.videoParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoParticipantFindManyArgs>(args?: SelectSubset<T, VideoParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VideoParticipant.
     * @param {VideoParticipantCreateArgs} args - Arguments to create a VideoParticipant.
     * @example
     * // Create one VideoParticipant
     * const VideoParticipant = await prisma.videoParticipant.create({
     *   data: {
     *     // ... data to create a VideoParticipant
     *   }
     * })
     * 
     */
    create<T extends VideoParticipantCreateArgs>(args: SelectSubset<T, VideoParticipantCreateArgs<ExtArgs>>): Prisma__VideoParticipantClient<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VideoParticipants.
     * @param {VideoParticipantCreateManyArgs} args - Arguments to create many VideoParticipants.
     * @example
     * // Create many VideoParticipants
     * const videoParticipant = await prisma.videoParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoParticipantCreateManyArgs>(args?: SelectSubset<T, VideoParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoParticipants and returns the data saved in the database.
     * @param {VideoParticipantCreateManyAndReturnArgs} args - Arguments to create many VideoParticipants.
     * @example
     * // Create many VideoParticipants
     * const videoParticipant = await prisma.videoParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoParticipants and only return the `id`
     * const videoParticipantWithIdOnly = await prisma.videoParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VideoParticipant.
     * @param {VideoParticipantDeleteArgs} args - Arguments to delete one VideoParticipant.
     * @example
     * // Delete one VideoParticipant
     * const VideoParticipant = await prisma.videoParticipant.delete({
     *   where: {
     *     // ... filter to delete one VideoParticipant
     *   }
     * })
     * 
     */
    delete<T extends VideoParticipantDeleteArgs>(args: SelectSubset<T, VideoParticipantDeleteArgs<ExtArgs>>): Prisma__VideoParticipantClient<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VideoParticipant.
     * @param {VideoParticipantUpdateArgs} args - Arguments to update one VideoParticipant.
     * @example
     * // Update one VideoParticipant
     * const videoParticipant = await prisma.videoParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoParticipantUpdateArgs>(args: SelectSubset<T, VideoParticipantUpdateArgs<ExtArgs>>): Prisma__VideoParticipantClient<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VideoParticipants.
     * @param {VideoParticipantDeleteManyArgs} args - Arguments to filter VideoParticipants to delete.
     * @example
     * // Delete a few VideoParticipants
     * const { count } = await prisma.videoParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoParticipantDeleteManyArgs>(args?: SelectSubset<T, VideoParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoParticipants
     * const videoParticipant = await prisma.videoParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoParticipantUpdateManyArgs>(args: SelectSubset<T, VideoParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoParticipants and returns the data updated in the database.
     * @param {VideoParticipantUpdateManyAndReturnArgs} args - Arguments to update many VideoParticipants.
     * @example
     * // Update many VideoParticipants
     * const videoParticipant = await prisma.videoParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VideoParticipants and only return the `id`
     * const videoParticipantWithIdOnly = await prisma.videoParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VideoParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, VideoParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VideoParticipant.
     * @param {VideoParticipantUpsertArgs} args - Arguments to update or create a VideoParticipant.
     * @example
     * // Update or create a VideoParticipant
     * const videoParticipant = await prisma.videoParticipant.upsert({
     *   create: {
     *     // ... data to create a VideoParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoParticipant we want to update
     *   }
     * })
     */
    upsert<T extends VideoParticipantUpsertArgs>(args: SelectSubset<T, VideoParticipantUpsertArgs<ExtArgs>>): Prisma__VideoParticipantClient<$Result.GetResult<Prisma.$VideoParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VideoParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoParticipantCountArgs} args - Arguments to filter VideoParticipants to count.
     * @example
     * // Count the number of VideoParticipants
     * const count = await prisma.videoParticipant.count({
     *   where: {
     *     // ... the filter for the VideoParticipants we want to count
     *   }
     * })
    **/
    count<T extends VideoParticipantCountArgs>(
      args?: Subset<T, VideoParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoParticipantAggregateArgs>(args: Subset<T, VideoParticipantAggregateArgs>): Prisma.PrismaPromise<GetVideoParticipantAggregateType<T>>

    /**
     * Group by VideoParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoParticipantGroupByArgs['orderBy'] }
        : { orderBy?: VideoParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoParticipant model
   */
  readonly fields: VideoParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends VideoRoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoRoomDefaultArgs<ExtArgs>>): Prisma__VideoRoomClient<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoParticipant model
   */
  interface VideoParticipantFieldRefs {
    readonly id: FieldRef<"VideoParticipant", 'String'>
    readonly roomId: FieldRef<"VideoParticipant", 'String'>
    readonly userId: FieldRef<"VideoParticipant", 'String'>
    readonly participantType: FieldRef<"VideoParticipant", 'ParticipantType'>
    readonly joinedAt: FieldRef<"VideoParticipant", 'DateTime'>
    readonly leftAt: FieldRef<"VideoParticipant", 'DateTime'>
    readonly isActive: FieldRef<"VideoParticipant", 'Boolean'>
    readonly tenantId: FieldRef<"VideoParticipant", 'String'>
    readonly createdAt: FieldRef<"VideoParticipant", 'DateTime'>
    readonly updatedAt: FieldRef<"VideoParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VideoParticipant findUnique
   */
  export type VideoParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoParticipant
     */
    omit?: VideoParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
    /**
     * Filter, which VideoParticipant to fetch.
     */
    where: VideoParticipantWhereUniqueInput
  }

  /**
   * VideoParticipant findUniqueOrThrow
   */
  export type VideoParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoParticipant
     */
    omit?: VideoParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
    /**
     * Filter, which VideoParticipant to fetch.
     */
    where: VideoParticipantWhereUniqueInput
  }

  /**
   * VideoParticipant findFirst
   */
  export type VideoParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoParticipant
     */
    omit?: VideoParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
    /**
     * Filter, which VideoParticipant to fetch.
     */
    where?: VideoParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoParticipants to fetch.
     */
    orderBy?: VideoParticipantOrderByWithRelationInput | VideoParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoParticipants.
     */
    cursor?: VideoParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoParticipants.
     */
    distinct?: VideoParticipantScalarFieldEnum | VideoParticipantScalarFieldEnum[]
  }

  /**
   * VideoParticipant findFirstOrThrow
   */
  export type VideoParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoParticipant
     */
    omit?: VideoParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
    /**
     * Filter, which VideoParticipant to fetch.
     */
    where?: VideoParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoParticipants to fetch.
     */
    orderBy?: VideoParticipantOrderByWithRelationInput | VideoParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoParticipants.
     */
    cursor?: VideoParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoParticipants.
     */
    distinct?: VideoParticipantScalarFieldEnum | VideoParticipantScalarFieldEnum[]
  }

  /**
   * VideoParticipant findMany
   */
  export type VideoParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoParticipant
     */
    omit?: VideoParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
    /**
     * Filter, which VideoParticipants to fetch.
     */
    where?: VideoParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoParticipants to fetch.
     */
    orderBy?: VideoParticipantOrderByWithRelationInput | VideoParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoParticipants.
     */
    cursor?: VideoParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoParticipants.
     */
    skip?: number
    distinct?: VideoParticipantScalarFieldEnum | VideoParticipantScalarFieldEnum[]
  }

  /**
   * VideoParticipant create
   */
  export type VideoParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoParticipant
     */
    omit?: VideoParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoParticipant.
     */
    data: XOR<VideoParticipantCreateInput, VideoParticipantUncheckedCreateInput>
  }

  /**
   * VideoParticipant createMany
   */
  export type VideoParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoParticipants.
     */
    data: VideoParticipantCreateManyInput | VideoParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoParticipant createManyAndReturn
   */
  export type VideoParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoParticipant
     */
    omit?: VideoParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many VideoParticipants.
     */
    data: VideoParticipantCreateManyInput | VideoParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoParticipant update
   */
  export type VideoParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoParticipant
     */
    omit?: VideoParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoParticipant.
     */
    data: XOR<VideoParticipantUpdateInput, VideoParticipantUncheckedUpdateInput>
    /**
     * Choose, which VideoParticipant to update.
     */
    where: VideoParticipantWhereUniqueInput
  }

  /**
   * VideoParticipant updateMany
   */
  export type VideoParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoParticipants.
     */
    data: XOR<VideoParticipantUpdateManyMutationInput, VideoParticipantUncheckedUpdateManyInput>
    /**
     * Filter which VideoParticipants to update
     */
    where?: VideoParticipantWhereInput
    /**
     * Limit how many VideoParticipants to update.
     */
    limit?: number
  }

  /**
   * VideoParticipant updateManyAndReturn
   */
  export type VideoParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoParticipant
     */
    omit?: VideoParticipantOmit<ExtArgs> | null
    /**
     * The data used to update VideoParticipants.
     */
    data: XOR<VideoParticipantUpdateManyMutationInput, VideoParticipantUncheckedUpdateManyInput>
    /**
     * Filter which VideoParticipants to update
     */
    where?: VideoParticipantWhereInput
    /**
     * Limit how many VideoParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoParticipant upsert
   */
  export type VideoParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoParticipant
     */
    omit?: VideoParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoParticipant to update in case it exists.
     */
    where: VideoParticipantWhereUniqueInput
    /**
     * In case the VideoParticipant found by the `where` argument doesn't exist, create a new VideoParticipant with this data.
     */
    create: XOR<VideoParticipantCreateInput, VideoParticipantUncheckedCreateInput>
    /**
     * In case the VideoParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoParticipantUpdateInput, VideoParticipantUncheckedUpdateInput>
  }

  /**
   * VideoParticipant delete
   */
  export type VideoParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoParticipant
     */
    omit?: VideoParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
    /**
     * Filter which VideoParticipant to delete.
     */
    where: VideoParticipantWhereUniqueInput
  }

  /**
   * VideoParticipant deleteMany
   */
  export type VideoParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoParticipants to delete
     */
    where?: VideoParticipantWhereInput
    /**
     * Limit how many VideoParticipants to delete.
     */
    limit?: number
  }

  /**
   * VideoParticipant without action
   */
  export type VideoParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoParticipant
     */
    select?: VideoParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoParticipant
     */
    omit?: VideoParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoParticipantInclude<ExtArgs> | null
  }


  /**
   * Model VideoRecording
   */

  export type AggregateVideoRecording = {
    _count: VideoRecordingCountAggregateOutputType | null
    _avg: VideoRecordingAvgAggregateOutputType | null
    _sum: VideoRecordingSumAggregateOutputType | null
    _min: VideoRecordingMinAggregateOutputType | null
    _max: VideoRecordingMaxAggregateOutputType | null
  }

  export type VideoRecordingAvgAggregateOutputType = {
    fileSize: number | null
    duration: number | null
  }

  export type VideoRecordingSumAggregateOutputType = {
    fileSize: number | null
    duration: number | null
  }

  export type VideoRecordingMinAggregateOutputType = {
    id: string | null
    roomId: string | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    duration: number | null
    status: $Enums.RecordingStatus | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoRecordingMaxAggregateOutputType = {
    id: string | null
    roomId: string | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    duration: number | null
    status: $Enums.RecordingStatus | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoRecordingCountAggregateOutputType = {
    id: number
    roomId: number
    fileName: number
    filePath: number
    fileSize: number
    duration: number
    status: number
    isActive: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VideoRecordingAvgAggregateInputType = {
    fileSize?: true
    duration?: true
  }

  export type VideoRecordingSumAggregateInputType = {
    fileSize?: true
    duration?: true
  }

  export type VideoRecordingMinAggregateInputType = {
    id?: true
    roomId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    duration?: true
    status?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoRecordingMaxAggregateInputType = {
    id?: true
    roomId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    duration?: true
    status?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoRecordingCountAggregateInputType = {
    id?: true
    roomId?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    duration?: true
    status?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VideoRecordingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoRecording to aggregate.
     */
    where?: VideoRecordingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoRecordings to fetch.
     */
    orderBy?: VideoRecordingOrderByWithRelationInput | VideoRecordingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoRecordingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoRecordings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoRecordings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoRecordings
    **/
    _count?: true | VideoRecordingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoRecordingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoRecordingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoRecordingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoRecordingMaxAggregateInputType
  }

  export type GetVideoRecordingAggregateType<T extends VideoRecordingAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoRecording]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoRecording[P]>
      : GetScalarType<T[P], AggregateVideoRecording[P]>
  }




  export type VideoRecordingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoRecordingWhereInput
    orderBy?: VideoRecordingOrderByWithAggregationInput | VideoRecordingOrderByWithAggregationInput[]
    by: VideoRecordingScalarFieldEnum[] | VideoRecordingScalarFieldEnum
    having?: VideoRecordingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoRecordingCountAggregateInputType | true
    _avg?: VideoRecordingAvgAggregateInputType
    _sum?: VideoRecordingSumAggregateInputType
    _min?: VideoRecordingMinAggregateInputType
    _max?: VideoRecordingMaxAggregateInputType
  }

  export type VideoRecordingGroupByOutputType = {
    id: string
    roomId: string
    fileName: string
    filePath: string
    fileSize: number
    duration: number | null
    status: $Enums.RecordingStatus
    isActive: boolean
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: VideoRecordingCountAggregateOutputType | null
    _avg: VideoRecordingAvgAggregateOutputType | null
    _sum: VideoRecordingSumAggregateOutputType | null
    _min: VideoRecordingMinAggregateOutputType | null
    _max: VideoRecordingMaxAggregateOutputType | null
  }

  type GetVideoRecordingGroupByPayload<T extends VideoRecordingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoRecordingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoRecordingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoRecordingGroupByOutputType[P]>
            : GetScalarType<T[P], VideoRecordingGroupByOutputType[P]>
        }
      >
    >


  export type VideoRecordingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    duration?: boolean
    status?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | VideoRoomDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoRecording"]>

  export type VideoRecordingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    duration?: boolean
    status?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | VideoRoomDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoRecording"]>

  export type VideoRecordingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    duration?: boolean
    status?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | VideoRoomDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoRecording"]>

  export type VideoRecordingSelectScalar = {
    id?: boolean
    roomId?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    duration?: boolean
    status?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VideoRecordingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomId" | "fileName" | "filePath" | "fileSize" | "duration" | "status" | "isActive" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["videoRecording"]>
  export type VideoRecordingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | VideoRoomDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type VideoRecordingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | VideoRoomDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type VideoRecordingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | VideoRoomDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $VideoRecordingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoRecording"
    objects: {
      room: Prisma.$VideoRoomPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomId: string
      fileName: string
      filePath: string
      fileSize: number
      duration: number | null
      status: $Enums.RecordingStatus
      isActive: boolean
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["videoRecording"]>
    composites: {}
  }

  type VideoRecordingGetPayload<S extends boolean | null | undefined | VideoRecordingDefaultArgs> = $Result.GetResult<Prisma.$VideoRecordingPayload, S>

  type VideoRecordingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideoRecordingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideoRecordingCountAggregateInputType | true
    }

  export interface VideoRecordingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoRecording'], meta: { name: 'VideoRecording' } }
    /**
     * Find zero or one VideoRecording that matches the filter.
     * @param {VideoRecordingFindUniqueArgs} args - Arguments to find a VideoRecording
     * @example
     * // Get one VideoRecording
     * const videoRecording = await prisma.videoRecording.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoRecordingFindUniqueArgs>(args: SelectSubset<T, VideoRecordingFindUniqueArgs<ExtArgs>>): Prisma__VideoRecordingClient<$Result.GetResult<Prisma.$VideoRecordingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VideoRecording that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideoRecordingFindUniqueOrThrowArgs} args - Arguments to find a VideoRecording
     * @example
     * // Get one VideoRecording
     * const videoRecording = await prisma.videoRecording.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoRecordingFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoRecordingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoRecordingClient<$Result.GetResult<Prisma.$VideoRecordingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoRecording that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRecordingFindFirstArgs} args - Arguments to find a VideoRecording
     * @example
     * // Get one VideoRecording
     * const videoRecording = await prisma.videoRecording.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoRecordingFindFirstArgs>(args?: SelectSubset<T, VideoRecordingFindFirstArgs<ExtArgs>>): Prisma__VideoRecordingClient<$Result.GetResult<Prisma.$VideoRecordingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoRecording that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRecordingFindFirstOrThrowArgs} args - Arguments to find a VideoRecording
     * @example
     * // Get one VideoRecording
     * const videoRecording = await prisma.videoRecording.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoRecordingFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoRecordingFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoRecordingClient<$Result.GetResult<Prisma.$VideoRecordingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VideoRecordings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRecordingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoRecordings
     * const videoRecordings = await prisma.videoRecording.findMany()
     * 
     * // Get first 10 VideoRecordings
     * const videoRecordings = await prisma.videoRecording.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoRecordingWithIdOnly = await prisma.videoRecording.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoRecordingFindManyArgs>(args?: SelectSubset<T, VideoRecordingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoRecordingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VideoRecording.
     * @param {VideoRecordingCreateArgs} args - Arguments to create a VideoRecording.
     * @example
     * // Create one VideoRecording
     * const VideoRecording = await prisma.videoRecording.create({
     *   data: {
     *     // ... data to create a VideoRecording
     *   }
     * })
     * 
     */
    create<T extends VideoRecordingCreateArgs>(args: SelectSubset<T, VideoRecordingCreateArgs<ExtArgs>>): Prisma__VideoRecordingClient<$Result.GetResult<Prisma.$VideoRecordingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VideoRecordings.
     * @param {VideoRecordingCreateManyArgs} args - Arguments to create many VideoRecordings.
     * @example
     * // Create many VideoRecordings
     * const videoRecording = await prisma.videoRecording.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoRecordingCreateManyArgs>(args?: SelectSubset<T, VideoRecordingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoRecordings and returns the data saved in the database.
     * @param {VideoRecordingCreateManyAndReturnArgs} args - Arguments to create many VideoRecordings.
     * @example
     * // Create many VideoRecordings
     * const videoRecording = await prisma.videoRecording.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoRecordings and only return the `id`
     * const videoRecordingWithIdOnly = await prisma.videoRecording.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoRecordingCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoRecordingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoRecordingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VideoRecording.
     * @param {VideoRecordingDeleteArgs} args - Arguments to delete one VideoRecording.
     * @example
     * // Delete one VideoRecording
     * const VideoRecording = await prisma.videoRecording.delete({
     *   where: {
     *     // ... filter to delete one VideoRecording
     *   }
     * })
     * 
     */
    delete<T extends VideoRecordingDeleteArgs>(args: SelectSubset<T, VideoRecordingDeleteArgs<ExtArgs>>): Prisma__VideoRecordingClient<$Result.GetResult<Prisma.$VideoRecordingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VideoRecording.
     * @param {VideoRecordingUpdateArgs} args - Arguments to update one VideoRecording.
     * @example
     * // Update one VideoRecording
     * const videoRecording = await prisma.videoRecording.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoRecordingUpdateArgs>(args: SelectSubset<T, VideoRecordingUpdateArgs<ExtArgs>>): Prisma__VideoRecordingClient<$Result.GetResult<Prisma.$VideoRecordingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VideoRecordings.
     * @param {VideoRecordingDeleteManyArgs} args - Arguments to filter VideoRecordings to delete.
     * @example
     * // Delete a few VideoRecordings
     * const { count } = await prisma.videoRecording.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoRecordingDeleteManyArgs>(args?: SelectSubset<T, VideoRecordingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoRecordings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRecordingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoRecordings
     * const videoRecording = await prisma.videoRecording.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoRecordingUpdateManyArgs>(args: SelectSubset<T, VideoRecordingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoRecordings and returns the data updated in the database.
     * @param {VideoRecordingUpdateManyAndReturnArgs} args - Arguments to update many VideoRecordings.
     * @example
     * // Update many VideoRecordings
     * const videoRecording = await prisma.videoRecording.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VideoRecordings and only return the `id`
     * const videoRecordingWithIdOnly = await prisma.videoRecording.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VideoRecordingUpdateManyAndReturnArgs>(args: SelectSubset<T, VideoRecordingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoRecordingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VideoRecording.
     * @param {VideoRecordingUpsertArgs} args - Arguments to update or create a VideoRecording.
     * @example
     * // Update or create a VideoRecording
     * const videoRecording = await prisma.videoRecording.upsert({
     *   create: {
     *     // ... data to create a VideoRecording
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoRecording we want to update
     *   }
     * })
     */
    upsert<T extends VideoRecordingUpsertArgs>(args: SelectSubset<T, VideoRecordingUpsertArgs<ExtArgs>>): Prisma__VideoRecordingClient<$Result.GetResult<Prisma.$VideoRecordingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VideoRecordings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRecordingCountArgs} args - Arguments to filter VideoRecordings to count.
     * @example
     * // Count the number of VideoRecordings
     * const count = await prisma.videoRecording.count({
     *   where: {
     *     // ... the filter for the VideoRecordings we want to count
     *   }
     * })
    **/
    count<T extends VideoRecordingCountArgs>(
      args?: Subset<T, VideoRecordingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoRecordingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoRecording.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRecordingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoRecordingAggregateArgs>(args: Subset<T, VideoRecordingAggregateArgs>): Prisma.PrismaPromise<GetVideoRecordingAggregateType<T>>

    /**
     * Group by VideoRecording.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoRecordingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoRecordingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoRecordingGroupByArgs['orderBy'] }
        : { orderBy?: VideoRecordingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoRecordingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoRecordingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoRecording model
   */
  readonly fields: VideoRecordingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoRecording.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoRecordingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends VideoRoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VideoRoomDefaultArgs<ExtArgs>>): Prisma__VideoRoomClient<$Result.GetResult<Prisma.$VideoRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoRecording model
   */
  interface VideoRecordingFieldRefs {
    readonly id: FieldRef<"VideoRecording", 'String'>
    readonly roomId: FieldRef<"VideoRecording", 'String'>
    readonly fileName: FieldRef<"VideoRecording", 'String'>
    readonly filePath: FieldRef<"VideoRecording", 'String'>
    readonly fileSize: FieldRef<"VideoRecording", 'Int'>
    readonly duration: FieldRef<"VideoRecording", 'Int'>
    readonly status: FieldRef<"VideoRecording", 'RecordingStatus'>
    readonly isActive: FieldRef<"VideoRecording", 'Boolean'>
    readonly tenantId: FieldRef<"VideoRecording", 'String'>
    readonly createdAt: FieldRef<"VideoRecording", 'DateTime'>
    readonly updatedAt: FieldRef<"VideoRecording", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VideoRecording findUnique
   */
  export type VideoRecordingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRecording
     */
    select?: VideoRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRecording
     */
    omit?: VideoRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRecordingInclude<ExtArgs> | null
    /**
     * Filter, which VideoRecording to fetch.
     */
    where: VideoRecordingWhereUniqueInput
  }

  /**
   * VideoRecording findUniqueOrThrow
   */
  export type VideoRecordingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRecording
     */
    select?: VideoRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRecording
     */
    omit?: VideoRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRecordingInclude<ExtArgs> | null
    /**
     * Filter, which VideoRecording to fetch.
     */
    where: VideoRecordingWhereUniqueInput
  }

  /**
   * VideoRecording findFirst
   */
  export type VideoRecordingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRecording
     */
    select?: VideoRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRecording
     */
    omit?: VideoRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRecordingInclude<ExtArgs> | null
    /**
     * Filter, which VideoRecording to fetch.
     */
    where?: VideoRecordingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoRecordings to fetch.
     */
    orderBy?: VideoRecordingOrderByWithRelationInput | VideoRecordingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoRecordings.
     */
    cursor?: VideoRecordingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoRecordings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoRecordings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoRecordings.
     */
    distinct?: VideoRecordingScalarFieldEnum | VideoRecordingScalarFieldEnum[]
  }

  /**
   * VideoRecording findFirstOrThrow
   */
  export type VideoRecordingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRecording
     */
    select?: VideoRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRecording
     */
    omit?: VideoRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRecordingInclude<ExtArgs> | null
    /**
     * Filter, which VideoRecording to fetch.
     */
    where?: VideoRecordingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoRecordings to fetch.
     */
    orderBy?: VideoRecordingOrderByWithRelationInput | VideoRecordingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoRecordings.
     */
    cursor?: VideoRecordingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoRecordings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoRecordings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoRecordings.
     */
    distinct?: VideoRecordingScalarFieldEnum | VideoRecordingScalarFieldEnum[]
  }

  /**
   * VideoRecording findMany
   */
  export type VideoRecordingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRecording
     */
    select?: VideoRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRecording
     */
    omit?: VideoRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRecordingInclude<ExtArgs> | null
    /**
     * Filter, which VideoRecordings to fetch.
     */
    where?: VideoRecordingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoRecordings to fetch.
     */
    orderBy?: VideoRecordingOrderByWithRelationInput | VideoRecordingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoRecordings.
     */
    cursor?: VideoRecordingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoRecordings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoRecordings.
     */
    skip?: number
    distinct?: VideoRecordingScalarFieldEnum | VideoRecordingScalarFieldEnum[]
  }

  /**
   * VideoRecording create
   */
  export type VideoRecordingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRecording
     */
    select?: VideoRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRecording
     */
    omit?: VideoRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRecordingInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoRecording.
     */
    data: XOR<VideoRecordingCreateInput, VideoRecordingUncheckedCreateInput>
  }

  /**
   * VideoRecording createMany
   */
  export type VideoRecordingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoRecordings.
     */
    data: VideoRecordingCreateManyInput | VideoRecordingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoRecording createManyAndReturn
   */
  export type VideoRecordingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRecording
     */
    select?: VideoRecordingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRecording
     */
    omit?: VideoRecordingOmit<ExtArgs> | null
    /**
     * The data used to create many VideoRecordings.
     */
    data: VideoRecordingCreateManyInput | VideoRecordingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRecordingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoRecording update
   */
  export type VideoRecordingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRecording
     */
    select?: VideoRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRecording
     */
    omit?: VideoRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRecordingInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoRecording.
     */
    data: XOR<VideoRecordingUpdateInput, VideoRecordingUncheckedUpdateInput>
    /**
     * Choose, which VideoRecording to update.
     */
    where: VideoRecordingWhereUniqueInput
  }

  /**
   * VideoRecording updateMany
   */
  export type VideoRecordingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoRecordings.
     */
    data: XOR<VideoRecordingUpdateManyMutationInput, VideoRecordingUncheckedUpdateManyInput>
    /**
     * Filter which VideoRecordings to update
     */
    where?: VideoRecordingWhereInput
    /**
     * Limit how many VideoRecordings to update.
     */
    limit?: number
  }

  /**
   * VideoRecording updateManyAndReturn
   */
  export type VideoRecordingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRecording
     */
    select?: VideoRecordingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRecording
     */
    omit?: VideoRecordingOmit<ExtArgs> | null
    /**
     * The data used to update VideoRecordings.
     */
    data: XOR<VideoRecordingUpdateManyMutationInput, VideoRecordingUncheckedUpdateManyInput>
    /**
     * Filter which VideoRecordings to update
     */
    where?: VideoRecordingWhereInput
    /**
     * Limit how many VideoRecordings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRecordingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoRecording upsert
   */
  export type VideoRecordingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRecording
     */
    select?: VideoRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRecording
     */
    omit?: VideoRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRecordingInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoRecording to update in case it exists.
     */
    where: VideoRecordingWhereUniqueInput
    /**
     * In case the VideoRecording found by the `where` argument doesn't exist, create a new VideoRecording with this data.
     */
    create: XOR<VideoRecordingCreateInput, VideoRecordingUncheckedCreateInput>
    /**
     * In case the VideoRecording was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoRecordingUpdateInput, VideoRecordingUncheckedUpdateInput>
  }

  /**
   * VideoRecording delete
   */
  export type VideoRecordingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRecording
     */
    select?: VideoRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRecording
     */
    omit?: VideoRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRecordingInclude<ExtArgs> | null
    /**
     * Filter which VideoRecording to delete.
     */
    where: VideoRecordingWhereUniqueInput
  }

  /**
   * VideoRecording deleteMany
   */
  export type VideoRecordingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoRecordings to delete
     */
    where?: VideoRecordingWhereInput
    /**
     * Limit how many VideoRecordings to delete.
     */
    limit?: number
  }

  /**
   * VideoRecording without action
   */
  export type VideoRecordingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoRecording
     */
    select?: VideoRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoRecording
     */
    omit?: VideoRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoRecordingInclude<ExtArgs> | null
  }


  /**
   * Model VideoMessage
   */

  export type AggregateVideoMessage = {
    _count: VideoMessageCountAggregateOutputType | null
    _min: VideoMessageMinAggregateOutputType | null
    _max: VideoMessageMaxAggregateOutputType | null
  }

  export type VideoMessageMinAggregateOutputType = {
    id: string | null
    roomId: string | null
    senderId: string | null
    message: string | null
    messageType: $Enums.MessageType | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoMessageMaxAggregateOutputType = {
    id: string | null
    roomId: string | null
    senderId: string | null
    message: string | null
    messageType: $Enums.MessageType | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VideoMessageCountAggregateOutputType = {
    id: number
    roomId: number
    senderId: number
    message: number
    messageType: number
    isActive: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VideoMessageMinAggregateInputType = {
    id?: true
    roomId?: true
    senderId?: true
    message?: true
    messageType?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoMessageMaxAggregateInputType = {
    id?: true
    roomId?: true
    senderId?: true
    message?: true
    messageType?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VideoMessageCountAggregateInputType = {
    id?: true
    roomId?: true
    senderId?: true
    message?: true
    messageType?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VideoMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoMessage to aggregate.
     */
    where?: VideoMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoMessages to fetch.
     */
    orderBy?: VideoMessageOrderByWithRelationInput | VideoMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VideoMessages
    **/
    _count?: true | VideoMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoMessageMaxAggregateInputType
  }

  export type GetVideoMessageAggregateType<T extends VideoMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateVideoMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideoMessage[P]>
      : GetScalarType<T[P], AggregateVideoMessage[P]>
  }




  export type VideoMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoMessageWhereInput
    orderBy?: VideoMessageOrderByWithAggregationInput | VideoMessageOrderByWithAggregationInput[]
    by: VideoMessageScalarFieldEnum[] | VideoMessageScalarFieldEnum
    having?: VideoMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoMessageCountAggregateInputType | true
    _min?: VideoMessageMinAggregateInputType
    _max?: VideoMessageMaxAggregateInputType
  }

  export type VideoMessageGroupByOutputType = {
    id: string
    roomId: string
    senderId: string
    message: string
    messageType: $Enums.MessageType
    isActive: boolean
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: VideoMessageCountAggregateOutputType | null
    _min: VideoMessageMinAggregateOutputType | null
    _max: VideoMessageMaxAggregateOutputType | null
  }

  type GetVideoMessageGroupByPayload<T extends VideoMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoMessageGroupByOutputType[P]>
            : GetScalarType<T[P], VideoMessageGroupByOutputType[P]>
        }
      >
    >


  export type VideoMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    senderId?: boolean
    message?: boolean
    messageType?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoMessage"]>

  export type VideoMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    senderId?: boolean
    message?: boolean
    messageType?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoMessage"]>

  export type VideoMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    senderId?: boolean
    message?: boolean
    messageType?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["videoMessage"]>

  export type VideoMessageSelectScalar = {
    id?: boolean
    roomId?: boolean
    senderId?: boolean
    message?: boolean
    messageType?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VideoMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomId" | "senderId" | "message" | "messageType" | "isActive" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["videoMessage"]>
  export type VideoMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type VideoMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type VideoMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $VideoMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VideoMessage"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomId: string
      senderId: string
      message: string
      messageType: $Enums.MessageType
      isActive: boolean
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["videoMessage"]>
    composites: {}
  }

  type VideoMessageGetPayload<S extends boolean | null | undefined | VideoMessageDefaultArgs> = $Result.GetResult<Prisma.$VideoMessagePayload, S>

  type VideoMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideoMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideoMessageCountAggregateInputType | true
    }

  export interface VideoMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VideoMessage'], meta: { name: 'VideoMessage' } }
    /**
     * Find zero or one VideoMessage that matches the filter.
     * @param {VideoMessageFindUniqueArgs} args - Arguments to find a VideoMessage
     * @example
     * // Get one VideoMessage
     * const videoMessage = await prisma.videoMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoMessageFindUniqueArgs>(args: SelectSubset<T, VideoMessageFindUniqueArgs<ExtArgs>>): Prisma__VideoMessageClient<$Result.GetResult<Prisma.$VideoMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VideoMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideoMessageFindUniqueOrThrowArgs} args - Arguments to find a VideoMessage
     * @example
     * // Get one VideoMessage
     * const videoMessage = await prisma.videoMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoMessageClient<$Result.GetResult<Prisma.$VideoMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoMessageFindFirstArgs} args - Arguments to find a VideoMessage
     * @example
     * // Get one VideoMessage
     * const videoMessage = await prisma.videoMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoMessageFindFirstArgs>(args?: SelectSubset<T, VideoMessageFindFirstArgs<ExtArgs>>): Prisma__VideoMessageClient<$Result.GetResult<Prisma.$VideoMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VideoMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoMessageFindFirstOrThrowArgs} args - Arguments to find a VideoMessage
     * @example
     * // Get one VideoMessage
     * const videoMessage = await prisma.videoMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoMessageClient<$Result.GetResult<Prisma.$VideoMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VideoMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VideoMessages
     * const videoMessages = await prisma.videoMessage.findMany()
     * 
     * // Get first 10 VideoMessages
     * const videoMessages = await prisma.videoMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoMessageWithIdOnly = await prisma.videoMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoMessageFindManyArgs>(args?: SelectSubset<T, VideoMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VideoMessage.
     * @param {VideoMessageCreateArgs} args - Arguments to create a VideoMessage.
     * @example
     * // Create one VideoMessage
     * const VideoMessage = await prisma.videoMessage.create({
     *   data: {
     *     // ... data to create a VideoMessage
     *   }
     * })
     * 
     */
    create<T extends VideoMessageCreateArgs>(args: SelectSubset<T, VideoMessageCreateArgs<ExtArgs>>): Prisma__VideoMessageClient<$Result.GetResult<Prisma.$VideoMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VideoMessages.
     * @param {VideoMessageCreateManyArgs} args - Arguments to create many VideoMessages.
     * @example
     * // Create many VideoMessages
     * const videoMessage = await prisma.videoMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoMessageCreateManyArgs>(args?: SelectSubset<T, VideoMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VideoMessages and returns the data saved in the database.
     * @param {VideoMessageCreateManyAndReturnArgs} args - Arguments to create many VideoMessages.
     * @example
     * // Create many VideoMessages
     * const videoMessage = await prisma.videoMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VideoMessages and only return the `id`
     * const videoMessageWithIdOnly = await prisma.videoMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VideoMessage.
     * @param {VideoMessageDeleteArgs} args - Arguments to delete one VideoMessage.
     * @example
     * // Delete one VideoMessage
     * const VideoMessage = await prisma.videoMessage.delete({
     *   where: {
     *     // ... filter to delete one VideoMessage
     *   }
     * })
     * 
     */
    delete<T extends VideoMessageDeleteArgs>(args: SelectSubset<T, VideoMessageDeleteArgs<ExtArgs>>): Prisma__VideoMessageClient<$Result.GetResult<Prisma.$VideoMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VideoMessage.
     * @param {VideoMessageUpdateArgs} args - Arguments to update one VideoMessage.
     * @example
     * // Update one VideoMessage
     * const videoMessage = await prisma.videoMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoMessageUpdateArgs>(args: SelectSubset<T, VideoMessageUpdateArgs<ExtArgs>>): Prisma__VideoMessageClient<$Result.GetResult<Prisma.$VideoMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VideoMessages.
     * @param {VideoMessageDeleteManyArgs} args - Arguments to filter VideoMessages to delete.
     * @example
     * // Delete a few VideoMessages
     * const { count } = await prisma.videoMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoMessageDeleteManyArgs>(args?: SelectSubset<T, VideoMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VideoMessages
     * const videoMessage = await prisma.videoMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoMessageUpdateManyArgs>(args: SelectSubset<T, VideoMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VideoMessages and returns the data updated in the database.
     * @param {VideoMessageUpdateManyAndReturnArgs} args - Arguments to update many VideoMessages.
     * @example
     * // Update many VideoMessages
     * const videoMessage = await prisma.videoMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VideoMessages and only return the `id`
     * const videoMessageWithIdOnly = await prisma.videoMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VideoMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, VideoMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VideoMessage.
     * @param {VideoMessageUpsertArgs} args - Arguments to update or create a VideoMessage.
     * @example
     * // Update or create a VideoMessage
     * const videoMessage = await prisma.videoMessage.upsert({
     *   create: {
     *     // ... data to create a VideoMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VideoMessage we want to update
     *   }
     * })
     */
    upsert<T extends VideoMessageUpsertArgs>(args: SelectSubset<T, VideoMessageUpsertArgs<ExtArgs>>): Prisma__VideoMessageClient<$Result.GetResult<Prisma.$VideoMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VideoMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoMessageCountArgs} args - Arguments to filter VideoMessages to count.
     * @example
     * // Count the number of VideoMessages
     * const count = await prisma.videoMessage.count({
     *   where: {
     *     // ... the filter for the VideoMessages we want to count
     *   }
     * })
    **/
    count<T extends VideoMessageCountArgs>(
      args?: Subset<T, VideoMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VideoMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoMessageAggregateArgs>(args: Subset<T, VideoMessageAggregateArgs>): Prisma.PrismaPromise<GetVideoMessageAggregateType<T>>

    /**
     * Group by VideoMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoMessageGroupByArgs['orderBy'] }
        : { orderBy?: VideoMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VideoMessage model
   */
  readonly fields: VideoMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VideoMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VideoMessage model
   */
  interface VideoMessageFieldRefs {
    readonly id: FieldRef<"VideoMessage", 'String'>
    readonly roomId: FieldRef<"VideoMessage", 'String'>
    readonly senderId: FieldRef<"VideoMessage", 'String'>
    readonly message: FieldRef<"VideoMessage", 'String'>
    readonly messageType: FieldRef<"VideoMessage", 'MessageType'>
    readonly isActive: FieldRef<"VideoMessage", 'Boolean'>
    readonly tenantId: FieldRef<"VideoMessage", 'String'>
    readonly createdAt: FieldRef<"VideoMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"VideoMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VideoMessage findUnique
   */
  export type VideoMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMessage
     */
    select?: VideoMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMessage
     */
    omit?: VideoMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMessageInclude<ExtArgs> | null
    /**
     * Filter, which VideoMessage to fetch.
     */
    where: VideoMessageWhereUniqueInput
  }

  /**
   * VideoMessage findUniqueOrThrow
   */
  export type VideoMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMessage
     */
    select?: VideoMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMessage
     */
    omit?: VideoMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMessageInclude<ExtArgs> | null
    /**
     * Filter, which VideoMessage to fetch.
     */
    where: VideoMessageWhereUniqueInput
  }

  /**
   * VideoMessage findFirst
   */
  export type VideoMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMessage
     */
    select?: VideoMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMessage
     */
    omit?: VideoMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMessageInclude<ExtArgs> | null
    /**
     * Filter, which VideoMessage to fetch.
     */
    where?: VideoMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoMessages to fetch.
     */
    orderBy?: VideoMessageOrderByWithRelationInput | VideoMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoMessages.
     */
    cursor?: VideoMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoMessages.
     */
    distinct?: VideoMessageScalarFieldEnum | VideoMessageScalarFieldEnum[]
  }

  /**
   * VideoMessage findFirstOrThrow
   */
  export type VideoMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMessage
     */
    select?: VideoMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMessage
     */
    omit?: VideoMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMessageInclude<ExtArgs> | null
    /**
     * Filter, which VideoMessage to fetch.
     */
    where?: VideoMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoMessages to fetch.
     */
    orderBy?: VideoMessageOrderByWithRelationInput | VideoMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VideoMessages.
     */
    cursor?: VideoMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VideoMessages.
     */
    distinct?: VideoMessageScalarFieldEnum | VideoMessageScalarFieldEnum[]
  }

  /**
   * VideoMessage findMany
   */
  export type VideoMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMessage
     */
    select?: VideoMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMessage
     */
    omit?: VideoMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMessageInclude<ExtArgs> | null
    /**
     * Filter, which VideoMessages to fetch.
     */
    where?: VideoMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VideoMessages to fetch.
     */
    orderBy?: VideoMessageOrderByWithRelationInput | VideoMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VideoMessages.
     */
    cursor?: VideoMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VideoMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VideoMessages.
     */
    skip?: number
    distinct?: VideoMessageScalarFieldEnum | VideoMessageScalarFieldEnum[]
  }

  /**
   * VideoMessage create
   */
  export type VideoMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMessage
     */
    select?: VideoMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMessage
     */
    omit?: VideoMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a VideoMessage.
     */
    data: XOR<VideoMessageCreateInput, VideoMessageUncheckedCreateInput>
  }

  /**
   * VideoMessage createMany
   */
  export type VideoMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VideoMessages.
     */
    data: VideoMessageCreateManyInput | VideoMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VideoMessage createManyAndReturn
   */
  export type VideoMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMessage
     */
    select?: VideoMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMessage
     */
    omit?: VideoMessageOmit<ExtArgs> | null
    /**
     * The data used to create many VideoMessages.
     */
    data: VideoMessageCreateManyInput | VideoMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoMessage update
   */
  export type VideoMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMessage
     */
    select?: VideoMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMessage
     */
    omit?: VideoMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a VideoMessage.
     */
    data: XOR<VideoMessageUpdateInput, VideoMessageUncheckedUpdateInput>
    /**
     * Choose, which VideoMessage to update.
     */
    where: VideoMessageWhereUniqueInput
  }

  /**
   * VideoMessage updateMany
   */
  export type VideoMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VideoMessages.
     */
    data: XOR<VideoMessageUpdateManyMutationInput, VideoMessageUncheckedUpdateManyInput>
    /**
     * Filter which VideoMessages to update
     */
    where?: VideoMessageWhereInput
    /**
     * Limit how many VideoMessages to update.
     */
    limit?: number
  }

  /**
   * VideoMessage updateManyAndReturn
   */
  export type VideoMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMessage
     */
    select?: VideoMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMessage
     */
    omit?: VideoMessageOmit<ExtArgs> | null
    /**
     * The data used to update VideoMessages.
     */
    data: XOR<VideoMessageUpdateManyMutationInput, VideoMessageUncheckedUpdateManyInput>
    /**
     * Filter which VideoMessages to update
     */
    where?: VideoMessageWhereInput
    /**
     * Limit how many VideoMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VideoMessage upsert
   */
  export type VideoMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMessage
     */
    select?: VideoMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMessage
     */
    omit?: VideoMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the VideoMessage to update in case it exists.
     */
    where: VideoMessageWhereUniqueInput
    /**
     * In case the VideoMessage found by the `where` argument doesn't exist, create a new VideoMessage with this data.
     */
    create: XOR<VideoMessageCreateInput, VideoMessageUncheckedCreateInput>
    /**
     * In case the VideoMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoMessageUpdateInput, VideoMessageUncheckedUpdateInput>
  }

  /**
   * VideoMessage delete
   */
  export type VideoMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMessage
     */
    select?: VideoMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMessage
     */
    omit?: VideoMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMessageInclude<ExtArgs> | null
    /**
     * Filter which VideoMessage to delete.
     */
    where: VideoMessageWhereUniqueInput
  }

  /**
   * VideoMessage deleteMany
   */
  export type VideoMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VideoMessages to delete
     */
    where?: VideoMessageWhereInput
    /**
     * Limit how many VideoMessages to delete.
     */
    limit?: number
  }

  /**
   * VideoMessage without action
   */
  export type VideoMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VideoMessage
     */
    select?: VideoMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VideoMessage
     */
    omit?: VideoMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoMessageInclude<ExtArgs> | null
  }


  /**
   * Model RadiologyOrder
   */

  export type AggregateRadiologyOrder = {
    _count: RadiologyOrderCountAggregateOutputType | null
    _min: RadiologyOrderMinAggregateOutputType | null
    _max: RadiologyOrderMaxAggregateOutputType | null
  }

  export type RadiologyOrderMinAggregateOutputType = {
    id: string | null
    consultationId: string | null
    patientId: string | null
    doctorId: string | null
    modalityId: string | null
    studyType: string | null
    priority: $Enums.Priority | null
    reason: string | null
    clinicalHistory: string | null
    status: $Enums.RadiologyOrderStatus | null
    scheduledAt: Date | null
    completedAt: Date | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studyId: string | null
  }

  export type RadiologyOrderMaxAggregateOutputType = {
    id: string | null
    consultationId: string | null
    patientId: string | null
    doctorId: string | null
    modalityId: string | null
    studyType: string | null
    priority: $Enums.Priority | null
    reason: string | null
    clinicalHistory: string | null
    status: $Enums.RadiologyOrderStatus | null
    scheduledAt: Date | null
    completedAt: Date | null
    isActive: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studyId: string | null
  }

  export type RadiologyOrderCountAggregateOutputType = {
    id: number
    consultationId: number
    patientId: number
    doctorId: number
    modalityId: number
    studyType: number
    priority: number
    reason: number
    clinicalHistory: number
    status: number
    scheduledAt: number
    completedAt: number
    isActive: number
    tenantId: number
    createdAt: number
    updatedAt: number
    studyId: number
    _all: number
  }


  export type RadiologyOrderMinAggregateInputType = {
    id?: true
    consultationId?: true
    patientId?: true
    doctorId?: true
    modalityId?: true
    studyType?: true
    priority?: true
    reason?: true
    clinicalHistory?: true
    status?: true
    scheduledAt?: true
    completedAt?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    studyId?: true
  }

  export type RadiologyOrderMaxAggregateInputType = {
    id?: true
    consultationId?: true
    patientId?: true
    doctorId?: true
    modalityId?: true
    studyType?: true
    priority?: true
    reason?: true
    clinicalHistory?: true
    status?: true
    scheduledAt?: true
    completedAt?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    studyId?: true
  }

  export type RadiologyOrderCountAggregateInputType = {
    id?: true
    consultationId?: true
    patientId?: true
    doctorId?: true
    modalityId?: true
    studyType?: true
    priority?: true
    reason?: true
    clinicalHistory?: true
    status?: true
    scheduledAt?: true
    completedAt?: true
    isActive?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    studyId?: true
    _all?: true
  }

  export type RadiologyOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RadiologyOrder to aggregate.
     */
    where?: RadiologyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RadiologyOrders to fetch.
     */
    orderBy?: RadiologyOrderOrderByWithRelationInput | RadiologyOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RadiologyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RadiologyOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RadiologyOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RadiologyOrders
    **/
    _count?: true | RadiologyOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RadiologyOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RadiologyOrderMaxAggregateInputType
  }

  export type GetRadiologyOrderAggregateType<T extends RadiologyOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateRadiologyOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRadiologyOrder[P]>
      : GetScalarType<T[P], AggregateRadiologyOrder[P]>
  }




  export type RadiologyOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RadiologyOrderWhereInput
    orderBy?: RadiologyOrderOrderByWithAggregationInput | RadiologyOrderOrderByWithAggregationInput[]
    by: RadiologyOrderScalarFieldEnum[] | RadiologyOrderScalarFieldEnum
    having?: RadiologyOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RadiologyOrderCountAggregateInputType | true
    _min?: RadiologyOrderMinAggregateInputType
    _max?: RadiologyOrderMaxAggregateInputType
  }

  export type RadiologyOrderGroupByOutputType = {
    id: string
    consultationId: string
    patientId: string
    doctorId: string
    modalityId: string
    studyType: string
    priority: $Enums.Priority
    reason: string | null
    clinicalHistory: string | null
    status: $Enums.RadiologyOrderStatus
    scheduledAt: Date | null
    completedAt: Date | null
    isActive: boolean
    tenantId: string
    createdAt: Date
    updatedAt: Date
    studyId: string | null
    _count: RadiologyOrderCountAggregateOutputType | null
    _min: RadiologyOrderMinAggregateOutputType | null
    _max: RadiologyOrderMaxAggregateOutputType | null
  }

  type GetRadiologyOrderGroupByPayload<T extends RadiologyOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RadiologyOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RadiologyOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RadiologyOrderGroupByOutputType[P]>
            : GetScalarType<T[P], RadiologyOrderGroupByOutputType[P]>
        }
      >
    >


  export type RadiologyOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationId?: boolean
    patientId?: boolean
    doctorId?: boolean
    modalityId?: boolean
    studyType?: boolean
    priority?: boolean
    reason?: boolean
    clinicalHistory?: boolean
    status?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studyId?: boolean
    consultation?: boolean | TelemedicineConsultationDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    modality?: boolean | ModalityDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    study?: boolean | RadiologyOrder$studyArgs<ExtArgs>
  }, ExtArgs["result"]["radiologyOrder"]>

  export type RadiologyOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationId?: boolean
    patientId?: boolean
    doctorId?: boolean
    modalityId?: boolean
    studyType?: boolean
    priority?: boolean
    reason?: boolean
    clinicalHistory?: boolean
    status?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studyId?: boolean
    consultation?: boolean | TelemedicineConsultationDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    modality?: boolean | ModalityDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    study?: boolean | RadiologyOrder$studyArgs<ExtArgs>
  }, ExtArgs["result"]["radiologyOrder"]>

  export type RadiologyOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationId?: boolean
    patientId?: boolean
    doctorId?: boolean
    modalityId?: boolean
    studyType?: boolean
    priority?: boolean
    reason?: boolean
    clinicalHistory?: boolean
    status?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studyId?: boolean
    consultation?: boolean | TelemedicineConsultationDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    modality?: boolean | ModalityDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    study?: boolean | RadiologyOrder$studyArgs<ExtArgs>
  }, ExtArgs["result"]["radiologyOrder"]>

  export type RadiologyOrderSelectScalar = {
    id?: boolean
    consultationId?: boolean
    patientId?: boolean
    doctorId?: boolean
    modalityId?: boolean
    studyType?: boolean
    priority?: boolean
    reason?: boolean
    clinicalHistory?: boolean
    status?: boolean
    scheduledAt?: boolean
    completedAt?: boolean
    isActive?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studyId?: boolean
  }

  export type RadiologyOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "consultationId" | "patientId" | "doctorId" | "modalityId" | "studyType" | "priority" | "reason" | "clinicalHistory" | "status" | "scheduledAt" | "completedAt" | "isActive" | "tenantId" | "createdAt" | "updatedAt" | "studyId", ExtArgs["result"]["radiologyOrder"]>
  export type RadiologyOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultation?: boolean | TelemedicineConsultationDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    modality?: boolean | ModalityDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    study?: boolean | RadiologyOrder$studyArgs<ExtArgs>
  }
  export type RadiologyOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultation?: boolean | TelemedicineConsultationDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    modality?: boolean | ModalityDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    study?: boolean | RadiologyOrder$studyArgs<ExtArgs>
  }
  export type RadiologyOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultation?: boolean | TelemedicineConsultationDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    modality?: boolean | ModalityDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    study?: boolean | RadiologyOrder$studyArgs<ExtArgs>
  }

  export type $RadiologyOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RadiologyOrder"
    objects: {
      consultation: Prisma.$TelemedicineConsultationPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
      doctor: Prisma.$UserPayload<ExtArgs>
      modality: Prisma.$ModalityPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
      study: Prisma.$StudyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      consultationId: string
      patientId: string
      doctorId: string
      modalityId: string
      studyType: string
      priority: $Enums.Priority
      reason: string | null
      clinicalHistory: string | null
      status: $Enums.RadiologyOrderStatus
      scheduledAt: Date | null
      completedAt: Date | null
      isActive: boolean
      tenantId: string
      createdAt: Date
      updatedAt: Date
      studyId: string | null
    }, ExtArgs["result"]["radiologyOrder"]>
    composites: {}
  }

  type RadiologyOrderGetPayload<S extends boolean | null | undefined | RadiologyOrderDefaultArgs> = $Result.GetResult<Prisma.$RadiologyOrderPayload, S>

  type RadiologyOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RadiologyOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RadiologyOrderCountAggregateInputType | true
    }

  export interface RadiologyOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RadiologyOrder'], meta: { name: 'RadiologyOrder' } }
    /**
     * Find zero or one RadiologyOrder that matches the filter.
     * @param {RadiologyOrderFindUniqueArgs} args - Arguments to find a RadiologyOrder
     * @example
     * // Get one RadiologyOrder
     * const radiologyOrder = await prisma.radiologyOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RadiologyOrderFindUniqueArgs>(args: SelectSubset<T, RadiologyOrderFindUniqueArgs<ExtArgs>>): Prisma__RadiologyOrderClient<$Result.GetResult<Prisma.$RadiologyOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RadiologyOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RadiologyOrderFindUniqueOrThrowArgs} args - Arguments to find a RadiologyOrder
     * @example
     * // Get one RadiologyOrder
     * const radiologyOrder = await prisma.radiologyOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RadiologyOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, RadiologyOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RadiologyOrderClient<$Result.GetResult<Prisma.$RadiologyOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RadiologyOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiologyOrderFindFirstArgs} args - Arguments to find a RadiologyOrder
     * @example
     * // Get one RadiologyOrder
     * const radiologyOrder = await prisma.radiologyOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RadiologyOrderFindFirstArgs>(args?: SelectSubset<T, RadiologyOrderFindFirstArgs<ExtArgs>>): Prisma__RadiologyOrderClient<$Result.GetResult<Prisma.$RadiologyOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RadiologyOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiologyOrderFindFirstOrThrowArgs} args - Arguments to find a RadiologyOrder
     * @example
     * // Get one RadiologyOrder
     * const radiologyOrder = await prisma.radiologyOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RadiologyOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, RadiologyOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__RadiologyOrderClient<$Result.GetResult<Prisma.$RadiologyOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RadiologyOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiologyOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RadiologyOrders
     * const radiologyOrders = await prisma.radiologyOrder.findMany()
     * 
     * // Get first 10 RadiologyOrders
     * const radiologyOrders = await prisma.radiologyOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const radiologyOrderWithIdOnly = await prisma.radiologyOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RadiologyOrderFindManyArgs>(args?: SelectSubset<T, RadiologyOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiologyOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RadiologyOrder.
     * @param {RadiologyOrderCreateArgs} args - Arguments to create a RadiologyOrder.
     * @example
     * // Create one RadiologyOrder
     * const RadiologyOrder = await prisma.radiologyOrder.create({
     *   data: {
     *     // ... data to create a RadiologyOrder
     *   }
     * })
     * 
     */
    create<T extends RadiologyOrderCreateArgs>(args: SelectSubset<T, RadiologyOrderCreateArgs<ExtArgs>>): Prisma__RadiologyOrderClient<$Result.GetResult<Prisma.$RadiologyOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RadiologyOrders.
     * @param {RadiologyOrderCreateManyArgs} args - Arguments to create many RadiologyOrders.
     * @example
     * // Create many RadiologyOrders
     * const radiologyOrder = await prisma.radiologyOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RadiologyOrderCreateManyArgs>(args?: SelectSubset<T, RadiologyOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RadiologyOrders and returns the data saved in the database.
     * @param {RadiologyOrderCreateManyAndReturnArgs} args - Arguments to create many RadiologyOrders.
     * @example
     * // Create many RadiologyOrders
     * const radiologyOrder = await prisma.radiologyOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RadiologyOrders and only return the `id`
     * const radiologyOrderWithIdOnly = await prisma.radiologyOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RadiologyOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, RadiologyOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiologyOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RadiologyOrder.
     * @param {RadiologyOrderDeleteArgs} args - Arguments to delete one RadiologyOrder.
     * @example
     * // Delete one RadiologyOrder
     * const RadiologyOrder = await prisma.radiologyOrder.delete({
     *   where: {
     *     // ... filter to delete one RadiologyOrder
     *   }
     * })
     * 
     */
    delete<T extends RadiologyOrderDeleteArgs>(args: SelectSubset<T, RadiologyOrderDeleteArgs<ExtArgs>>): Prisma__RadiologyOrderClient<$Result.GetResult<Prisma.$RadiologyOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RadiologyOrder.
     * @param {RadiologyOrderUpdateArgs} args - Arguments to update one RadiologyOrder.
     * @example
     * // Update one RadiologyOrder
     * const radiologyOrder = await prisma.radiologyOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RadiologyOrderUpdateArgs>(args: SelectSubset<T, RadiologyOrderUpdateArgs<ExtArgs>>): Prisma__RadiologyOrderClient<$Result.GetResult<Prisma.$RadiologyOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RadiologyOrders.
     * @param {RadiologyOrderDeleteManyArgs} args - Arguments to filter RadiologyOrders to delete.
     * @example
     * // Delete a few RadiologyOrders
     * const { count } = await prisma.radiologyOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RadiologyOrderDeleteManyArgs>(args?: SelectSubset<T, RadiologyOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RadiologyOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiologyOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RadiologyOrders
     * const radiologyOrder = await prisma.radiologyOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RadiologyOrderUpdateManyArgs>(args: SelectSubset<T, RadiologyOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RadiologyOrders and returns the data updated in the database.
     * @param {RadiologyOrderUpdateManyAndReturnArgs} args - Arguments to update many RadiologyOrders.
     * @example
     * // Update many RadiologyOrders
     * const radiologyOrder = await prisma.radiologyOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RadiologyOrders and only return the `id`
     * const radiologyOrderWithIdOnly = await prisma.radiologyOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RadiologyOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, RadiologyOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RadiologyOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RadiologyOrder.
     * @param {RadiologyOrderUpsertArgs} args - Arguments to update or create a RadiologyOrder.
     * @example
     * // Update or create a RadiologyOrder
     * const radiologyOrder = await prisma.radiologyOrder.upsert({
     *   create: {
     *     // ... data to create a RadiologyOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RadiologyOrder we want to update
     *   }
     * })
     */
    upsert<T extends RadiologyOrderUpsertArgs>(args: SelectSubset<T, RadiologyOrderUpsertArgs<ExtArgs>>): Prisma__RadiologyOrderClient<$Result.GetResult<Prisma.$RadiologyOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RadiologyOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiologyOrderCountArgs} args - Arguments to filter RadiologyOrders to count.
     * @example
     * // Count the number of RadiologyOrders
     * const count = await prisma.radiologyOrder.count({
     *   where: {
     *     // ... the filter for the RadiologyOrders we want to count
     *   }
     * })
    **/
    count<T extends RadiologyOrderCountArgs>(
      args?: Subset<T, RadiologyOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RadiologyOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RadiologyOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiologyOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RadiologyOrderAggregateArgs>(args: Subset<T, RadiologyOrderAggregateArgs>): Prisma.PrismaPromise<GetRadiologyOrderAggregateType<T>>

    /**
     * Group by RadiologyOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RadiologyOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RadiologyOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RadiologyOrderGroupByArgs['orderBy'] }
        : { orderBy?: RadiologyOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RadiologyOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRadiologyOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RadiologyOrder model
   */
  readonly fields: RadiologyOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RadiologyOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RadiologyOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consultation<T extends TelemedicineConsultationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TelemedicineConsultationDefaultArgs<ExtArgs>>): Prisma__TelemedicineConsultationClient<$Result.GetResult<Prisma.$TelemedicineConsultationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    modality<T extends ModalityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModalityDefaultArgs<ExtArgs>>): Prisma__ModalityClient<$Result.GetResult<Prisma.$ModalityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    study<T extends RadiologyOrder$studyArgs<ExtArgs> = {}>(args?: Subset<T, RadiologyOrder$studyArgs<ExtArgs>>): Prisma__StudyClient<$Result.GetResult<Prisma.$StudyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RadiologyOrder model
   */
  interface RadiologyOrderFieldRefs {
    readonly id: FieldRef<"RadiologyOrder", 'String'>
    readonly consultationId: FieldRef<"RadiologyOrder", 'String'>
    readonly patientId: FieldRef<"RadiologyOrder", 'String'>
    readonly doctorId: FieldRef<"RadiologyOrder", 'String'>
    readonly modalityId: FieldRef<"RadiologyOrder", 'String'>
    readonly studyType: FieldRef<"RadiologyOrder", 'String'>
    readonly priority: FieldRef<"RadiologyOrder", 'Priority'>
    readonly reason: FieldRef<"RadiologyOrder", 'String'>
    readonly clinicalHistory: FieldRef<"RadiologyOrder", 'String'>
    readonly status: FieldRef<"RadiologyOrder", 'RadiologyOrderStatus'>
    readonly scheduledAt: FieldRef<"RadiologyOrder", 'DateTime'>
    readonly completedAt: FieldRef<"RadiologyOrder", 'DateTime'>
    readonly isActive: FieldRef<"RadiologyOrder", 'Boolean'>
    readonly tenantId: FieldRef<"RadiologyOrder", 'String'>
    readonly createdAt: FieldRef<"RadiologyOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"RadiologyOrder", 'DateTime'>
    readonly studyId: FieldRef<"RadiologyOrder", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RadiologyOrder findUnique
   */
  export type RadiologyOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyOrder
     */
    select?: RadiologyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyOrder
     */
    omit?: RadiologyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyOrderInclude<ExtArgs> | null
    /**
     * Filter, which RadiologyOrder to fetch.
     */
    where: RadiologyOrderWhereUniqueInput
  }

  /**
   * RadiologyOrder findUniqueOrThrow
   */
  export type RadiologyOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyOrder
     */
    select?: RadiologyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyOrder
     */
    omit?: RadiologyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyOrderInclude<ExtArgs> | null
    /**
     * Filter, which RadiologyOrder to fetch.
     */
    where: RadiologyOrderWhereUniqueInput
  }

  /**
   * RadiologyOrder findFirst
   */
  export type RadiologyOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyOrder
     */
    select?: RadiologyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyOrder
     */
    omit?: RadiologyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyOrderInclude<ExtArgs> | null
    /**
     * Filter, which RadiologyOrder to fetch.
     */
    where?: RadiologyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RadiologyOrders to fetch.
     */
    orderBy?: RadiologyOrderOrderByWithRelationInput | RadiologyOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RadiologyOrders.
     */
    cursor?: RadiologyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RadiologyOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RadiologyOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RadiologyOrders.
     */
    distinct?: RadiologyOrderScalarFieldEnum | RadiologyOrderScalarFieldEnum[]
  }

  /**
   * RadiologyOrder findFirstOrThrow
   */
  export type RadiologyOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyOrder
     */
    select?: RadiologyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyOrder
     */
    omit?: RadiologyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyOrderInclude<ExtArgs> | null
    /**
     * Filter, which RadiologyOrder to fetch.
     */
    where?: RadiologyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RadiologyOrders to fetch.
     */
    orderBy?: RadiologyOrderOrderByWithRelationInput | RadiologyOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RadiologyOrders.
     */
    cursor?: RadiologyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RadiologyOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RadiologyOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RadiologyOrders.
     */
    distinct?: RadiologyOrderScalarFieldEnum | RadiologyOrderScalarFieldEnum[]
  }

  /**
   * RadiologyOrder findMany
   */
  export type RadiologyOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyOrder
     */
    select?: RadiologyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyOrder
     */
    omit?: RadiologyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyOrderInclude<ExtArgs> | null
    /**
     * Filter, which RadiologyOrders to fetch.
     */
    where?: RadiologyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RadiologyOrders to fetch.
     */
    orderBy?: RadiologyOrderOrderByWithRelationInput | RadiologyOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RadiologyOrders.
     */
    cursor?: RadiologyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RadiologyOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RadiologyOrders.
     */
    skip?: number
    distinct?: RadiologyOrderScalarFieldEnum | RadiologyOrderScalarFieldEnum[]
  }

  /**
   * RadiologyOrder create
   */
  export type RadiologyOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyOrder
     */
    select?: RadiologyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyOrder
     */
    omit?: RadiologyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a RadiologyOrder.
     */
    data: XOR<RadiologyOrderCreateInput, RadiologyOrderUncheckedCreateInput>
  }

  /**
   * RadiologyOrder createMany
   */
  export type RadiologyOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RadiologyOrders.
     */
    data: RadiologyOrderCreateManyInput | RadiologyOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RadiologyOrder createManyAndReturn
   */
  export type RadiologyOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyOrder
     */
    select?: RadiologyOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyOrder
     */
    omit?: RadiologyOrderOmit<ExtArgs> | null
    /**
     * The data used to create many RadiologyOrders.
     */
    data: RadiologyOrderCreateManyInput | RadiologyOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RadiologyOrder update
   */
  export type RadiologyOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyOrder
     */
    select?: RadiologyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyOrder
     */
    omit?: RadiologyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a RadiologyOrder.
     */
    data: XOR<RadiologyOrderUpdateInput, RadiologyOrderUncheckedUpdateInput>
    /**
     * Choose, which RadiologyOrder to update.
     */
    where: RadiologyOrderWhereUniqueInput
  }

  /**
   * RadiologyOrder updateMany
   */
  export type RadiologyOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RadiologyOrders.
     */
    data: XOR<RadiologyOrderUpdateManyMutationInput, RadiologyOrderUncheckedUpdateManyInput>
    /**
     * Filter which RadiologyOrders to update
     */
    where?: RadiologyOrderWhereInput
    /**
     * Limit how many RadiologyOrders to update.
     */
    limit?: number
  }

  /**
   * RadiologyOrder updateManyAndReturn
   */
  export type RadiologyOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyOrder
     */
    select?: RadiologyOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyOrder
     */
    omit?: RadiologyOrderOmit<ExtArgs> | null
    /**
     * The data used to update RadiologyOrders.
     */
    data: XOR<RadiologyOrderUpdateManyMutationInput, RadiologyOrderUncheckedUpdateManyInput>
    /**
     * Filter which RadiologyOrders to update
     */
    where?: RadiologyOrderWhereInput
    /**
     * Limit how many RadiologyOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RadiologyOrder upsert
   */
  export type RadiologyOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyOrder
     */
    select?: RadiologyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyOrder
     */
    omit?: RadiologyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the RadiologyOrder to update in case it exists.
     */
    where: RadiologyOrderWhereUniqueInput
    /**
     * In case the RadiologyOrder found by the `where` argument doesn't exist, create a new RadiologyOrder with this data.
     */
    create: XOR<RadiologyOrderCreateInput, RadiologyOrderUncheckedCreateInput>
    /**
     * In case the RadiologyOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RadiologyOrderUpdateInput, RadiologyOrderUncheckedUpdateInput>
  }

  /**
   * RadiologyOrder delete
   */
  export type RadiologyOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyOrder
     */
    select?: RadiologyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyOrder
     */
    omit?: RadiologyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyOrderInclude<ExtArgs> | null
    /**
     * Filter which RadiologyOrder to delete.
     */
    where: RadiologyOrderWhereUniqueInput
  }

  /**
   * RadiologyOrder deleteMany
   */
  export type RadiologyOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RadiologyOrders to delete
     */
    where?: RadiologyOrderWhereInput
    /**
     * Limit how many RadiologyOrders to delete.
     */
    limit?: number
  }

  /**
   * RadiologyOrder.study
   */
  export type RadiologyOrder$studyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Study
     */
    select?: StudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Study
     */
    omit?: StudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyInclude<ExtArgs> | null
    where?: StudyWhereInput
  }

  /**
   * RadiologyOrder without action
   */
  export type RadiologyOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RadiologyOrder
     */
    select?: RadiologyOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RadiologyOrder
     */
    omit?: RadiologyOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RadiologyOrderInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    isActive: 'isActive',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const SpecialtyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    isActive: 'isActive',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SpecialtyScalarFieldEnum = (typeof SpecialtyScalarFieldEnum)[keyof typeof SpecialtyScalarFieldEnum]


  export const StaffScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    employeeId: 'employeeId',
    designation: 'designation',
    departmentId: 'departmentId',
    joiningDate: 'joiningDate',
    qualification: 'qualification',
    experience: 'experience',
    isActive: 'isActive',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffScalarFieldEnum = (typeof StaffScalarFieldEnum)[keyof typeof StaffScalarFieldEnum]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    type: 'type',
    address: 'address',
    phone: 'phone',
    email: 'email',
    logo: 'logo',
    deletedAt: 'deletedAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    specialization: 'specialization',
    experience: 'experience',
    licenseNumber: 'licenseNumber',
    signature: 'signature',
    isActive: 'isActive',
    lastLoginAt: 'lastLoginAt',
    deletedAt: 'deletedAt',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    jti: 'jti',
    token: 'token',
    userId: 'userId',
    revoked: 'revoked',
    expiresAt: 'expiresAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    medicalRecordNumber: 'medicalRecordNumber',
    registrationNumber: 'registrationNumber',
    externalId: 'externalId',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender',
    bloodType: 'bloodType',
    maritalStatus: 'maritalStatus',
    email: 'email',
    phone: 'phone',
    address: 'address',
    city: 'city',
    state: 'state',
    country: 'country',
    pincode: 'pincode',
    phoneVerified: 'phoneVerified',
    emailVerified: 'emailVerified',
    allergies: 'allergies',
    chronicConditions: 'chronicConditions',
    currentMedications: 'currentMedications',
    knownAllergies: 'knownAllergies',
    familyHistory: 'familyHistory',
    insuranceProvider: 'insuranceProvider',
    insuranceId: 'insuranceId',
    insuranceGroup: 'insuranceGroup',
    insuranceValidUntil: 'insuranceValidUntil',
    insuranceType: 'insuranceType',
    tenantId: 'tenantId',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    isActive: 'isActive',
    isVerified: 'isVerified',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    doctorId: 'doctorId',
    departmentId: 'departmentId',
    startTime: 'startTime',
    endTime: 'endTime',
    status: 'status',
    reason: 'reason',
    notes: 'notes',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const PrescriptionScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    doctorId: 'doctorId',
    diagnosis: 'diagnosis',
    notes: 'notes',
    status: 'status',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PrescriptionScalarFieldEnum = (typeof PrescriptionScalarFieldEnum)[keyof typeof PrescriptionScalarFieldEnum]


  export const PrescriptionItemScalarFieldEnum: {
    id: 'id',
    prescriptionId: 'prescriptionId',
    medicationId: 'medicationId',
    patientId: 'patientId',
    dosage: 'dosage',
    frequency: 'frequency',
    duration: 'duration',
    instructions: 'instructions',
    isDispensed: 'isDispensed',
    tenantId: 'tenantId'
  };

  export type PrescriptionItemScalarFieldEnum = (typeof PrescriptionItemScalarFieldEnum)[keyof typeof PrescriptionItemScalarFieldEnum]


  export const MedicalRecordScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    recordType: 'recordType',
    title: 'title',
    description: 'description',
    date: 'date',
    doctorId: 'doctorId',
    updatedById: 'updatedById',
    isActive: 'isActive',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicalRecordScalarFieldEnum = (typeof MedicalRecordScalarFieldEnum)[keyof typeof MedicalRecordScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    patientId: 'patientId',
    date: 'date',
    dueDate: 'dueDate',
    status: 'status',
    subTotal: 'subTotal',
    taxAmount: 'taxAmount',
    discountAmount: 'discountAmount',
    totalAmount: 'totalAmount',
    notes: 'notes',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    itemType: 'itemType',
    itemId: 'itemId',
    description: 'description',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    discount: 'discount',
    taxRate: 'taxRate',
    totalAmount: 'totalAmount',
    tenantId: 'tenantId'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    paymentNumber: 'paymentNumber',
    invoiceId: 'invoiceId',
    amount: 'amount',
    paymentDate: 'paymentDate',
    paymentMethod: 'paymentMethod',
    referenceNumber: 'referenceNumber',
    notes: 'notes',
    status: 'status',
    tenantId: 'tenantId',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const LabTestScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    category: 'category',
    price: 'price',
    isActive: 'isActive',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LabTestScalarFieldEnum = (typeof LabTestScalarFieldEnum)[keyof typeof LabTestScalarFieldEnum]


  export const LabOrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    patientId: 'patientId',
    doctorId: 'doctorId',
    status: 'status',
    orderDate: 'orderDate',
    completedDate: 'completedDate',
    notes: 'notes',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    consultationId: 'consultationId'
  };

  export type LabOrderScalarFieldEnum = (typeof LabOrderScalarFieldEnum)[keyof typeof LabOrderScalarFieldEnum]


  export const LabOrderTestScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    testId: 'testId',
    status: 'status',
    result: 'result',
    resultDate: 'resultDate',
    referenceRange: 'referenceRange',
    notes: 'notes',
    tenantId: 'tenantId'
  };

  export type LabOrderTestScalarFieldEnum = (typeof LabOrderTestScalarFieldEnum)[keyof typeof LabOrderTestScalarFieldEnum]


  export const MedicationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    genericName: 'genericName',
    description: 'description',
    strength: 'strength',
    unit: 'unit',
    dosageForm: 'dosageForm',
    route: 'route',
    schedule: 'schedule',
    isActive: 'isActive',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicationScalarFieldEnum = (typeof MedicationScalarFieldEnum)[keyof typeof MedicationScalarFieldEnum]


  export const PharmacyOrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    patientId: 'patientId',
    doctorId: 'doctorId',
    status: 'status',
    orderDate: 'orderDate',
    dispensedDate: 'dispensedDate',
    notes: 'notes',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    invoiceId: 'invoiceId',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type PharmacyOrderScalarFieldEnum = (typeof PharmacyOrderScalarFieldEnum)[keyof typeof PharmacyOrderScalarFieldEnum]


  export const PharmacyOrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    medicationId: 'medicationId',
    quantity: 'quantity',
    dosage: 'dosage',
    frequency: 'frequency',
    duration: 'duration',
    instructions: 'instructions',
    status: 'status',
    tenantId: 'tenantId'
  };

  export type PharmacyOrderItemScalarFieldEnum = (typeof PharmacyOrderItemScalarFieldEnum)[keyof typeof PharmacyOrderItemScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    oldValues: 'oldValues',
    newValues: 'newValues',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    tenantId: 'tenantId',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const ModalityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModalityScalarFieldEnum = (typeof ModalityScalarFieldEnum)[keyof typeof ModalityScalarFieldEnum]


  export const StudyScalarFieldEnum: {
    id: 'id',
    studyId: 'studyId',
    patientId: 'patientId',
    patientName: 'patientName',
    modalityId: 'modalityId',
    status: 'status',
    studyDate: 'studyDate',
    priority: 'priority',
    description: 'description',
    notes: 'notes',
    isActive: 'isActive',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudyScalarFieldEnum = (typeof StudyScalarFieldEnum)[keyof typeof StudyScalarFieldEnum]


  export const SeriesScalarFieldEnum: {
    id: 'id',
    seriesUid: 'seriesUid',
    studyId: 'studyId',
    number: 'number',
    description: 'description',
    modality: 'modality',
    bodyPart: 'bodyPart',
    count: 'count',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SeriesScalarFieldEnum = (typeof SeriesScalarFieldEnum)[keyof typeof SeriesScalarFieldEnum]


  export const ImageScalarFieldEnum: {
    id: 'id',
    sopInstanceUid: 'sopInstanceUid',
    seriesId: 'seriesId',
    number: 'number',
    path: 'path',
    size: 'size',
    contentType: 'contentType',
    width: 'width',
    height: 'height',
    windowCenter: 'windowCenter',
    windowWidth: 'windowWidth',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ImageScalarFieldEnum = (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum]


  export const RadReportScalarFieldEnum: {
    id: 'id',
    reportId: 'reportId',
    studyId: 'studyId',
    reportTemplateId: 'reportTemplateId',
    status: 'status',
    findings: 'findings',
    impression: 'impression',
    conclusion: 'conclusion',
    reportDateTime: 'reportDateTime',
    verifiedBy: 'verifiedBy',
    verifiedAt: 'verifiedAt',
    isActive: 'isActive',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RadReportScalarFieldEnum = (typeof RadReportScalarFieldEnum)[keyof typeof RadReportScalarFieldEnum]


  export const RadiationDoseScalarFieldEnum: {
    id: 'id',
    studyId: 'studyId',
    deviceName: 'deviceName',
    deviceType: 'deviceType',
    exposureTime: 'exposureTime',
    kvp: 'kvp',
    ma: 'ma',
    doseAreaProduct: 'doseAreaProduct',
    doseLengthProduct: 'doseLengthProduct',
    ctdiVol: 'ctdiVol',
    dlp: 'dlp',
    effectiveDose: 'effectiveDose',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RadiationDoseScalarFieldEnum = (typeof RadiationDoseScalarFieldEnum)[keyof typeof RadiationDoseScalarFieldEnum]


  export const ReportTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    template: 'template',
    isActive: 'isActive',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportTemplateScalarFieldEnum = (typeof ReportTemplateScalarFieldEnum)[keyof typeof ReportTemplateScalarFieldEnum]


  export const TelemedicineConsultationScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    doctorId: 'doctorId',
    status: 'status',
    scheduledAt: 'scheduledAt',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    duration: 'duration',
    consultationType: 'consultationType',
    reason: 'reason',
    notes: 'notes',
    prescription: 'prescription',
    followUpRequired: 'followUpRequired',
    followUpDate: 'followUpDate',
    isEmergency: 'isEmergency',
    isActive: 'isActive',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TelemedicineConsultationScalarFieldEnum = (typeof TelemedicineConsultationScalarFieldEnum)[keyof typeof TelemedicineConsultationScalarFieldEnum]


  export const VideoRoomScalarFieldEnum: {
    id: 'id',
    consultationId: 'consultationId',
    roomId: 'roomId',
    status: 'status',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    maxParticipants: 'maxParticipants',
    recordingEnabled: 'recordingEnabled',
    recordingUrl: 'recordingUrl',
    isActive: 'isActive',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VideoRoomScalarFieldEnum = (typeof VideoRoomScalarFieldEnum)[keyof typeof VideoRoomScalarFieldEnum]


  export const VideoParticipantScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    userId: 'userId',
    participantType: 'participantType',
    joinedAt: 'joinedAt',
    leftAt: 'leftAt',
    isActive: 'isActive',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VideoParticipantScalarFieldEnum = (typeof VideoParticipantScalarFieldEnum)[keyof typeof VideoParticipantScalarFieldEnum]


  export const VideoRecordingScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    fileName: 'fileName',
    filePath: 'filePath',
    fileSize: 'fileSize',
    duration: 'duration',
    status: 'status',
    isActive: 'isActive',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VideoRecordingScalarFieldEnum = (typeof VideoRecordingScalarFieldEnum)[keyof typeof VideoRecordingScalarFieldEnum]


  export const VideoMessageScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    senderId: 'senderId',
    message: 'message',
    messageType: 'messageType',
    isActive: 'isActive',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VideoMessageScalarFieldEnum = (typeof VideoMessageScalarFieldEnum)[keyof typeof VideoMessageScalarFieldEnum]


  export const RadiologyOrderScalarFieldEnum: {
    id: 'id',
    consultationId: 'consultationId',
    patientId: 'patientId',
    doctorId: 'doctorId',
    modalityId: 'modalityId',
    studyType: 'studyType',
    priority: 'priority',
    reason: 'reason',
    clinicalHistory: 'clinicalHistory',
    status: 'status',
    scheduledAt: 'scheduledAt',
    completedAt: 'completedAt',
    isActive: 'isActive',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    studyId: 'studyId'
  };

  export type RadiologyOrderScalarFieldEnum = (typeof RadiologyOrderScalarFieldEnum)[keyof typeof RadiologyOrderScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'TenantType'
   */
  export type EnumTenantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantType'>
    


  /**
   * Reference to a field of type 'TenantType[]'
   */
  export type ListEnumTenantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantType[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'BloodType'
   */
  export type EnumBloodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BloodType'>
    


  /**
   * Reference to a field of type 'BloodType[]'
   */
  export type ListEnumBloodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BloodType[]'>
    


  /**
   * Reference to a field of type 'MaritalStatus'
   */
  export type EnumMaritalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaritalStatus'>
    


  /**
   * Reference to a field of type 'MaritalStatus[]'
   */
  export type ListEnumMaritalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaritalStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'InsuranceType'
   */
  export type EnumInsuranceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsuranceType'>
    


  /**
   * Reference to a field of type 'InsuranceType[]'
   */
  export type ListEnumInsuranceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsuranceType[]'>
    


  /**
   * Reference to a field of type 'AppointmentStatus'
   */
  export type EnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus'>
    


  /**
   * Reference to a field of type 'AppointmentStatus[]'
   */
  export type ListEnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus[]'>
    


  /**
   * Reference to a field of type 'PrescriptionStatus'
   */
  export type EnumPrescriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrescriptionStatus'>
    


  /**
   * Reference to a field of type 'PrescriptionStatus[]'
   */
  export type ListEnumPrescriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrescriptionStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'LabOrderStatus'
   */
  export type EnumLabOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LabOrderStatus'>
    


  /**
   * Reference to a field of type 'LabOrderStatus[]'
   */
  export type ListEnumLabOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LabOrderStatus[]'>
    


  /**
   * Reference to a field of type 'LabTestStatus'
   */
  export type EnumLabTestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LabTestStatus'>
    


  /**
   * Reference to a field of type 'LabTestStatus[]'
   */
  export type ListEnumLabTestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LabTestStatus[]'>
    


  /**
   * Reference to a field of type 'PharmacyOrderStatus'
   */
  export type EnumPharmacyOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PharmacyOrderStatus'>
    


  /**
   * Reference to a field of type 'PharmacyOrderStatus[]'
   */
  export type ListEnumPharmacyOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PharmacyOrderStatus[]'>
    


  /**
   * Reference to a field of type 'PharmacyItemStatus'
   */
  export type EnumPharmacyItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PharmacyItemStatus'>
    


  /**
   * Reference to a field of type 'PharmacyItemStatus[]'
   */
  export type ListEnumPharmacyItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PharmacyItemStatus[]'>
    


  /**
   * Reference to a field of type 'StudyStatus'
   */
  export type EnumStudyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudyStatus'>
    


  /**
   * Reference to a field of type 'StudyStatus[]'
   */
  export type ListEnumStudyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudyStatus[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus'>
    


  /**
   * Reference to a field of type 'ReportStatus[]'
   */
  export type ListEnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus[]'>
    


  /**
   * Reference to a field of type 'TelemedicineStatus'
   */
  export type EnumTelemedicineStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TelemedicineStatus'>
    


  /**
   * Reference to a field of type 'TelemedicineStatus[]'
   */
  export type ListEnumTelemedicineStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TelemedicineStatus[]'>
    


  /**
   * Reference to a field of type 'ConsultationType'
   */
  export type EnumConsultationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsultationType'>
    


  /**
   * Reference to a field of type 'ConsultationType[]'
   */
  export type ListEnumConsultationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConsultationType[]'>
    


  /**
   * Reference to a field of type 'VideoRoomStatus'
   */
  export type EnumVideoRoomStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VideoRoomStatus'>
    


  /**
   * Reference to a field of type 'VideoRoomStatus[]'
   */
  export type ListEnumVideoRoomStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VideoRoomStatus[]'>
    


  /**
   * Reference to a field of type 'ParticipantType'
   */
  export type EnumParticipantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParticipantType'>
    


  /**
   * Reference to a field of type 'ParticipantType[]'
   */
  export type ListEnumParticipantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ParticipantType[]'>
    


  /**
   * Reference to a field of type 'RecordingStatus'
   */
  export type EnumRecordingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecordingStatus'>
    


  /**
   * Reference to a field of type 'RecordingStatus[]'
   */
  export type ListEnumRecordingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecordingStatus[]'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'MessageType[]'
   */
  export type ListEnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType[]'>
    


  /**
   * Reference to a field of type 'RadiologyOrderStatus'
   */
  export type EnumRadiologyOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RadiologyOrderStatus'>
    


  /**
   * Reference to a field of type 'RadiologyOrderStatus[]'
   */
  export type ListEnumRadiologyOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RadiologyOrderStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    code?: StringNullableFilter<"Department"> | string | null
    description?: StringNullableFilter<"Department"> | string | null
    isActive?: BoolFilter<"Department"> | boolean
    tenantId?: StringFilter<"Department"> | string
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    appointments?: AppointmentListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    staff?: StaffListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    appointments?: AppointmentOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
    staff?: StaffOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    isActive?: BoolFilter<"Department"> | boolean
    tenantId?: StringFilter<"Department"> | string
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    appointments?: AppointmentListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    staff?: StaffListRelationFilter
  }, "id" | "code">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    code?: StringNullableWithAggregatesFilter<"Department"> | string | null
    description?: StringNullableWithAggregatesFilter<"Department"> | string | null
    isActive?: BoolWithAggregatesFilter<"Department"> | boolean
    tenantId?: StringWithAggregatesFilter<"Department"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type SpecialtyWhereInput = {
    AND?: SpecialtyWhereInput | SpecialtyWhereInput[]
    OR?: SpecialtyWhereInput[]
    NOT?: SpecialtyWhereInput | SpecialtyWhereInput[]
    id?: StringFilter<"Specialty"> | string
    name?: StringFilter<"Specialty"> | string
    code?: StringNullableFilter<"Specialty"> | string | null
    description?: StringNullableFilter<"Specialty"> | string | null
    isActive?: BoolFilter<"Specialty"> | boolean
    tenantId?: StringFilter<"Specialty"> | string
    createdAt?: DateTimeFilter<"Specialty"> | Date | string
    updatedAt?: DateTimeFilter<"Specialty"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type SpecialtyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type SpecialtyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: SpecialtyWhereInput | SpecialtyWhereInput[]
    OR?: SpecialtyWhereInput[]
    NOT?: SpecialtyWhereInput | SpecialtyWhereInput[]
    name?: StringFilter<"Specialty"> | string
    description?: StringNullableFilter<"Specialty"> | string | null
    isActive?: BoolFilter<"Specialty"> | boolean
    tenantId?: StringFilter<"Specialty"> | string
    createdAt?: DateTimeFilter<"Specialty"> | Date | string
    updatedAt?: DateTimeFilter<"Specialty"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "code">

  export type SpecialtyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SpecialtyCountOrderByAggregateInput
    _max?: SpecialtyMaxOrderByAggregateInput
    _min?: SpecialtyMinOrderByAggregateInput
  }

  export type SpecialtyScalarWhereWithAggregatesInput = {
    AND?: SpecialtyScalarWhereWithAggregatesInput | SpecialtyScalarWhereWithAggregatesInput[]
    OR?: SpecialtyScalarWhereWithAggregatesInput[]
    NOT?: SpecialtyScalarWhereWithAggregatesInput | SpecialtyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Specialty"> | string
    name?: StringWithAggregatesFilter<"Specialty"> | string
    code?: StringNullableWithAggregatesFilter<"Specialty"> | string | null
    description?: StringNullableWithAggregatesFilter<"Specialty"> | string | null
    isActive?: BoolWithAggregatesFilter<"Specialty"> | boolean
    tenantId?: StringWithAggregatesFilter<"Specialty"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Specialty"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Specialty"> | Date | string
  }

  export type StaffWhereInput = {
    AND?: StaffWhereInput | StaffWhereInput[]
    OR?: StaffWhereInput[]
    NOT?: StaffWhereInput | StaffWhereInput[]
    id?: StringFilter<"Staff"> | string
    userId?: StringFilter<"Staff"> | string
    employeeId?: StringNullableFilter<"Staff"> | string | null
    designation?: StringNullableFilter<"Staff"> | string | null
    departmentId?: StringNullableFilter<"Staff"> | string | null
    joiningDate?: DateTimeNullableFilter<"Staff"> | Date | string | null
    qualification?: StringNullableFilter<"Staff"> | string | null
    experience?: StringNullableFilter<"Staff"> | string | null
    isActive?: BoolFilter<"Staff"> | boolean
    tenantId?: StringFilter<"Staff"> | string
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Staff"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type StaffOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    designation?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    joiningDate?: SortOrderInput | SortOrder
    qualification?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type StaffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    employeeId?: string
    AND?: StaffWhereInput | StaffWhereInput[]
    OR?: StaffWhereInput[]
    NOT?: StaffWhereInput | StaffWhereInput[]
    designation?: StringNullableFilter<"Staff"> | string | null
    departmentId?: StringNullableFilter<"Staff"> | string | null
    joiningDate?: DateTimeNullableFilter<"Staff"> | Date | string | null
    qualification?: StringNullableFilter<"Staff"> | string | null
    experience?: StringNullableFilter<"Staff"> | string | null
    isActive?: BoolFilter<"Staff"> | boolean
    tenantId?: StringFilter<"Staff"> | string
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Staff"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId" | "employeeId">

  export type StaffOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrderInput | SortOrder
    designation?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    joiningDate?: SortOrderInput | SortOrder
    qualification?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StaffCountOrderByAggregateInput
    _max?: StaffMaxOrderByAggregateInput
    _min?: StaffMinOrderByAggregateInput
  }

  export type StaffScalarWhereWithAggregatesInput = {
    AND?: StaffScalarWhereWithAggregatesInput | StaffScalarWhereWithAggregatesInput[]
    OR?: StaffScalarWhereWithAggregatesInput[]
    NOT?: StaffScalarWhereWithAggregatesInput | StaffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Staff"> | string
    userId?: StringWithAggregatesFilter<"Staff"> | string
    employeeId?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    designation?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    departmentId?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    joiningDate?: DateTimeNullableWithAggregatesFilter<"Staff"> | Date | string | null
    qualification?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    experience?: StringNullableWithAggregatesFilter<"Staff"> | string | null
    isActive?: BoolWithAggregatesFilter<"Staff"> | boolean
    tenantId?: StringWithAggregatesFilter<"Staff"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Staff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Staff"> | Date | string
  }

  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    slug?: StringFilter<"Tenant"> | string
    type?: EnumTenantTypeFilter<"Tenant"> | $Enums.TenantType
    address?: StringNullableFilter<"Tenant"> | string | null
    phone?: StringNullableFilter<"Tenant"> | string | null
    email?: StringNullableFilter<"Tenant"> | string | null
    logo?: StringNullableFilter<"Tenant"> | string | null
    deletedAt?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    isActive?: BoolFilter<"Tenant"> | boolean
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    appointments?: AppointmentListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    departments?: DepartmentListRelationFilter
    invoices?: InvoiceListRelationFilter
    invoiceItems?: InvoiceItemListRelationFilter
    labOrders?: LabOrderListRelationFilter
    labOrderTests?: LabOrderTestListRelationFilter
    labTests?: LabTestListRelationFilter
    medicalRecords?: MedicalRecordListRelationFilter
    medications?: MedicationListRelationFilter
    payments?: PaymentListRelationFilter
    pharmacyOrders?: PharmacyOrderListRelationFilter
    pharmacyOrderItems?: PharmacyOrderItemListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    prescriptionItems?: PrescriptionItemListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    specialties?: SpecialtyListRelationFilter
    staff?: StaffListRelationFilter
    users?: UserListRelationFilter
    patients?: PatientListRelationFilter
    studies?: StudyListRelationFilter
    radReports?: RadReportListRelationFilter
    reportTemplates?: ReportTemplateListRelationFilter
    telemedicineConsultations?: TelemedicineConsultationListRelationFilter
    videoRooms?: VideoRoomListRelationFilter
    videoParticipants?: VideoParticipantListRelationFilter
    videoRecordings?: VideoRecordingListRelationFilter
    videoMessages?: VideoMessageListRelationFilter
    radiologyOrders?: RadiologyOrderListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    appointments?: AppointmentOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    departments?: DepartmentOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    invoiceItems?: InvoiceItemOrderByRelationAggregateInput
    labOrders?: LabOrderOrderByRelationAggregateInput
    labOrderTests?: LabOrderTestOrderByRelationAggregateInput
    labTests?: LabTestOrderByRelationAggregateInput
    medicalRecords?: MedicalRecordOrderByRelationAggregateInput
    medications?: MedicationOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    pharmacyOrders?: PharmacyOrderOrderByRelationAggregateInput
    pharmacyOrderItems?: PharmacyOrderItemOrderByRelationAggregateInput
    prescriptions?: PrescriptionOrderByRelationAggregateInput
    prescriptionItems?: PrescriptionItemOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    specialties?: SpecialtyOrderByRelationAggregateInput
    staff?: StaffOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    patients?: PatientOrderByRelationAggregateInput
    studies?: StudyOrderByRelationAggregateInput
    radReports?: RadReportOrderByRelationAggregateInput
    reportTemplates?: ReportTemplateOrderByRelationAggregateInput
    telemedicineConsultations?: TelemedicineConsultationOrderByRelationAggregateInput
    videoRooms?: VideoRoomOrderByRelationAggregateInput
    videoParticipants?: VideoParticipantOrderByRelationAggregateInput
    videoRecordings?: VideoRecordingOrderByRelationAggregateInput
    videoMessages?: VideoMessageOrderByRelationAggregateInput
    radiologyOrders?: RadiologyOrderOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    type?: EnumTenantTypeFilter<"Tenant"> | $Enums.TenantType
    address?: StringNullableFilter<"Tenant"> | string | null
    phone?: StringNullableFilter<"Tenant"> | string | null
    email?: StringNullableFilter<"Tenant"> | string | null
    logo?: StringNullableFilter<"Tenant"> | string | null
    deletedAt?: DateTimeNullableFilter<"Tenant"> | Date | string | null
    isActive?: BoolFilter<"Tenant"> | boolean
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    appointments?: AppointmentListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    departments?: DepartmentListRelationFilter
    invoices?: InvoiceListRelationFilter
    invoiceItems?: InvoiceItemListRelationFilter
    labOrders?: LabOrderListRelationFilter
    labOrderTests?: LabOrderTestListRelationFilter
    labTests?: LabTestListRelationFilter
    medicalRecords?: MedicalRecordListRelationFilter
    medications?: MedicationListRelationFilter
    payments?: PaymentListRelationFilter
    pharmacyOrders?: PharmacyOrderListRelationFilter
    pharmacyOrderItems?: PharmacyOrderItemListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    prescriptionItems?: PrescriptionItemListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    specialties?: SpecialtyListRelationFilter
    staff?: StaffListRelationFilter
    users?: UserListRelationFilter
    patients?: PatientListRelationFilter
    studies?: StudyListRelationFilter
    radReports?: RadReportListRelationFilter
    reportTemplates?: ReportTemplateListRelationFilter
    telemedicineConsultations?: TelemedicineConsultationListRelationFilter
    videoRooms?: VideoRoomListRelationFilter
    videoParticipants?: VideoParticipantListRelationFilter
    videoRecordings?: VideoRecordingListRelationFilter
    videoMessages?: VideoMessageListRelationFilter
    radiologyOrders?: RadiologyOrderListRelationFilter
  }, "id" | "slug">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    slug?: StringWithAggregatesFilter<"Tenant"> | string
    type?: EnumTenantTypeWithAggregatesFilter<"Tenant"> | $Enums.TenantType
    address?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    email?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Tenant"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"Tenant"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    specialization?: StringNullableFilter<"User"> | string | null
    experience?: IntNullableFilter<"User"> | number | null
    licenseNumber?: StringNullableFilter<"User"> | string | null
    signature?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    tenantId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    doctorAppointments?: AppointmentListRelationFilter
    doctorLabOrders?: LabOrderListRelationFilter
    doctorPrescriptions?: PharmacyOrderListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    doctorTelemedicine?: TelemedicineConsultationListRelationFilter
    doctorRadiologyOrders?: RadiologyOrderListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    staff?: XOR<StaffNullableScalarRelationFilter, StaffWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
    createdMedicalRecords?: MedicalRecordListRelationFilter
    updatedMedicalRecords?: MedicalRecordListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    specialization?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    signature?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctorAppointments?: AppointmentOrderByRelationAggregateInput
    doctorLabOrders?: LabOrderOrderByRelationAggregateInput
    doctorPrescriptions?: PharmacyOrderOrderByRelationAggregateInput
    prescriptions?: PrescriptionOrderByRelationAggregateInput
    doctorTelemedicine?: TelemedicineConsultationOrderByRelationAggregateInput
    doctorRadiologyOrders?: RadiologyOrderOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    staff?: StaffOrderByWithRelationInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    createdMedicalRecords?: MedicalRecordOrderByRelationAggregateInput
    updatedMedicalRecords?: MedicalRecordOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    specialization?: StringNullableFilter<"User"> | string | null
    experience?: IntNullableFilter<"User"> | number | null
    licenseNumber?: StringNullableFilter<"User"> | string | null
    signature?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    tenantId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    doctorAppointments?: AppointmentListRelationFilter
    doctorLabOrders?: LabOrderListRelationFilter
    doctorPrescriptions?: PharmacyOrderListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    doctorTelemedicine?: TelemedicineConsultationListRelationFilter
    doctorRadiologyOrders?: RadiologyOrderListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    staff?: XOR<StaffNullableScalarRelationFilter, StaffWhereInput> | null
    auditLogs?: AuditLogListRelationFilter
    createdMedicalRecords?: MedicalRecordListRelationFilter
    updatedMedicalRecords?: MedicalRecordListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    specialization?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    signature?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    specialization?: StringNullableWithAggregatesFilter<"User"> | string | null
    experience?: IntNullableWithAggregatesFilter<"User"> | number | null
    licenseNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    signature?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    tenantId?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    jti?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    ipAddress?: StringNullableFilter<"RefreshToken"> | string | null
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    tenantId?: StringFilter<"RefreshToken"> | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    jti?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    revoked?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jti?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    ipAddress?: StringNullableFilter<"RefreshToken"> | string | null
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    tenantId?: StringFilter<"RefreshToken"> | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "jti">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    jti?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    revoked?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    jti?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    revoked?: BoolWithAggregatesFilter<"RefreshToken"> | boolean
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
    tenantId?: StringWithAggregatesFilter<"RefreshToken"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: StringFilter<"Patient"> | string
    medicalRecordNumber?: StringFilter<"Patient"> | string
    registrationNumber?: StringNullableFilter<"Patient"> | string | null
    externalId?: StringNullableFilter<"Patient"> | string | null
    firstName?: StringFilter<"Patient"> | string
    middleName?: StringNullableFilter<"Patient"> | string | null
    lastName?: StringFilter<"Patient"> | string
    dateOfBirth?: DateTimeNullableFilter<"Patient"> | Date | string | null
    gender?: EnumGenderNullableFilter<"Patient"> | $Enums.Gender | null
    bloodType?: EnumBloodTypeNullableFilter<"Patient"> | $Enums.BloodType | null
    maritalStatus?: EnumMaritalStatusNullableFilter<"Patient"> | $Enums.MaritalStatus | null
    email?: StringNullableFilter<"Patient"> | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    city?: StringNullableFilter<"Patient"> | string | null
    state?: StringNullableFilter<"Patient"> | string | null
    country?: StringNullableFilter<"Patient"> | string | null
    pincode?: StringNullableFilter<"Patient"> | string | null
    phoneVerified?: BoolFilter<"Patient"> | boolean
    emailVerified?: BoolFilter<"Patient"> | boolean
    allergies?: JsonNullableFilter<"Patient">
    chronicConditions?: JsonNullableFilter<"Patient">
    currentMedications?: JsonNullableFilter<"Patient">
    knownAllergies?: JsonNullableFilter<"Patient">
    familyHistory?: JsonNullableFilter<"Patient">
    insuranceProvider?: StringNullableFilter<"Patient"> | string | null
    insuranceId?: StringNullableFilter<"Patient"> | string | null
    insuranceGroup?: StringNullableFilter<"Patient"> | string | null
    insuranceValidUntil?: DateTimeNullableFilter<"Patient"> | Date | string | null
    insuranceType?: EnumInsuranceTypeNullableFilter<"Patient"> | $Enums.InsuranceType | null
    tenantId?: StringFilter<"Patient"> | string
    createdBy?: StringNullableFilter<"Patient"> | string | null
    updatedBy?: StringNullableFilter<"Patient"> | string | null
    isActive?: BoolFilter<"Patient"> | boolean
    isVerified?: BoolFilter<"Patient"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    appointments?: AppointmentListRelationFilter
    invoices?: InvoiceListRelationFilter
    labOrders?: LabOrderListRelationFilter
    medicalRecords?: MedicalRecordListRelationFilter
    pharmacyOrders?: PharmacyOrderListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    prescriptionItems?: PrescriptionItemListRelationFilter
    studies?: StudyListRelationFilter
    telemedicineConsultations?: TelemedicineConsultationListRelationFilter
    radiologyOrders?: RadiologyOrderListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    medicalRecordNumber?: SortOrder
    registrationNumber?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    bloodType?: SortOrderInput | SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    phoneVerified?: SortOrder
    emailVerified?: SortOrder
    allergies?: SortOrderInput | SortOrder
    chronicConditions?: SortOrderInput | SortOrder
    currentMedications?: SortOrderInput | SortOrder
    knownAllergies?: SortOrderInput | SortOrder
    familyHistory?: SortOrderInput | SortOrder
    insuranceProvider?: SortOrderInput | SortOrder
    insuranceId?: SortOrderInput | SortOrder
    insuranceGroup?: SortOrderInput | SortOrder
    insuranceValidUntil?: SortOrderInput | SortOrder
    insuranceType?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    appointments?: AppointmentOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    labOrders?: LabOrderOrderByRelationAggregateInput
    medicalRecords?: MedicalRecordOrderByRelationAggregateInput
    pharmacyOrders?: PharmacyOrderOrderByRelationAggregateInput
    prescriptions?: PrescriptionOrderByRelationAggregateInput
    prescriptionItems?: PrescriptionItemOrderByRelationAggregateInput
    studies?: StudyOrderByRelationAggregateInput
    telemedicineConsultations?: TelemedicineConsultationOrderByRelationAggregateInput
    radiologyOrders?: RadiologyOrderOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    medicalRecordNumber?: string
    registrationNumber?: string
    externalId?: string
    email?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    firstName?: StringFilter<"Patient"> | string
    middleName?: StringNullableFilter<"Patient"> | string | null
    lastName?: StringFilter<"Patient"> | string
    dateOfBirth?: DateTimeNullableFilter<"Patient"> | Date | string | null
    gender?: EnumGenderNullableFilter<"Patient"> | $Enums.Gender | null
    bloodType?: EnumBloodTypeNullableFilter<"Patient"> | $Enums.BloodType | null
    maritalStatus?: EnumMaritalStatusNullableFilter<"Patient"> | $Enums.MaritalStatus | null
    phone?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    city?: StringNullableFilter<"Patient"> | string | null
    state?: StringNullableFilter<"Patient"> | string | null
    country?: StringNullableFilter<"Patient"> | string | null
    pincode?: StringNullableFilter<"Patient"> | string | null
    phoneVerified?: BoolFilter<"Patient"> | boolean
    emailVerified?: BoolFilter<"Patient"> | boolean
    allergies?: JsonNullableFilter<"Patient">
    chronicConditions?: JsonNullableFilter<"Patient">
    currentMedications?: JsonNullableFilter<"Patient">
    knownAllergies?: JsonNullableFilter<"Patient">
    familyHistory?: JsonNullableFilter<"Patient">
    insuranceProvider?: StringNullableFilter<"Patient"> | string | null
    insuranceId?: StringNullableFilter<"Patient"> | string | null
    insuranceGroup?: StringNullableFilter<"Patient"> | string | null
    insuranceValidUntil?: DateTimeNullableFilter<"Patient"> | Date | string | null
    insuranceType?: EnumInsuranceTypeNullableFilter<"Patient"> | $Enums.InsuranceType | null
    tenantId?: StringFilter<"Patient"> | string
    createdBy?: StringNullableFilter<"Patient"> | string | null
    updatedBy?: StringNullableFilter<"Patient"> | string | null
    isActive?: BoolFilter<"Patient"> | boolean
    isVerified?: BoolFilter<"Patient"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    appointments?: AppointmentListRelationFilter
    invoices?: InvoiceListRelationFilter
    labOrders?: LabOrderListRelationFilter
    medicalRecords?: MedicalRecordListRelationFilter
    pharmacyOrders?: PharmacyOrderListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    prescriptionItems?: PrescriptionItemListRelationFilter
    studies?: StudyListRelationFilter
    telemedicineConsultations?: TelemedicineConsultationListRelationFilter
    radiologyOrders?: RadiologyOrderListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "medicalRecordNumber" | "registrationNumber" | "externalId" | "email">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    medicalRecordNumber?: SortOrder
    registrationNumber?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    bloodType?: SortOrderInput | SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    phoneVerified?: SortOrder
    emailVerified?: SortOrder
    allergies?: SortOrderInput | SortOrder
    chronicConditions?: SortOrderInput | SortOrder
    currentMedications?: SortOrderInput | SortOrder
    knownAllergies?: SortOrderInput | SortOrder
    familyHistory?: SortOrderInput | SortOrder
    insuranceProvider?: SortOrderInput | SortOrder
    insuranceId?: SortOrderInput | SortOrder
    insuranceGroup?: SortOrderInput | SortOrder
    insuranceValidUntil?: SortOrderInput | SortOrder
    insuranceType?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PatientCountOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Patient"> | string
    medicalRecordNumber?: StringWithAggregatesFilter<"Patient"> | string
    registrationNumber?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    externalId?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    firstName?: StringWithAggregatesFilter<"Patient"> | string
    middleName?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    lastName?: StringWithAggregatesFilter<"Patient"> | string
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    gender?: EnumGenderNullableWithAggregatesFilter<"Patient"> | $Enums.Gender | null
    bloodType?: EnumBloodTypeNullableWithAggregatesFilter<"Patient"> | $Enums.BloodType | null
    maritalStatus?: EnumMaritalStatusNullableWithAggregatesFilter<"Patient"> | $Enums.MaritalStatus | null
    email?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    address?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    city?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    state?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    country?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    pincode?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    phoneVerified?: BoolWithAggregatesFilter<"Patient"> | boolean
    emailVerified?: BoolWithAggregatesFilter<"Patient"> | boolean
    allergies?: JsonNullableWithAggregatesFilter<"Patient">
    chronicConditions?: JsonNullableWithAggregatesFilter<"Patient">
    currentMedications?: JsonNullableWithAggregatesFilter<"Patient">
    knownAllergies?: JsonNullableWithAggregatesFilter<"Patient">
    familyHistory?: JsonNullableWithAggregatesFilter<"Patient">
    insuranceProvider?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    insuranceId?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    insuranceGroup?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    insuranceValidUntil?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    insuranceType?: EnumInsuranceTypeNullableWithAggregatesFilter<"Patient"> | $Enums.InsuranceType | null
    tenantId?: StringWithAggregatesFilter<"Patient"> | string
    createdBy?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    isActive?: BoolWithAggregatesFilter<"Patient"> | boolean
    isVerified?: BoolWithAggregatesFilter<"Patient"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: StringFilter<"Appointment"> | string
    patientId?: StringFilter<"Appointment"> | string
    doctorId?: StringFilter<"Appointment"> | string
    departmentId?: StringNullableFilter<"Appointment"> | string | null
    startTime?: DateTimeFilter<"Appointment"> | Date | string
    endTime?: DateTimeFilter<"Appointment"> | Date | string
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    reason?: StringNullableFilter<"Appointment"> | string | null
    notes?: StringNullableFilter<"Appointment"> | string | null
    tenantId?: StringFilter<"Appointment"> | string
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    doctor?: XOR<UserScalarRelationFilter, UserWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    doctor?: UserOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    patientId?: StringFilter<"Appointment"> | string
    doctorId?: StringFilter<"Appointment"> | string
    departmentId?: StringNullableFilter<"Appointment"> | string | null
    startTime?: DateTimeFilter<"Appointment"> | Date | string
    endTime?: DateTimeFilter<"Appointment"> | Date | string
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    reason?: StringNullableFilter<"Appointment"> | string | null
    notes?: StringNullableFilter<"Appointment"> | string | null
    tenantId?: StringFilter<"Appointment"> | string
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    doctor?: XOR<UserScalarRelationFilter, UserWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Appointment"> | string
    patientId?: StringWithAggregatesFilter<"Appointment"> | string
    doctorId?: StringWithAggregatesFilter<"Appointment"> | string
    departmentId?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    status?: EnumAppointmentStatusWithAggregatesFilter<"Appointment"> | $Enums.AppointmentStatus
    reason?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    tenantId?: StringWithAggregatesFilter<"Appointment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
  }

  export type PrescriptionWhereInput = {
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    id?: StringFilter<"Prescription"> | string
    patientId?: StringFilter<"Prescription"> | string
    doctorId?: StringFilter<"Prescription"> | string
    diagnosis?: StringNullableFilter<"Prescription"> | string | null
    notes?: StringNullableFilter<"Prescription"> | string | null
    status?: EnumPrescriptionStatusFilter<"Prescription"> | $Enums.PrescriptionStatus
    tenantId?: StringFilter<"Prescription"> | string
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    updatedAt?: DateTimeFilter<"Prescription"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    doctor?: XOR<UserScalarRelationFilter, UserWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    prescriptionItems?: PrescriptionItemListRelationFilter
  }

  export type PrescriptionOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    diagnosis?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    doctor?: UserOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    prescriptionItems?: PrescriptionItemOrderByRelationAggregateInput
  }

  export type PrescriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    patientId?: StringFilter<"Prescription"> | string
    doctorId?: StringFilter<"Prescription"> | string
    diagnosis?: StringNullableFilter<"Prescription"> | string | null
    notes?: StringNullableFilter<"Prescription"> | string | null
    status?: EnumPrescriptionStatusFilter<"Prescription"> | $Enums.PrescriptionStatus
    tenantId?: StringFilter<"Prescription"> | string
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    updatedAt?: DateTimeFilter<"Prescription"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    doctor?: XOR<UserScalarRelationFilter, UserWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    prescriptionItems?: PrescriptionItemListRelationFilter
  }, "id">

  export type PrescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    diagnosis?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PrescriptionCountOrderByAggregateInput
    _max?: PrescriptionMaxOrderByAggregateInput
    _min?: PrescriptionMinOrderByAggregateInput
  }

  export type PrescriptionScalarWhereWithAggregatesInput = {
    AND?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    OR?: PrescriptionScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Prescription"> | string
    patientId?: StringWithAggregatesFilter<"Prescription"> | string
    doctorId?: StringWithAggregatesFilter<"Prescription"> | string
    diagnosis?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
    status?: EnumPrescriptionStatusWithAggregatesFilter<"Prescription"> | $Enums.PrescriptionStatus
    tenantId?: StringWithAggregatesFilter<"Prescription"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Prescription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Prescription"> | Date | string
  }

  export type PrescriptionItemWhereInput = {
    AND?: PrescriptionItemWhereInput | PrescriptionItemWhereInput[]
    OR?: PrescriptionItemWhereInput[]
    NOT?: PrescriptionItemWhereInput | PrescriptionItemWhereInput[]
    id?: StringFilter<"PrescriptionItem"> | string
    prescriptionId?: StringFilter<"PrescriptionItem"> | string
    medicationId?: StringFilter<"PrescriptionItem"> | string
    patientId?: StringFilter<"PrescriptionItem"> | string
    dosage?: StringFilter<"PrescriptionItem"> | string
    frequency?: StringFilter<"PrescriptionItem"> | string
    duration?: StringFilter<"PrescriptionItem"> | string
    instructions?: StringNullableFilter<"PrescriptionItem"> | string | null
    isDispensed?: BoolFilter<"PrescriptionItem"> | boolean
    tenantId?: StringFilter<"PrescriptionItem"> | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    medication?: XOR<MedicationScalarRelationFilter, MedicationWhereInput>
    prescription?: XOR<PrescriptionScalarRelationFilter, PrescriptionWhereInput>
  }

  export type PrescriptionItemOrderByWithRelationInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    medicationId?: SortOrder
    patientId?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instructions?: SortOrderInput | SortOrder
    isDispensed?: SortOrder
    tenantId?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    medication?: MedicationOrderByWithRelationInput
    prescription?: PrescriptionOrderByWithRelationInput
  }

  export type PrescriptionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrescriptionItemWhereInput | PrescriptionItemWhereInput[]
    OR?: PrescriptionItemWhereInput[]
    NOT?: PrescriptionItemWhereInput | PrescriptionItemWhereInput[]
    prescriptionId?: StringFilter<"PrescriptionItem"> | string
    medicationId?: StringFilter<"PrescriptionItem"> | string
    patientId?: StringFilter<"PrescriptionItem"> | string
    dosage?: StringFilter<"PrescriptionItem"> | string
    frequency?: StringFilter<"PrescriptionItem"> | string
    duration?: StringFilter<"PrescriptionItem"> | string
    instructions?: StringNullableFilter<"PrescriptionItem"> | string | null
    isDispensed?: BoolFilter<"PrescriptionItem"> | boolean
    tenantId?: StringFilter<"PrescriptionItem"> | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    medication?: XOR<MedicationScalarRelationFilter, MedicationWhereInput>
    prescription?: XOR<PrescriptionScalarRelationFilter, PrescriptionWhereInput>
  }, "id">

  export type PrescriptionItemOrderByWithAggregationInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    medicationId?: SortOrder
    patientId?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instructions?: SortOrderInput | SortOrder
    isDispensed?: SortOrder
    tenantId?: SortOrder
    _count?: PrescriptionItemCountOrderByAggregateInput
    _max?: PrescriptionItemMaxOrderByAggregateInput
    _min?: PrescriptionItemMinOrderByAggregateInput
  }

  export type PrescriptionItemScalarWhereWithAggregatesInput = {
    AND?: PrescriptionItemScalarWhereWithAggregatesInput | PrescriptionItemScalarWhereWithAggregatesInput[]
    OR?: PrescriptionItemScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionItemScalarWhereWithAggregatesInput | PrescriptionItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    prescriptionId?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    medicationId?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    patientId?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    dosage?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    frequency?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    duration?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    instructions?: StringNullableWithAggregatesFilter<"PrescriptionItem"> | string | null
    isDispensed?: BoolWithAggregatesFilter<"PrescriptionItem"> | boolean
    tenantId?: StringWithAggregatesFilter<"PrescriptionItem"> | string
  }

  export type MedicalRecordWhereInput = {
    AND?: MedicalRecordWhereInput | MedicalRecordWhereInput[]
    OR?: MedicalRecordWhereInput[]
    NOT?: MedicalRecordWhereInput | MedicalRecordWhereInput[]
    id?: StringFilter<"MedicalRecord"> | string
    patientId?: StringFilter<"MedicalRecord"> | string
    recordType?: StringFilter<"MedicalRecord"> | string
    title?: StringFilter<"MedicalRecord"> | string
    description?: StringNullableFilter<"MedicalRecord"> | string | null
    date?: DateTimeFilter<"MedicalRecord"> | Date | string
    doctorId?: StringNullableFilter<"MedicalRecord"> | string | null
    updatedById?: StringNullableFilter<"MedicalRecord"> | string | null
    isActive?: BoolFilter<"MedicalRecord"> | boolean
    tenantId?: StringFilter<"MedicalRecord"> | string
    createdAt?: DateTimeFilter<"MedicalRecord"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalRecord"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type MedicalRecordOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    recordType?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    doctor?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
  }

  export type MedicalRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicalRecordWhereInput | MedicalRecordWhereInput[]
    OR?: MedicalRecordWhereInput[]
    NOT?: MedicalRecordWhereInput | MedicalRecordWhereInput[]
    patientId?: StringFilter<"MedicalRecord"> | string
    recordType?: StringFilter<"MedicalRecord"> | string
    title?: StringFilter<"MedicalRecord"> | string
    description?: StringNullableFilter<"MedicalRecord"> | string | null
    date?: DateTimeFilter<"MedicalRecord"> | Date | string
    doctorId?: StringNullableFilter<"MedicalRecord"> | string | null
    updatedById?: StringNullableFilter<"MedicalRecord"> | string | null
    isActive?: BoolFilter<"MedicalRecord"> | boolean
    tenantId?: StringFilter<"MedicalRecord"> | string
    createdAt?: DateTimeFilter<"MedicalRecord"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalRecord"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type MedicalRecordOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    recordType?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicalRecordCountOrderByAggregateInput
    _max?: MedicalRecordMaxOrderByAggregateInput
    _min?: MedicalRecordMinOrderByAggregateInput
  }

  export type MedicalRecordScalarWhereWithAggregatesInput = {
    AND?: MedicalRecordScalarWhereWithAggregatesInput | MedicalRecordScalarWhereWithAggregatesInput[]
    OR?: MedicalRecordScalarWhereWithAggregatesInput[]
    NOT?: MedicalRecordScalarWhereWithAggregatesInput | MedicalRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicalRecord"> | string
    patientId?: StringWithAggregatesFilter<"MedicalRecord"> | string
    recordType?: StringWithAggregatesFilter<"MedicalRecord"> | string
    title?: StringWithAggregatesFilter<"MedicalRecord"> | string
    description?: StringNullableWithAggregatesFilter<"MedicalRecord"> | string | null
    date?: DateTimeWithAggregatesFilter<"MedicalRecord"> | Date | string
    doctorId?: StringNullableWithAggregatesFilter<"MedicalRecord"> | string | null
    updatedById?: StringNullableWithAggregatesFilter<"MedicalRecord"> | string | null
    isActive?: BoolWithAggregatesFilter<"MedicalRecord"> | boolean
    tenantId?: StringWithAggregatesFilter<"MedicalRecord"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MedicalRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicalRecord"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    patientId?: StringFilter<"Invoice"> | string
    date?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    subTotal?: FloatFilter<"Invoice"> | number
    taxAmount?: FloatFilter<"Invoice"> | number
    discountAmount?: FloatFilter<"Invoice"> | number
    totalAmount?: FloatFilter<"Invoice"> | number
    notes?: StringNullableFilter<"Invoice"> | string | null
    tenantId?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    createdBy?: StringNullableFilter<"Invoice"> | string | null
    updatedBy?: StringNullableFilter<"Invoice"> | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    invoiceItems?: InvoiceItemListRelationFilter
    payments?: PaymentListRelationFilter
    pharmacyOrder?: XOR<PharmacyOrderNullableScalarRelationFilter, PharmacyOrderWhereInput> | null
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    subTotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    invoiceItems?: InvoiceItemOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    pharmacyOrder?: PharmacyOrderOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    patientId?: StringFilter<"Invoice"> | string
    date?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    subTotal?: FloatFilter<"Invoice"> | number
    taxAmount?: FloatFilter<"Invoice"> | number
    discountAmount?: FloatFilter<"Invoice"> | number
    totalAmount?: FloatFilter<"Invoice"> | number
    notes?: StringNullableFilter<"Invoice"> | string | null
    tenantId?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    createdBy?: StringNullableFilter<"Invoice"> | string | null
    updatedBy?: StringNullableFilter<"Invoice"> | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    invoiceItems?: InvoiceItemListRelationFilter
    payments?: PaymentListRelationFilter
    pharmacyOrder?: XOR<PharmacyOrderNullableScalarRelationFilter, PharmacyOrderWhereInput> | null
  }, "id" | "invoiceNumber">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    subTotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    patientId?: StringWithAggregatesFilter<"Invoice"> | string
    date?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    subTotal?: FloatWithAggregatesFilter<"Invoice"> | number
    taxAmount?: FloatWithAggregatesFilter<"Invoice"> | number
    discountAmount?: FloatWithAggregatesFilter<"Invoice"> | number
    totalAmount?: FloatWithAggregatesFilter<"Invoice"> | number
    notes?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    tenantId?: StringWithAggregatesFilter<"Invoice"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
  }

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoiceId?: StringFilter<"InvoiceItem"> | string
    itemType?: StringFilter<"InvoiceItem"> | string
    itemId?: StringFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    unitPrice?: FloatFilter<"InvoiceItem"> | number
    discount?: FloatFilter<"InvoiceItem"> | number
    taxRate?: FloatFilter<"InvoiceItem"> | number
    totalAmount?: FloatFilter<"InvoiceItem"> | number
    tenantId?: StringFilter<"InvoiceItem"> | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    taxRate?: SortOrder
    totalAmount?: SortOrder
    tenantId?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    invoiceId?: StringFilter<"InvoiceItem"> | string
    itemType?: StringFilter<"InvoiceItem"> | string
    itemId?: StringFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    unitPrice?: FloatFilter<"InvoiceItem"> | number
    discount?: FloatFilter<"InvoiceItem"> | number
    taxRate?: FloatFilter<"InvoiceItem"> | number
    totalAmount?: FloatFilter<"InvoiceItem"> | number
    tenantId?: StringFilter<"InvoiceItem"> | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }, "id">

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    taxRate?: SortOrder
    totalAmount?: SortOrder
    tenantId?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceItem"> | string
    invoiceId?: StringWithAggregatesFilter<"InvoiceItem"> | string
    itemType?: StringWithAggregatesFilter<"InvoiceItem"> | string
    itemId?: StringWithAggregatesFilter<"InvoiceItem"> | string
    description?: StringWithAggregatesFilter<"InvoiceItem"> | string
    quantity?: IntWithAggregatesFilter<"InvoiceItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    discount?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    taxRate?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    totalAmount?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    tenantId?: StringWithAggregatesFilter<"InvoiceItem"> | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    paymentNumber?: StringFilter<"Payment"> | string
    invoiceId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    referenceNumber?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    tenantId?: StringFilter<"Payment"> | string
    createdBy?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    paymentNumber?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    paymentNumber?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    invoiceId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    referenceNumber?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    tenantId?: StringFilter<"Payment"> | string
    createdBy?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }, "id" | "paymentNumber">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    paymentNumber?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    paymentNumber?: StringWithAggregatesFilter<"Payment"> | string
    invoiceId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    paymentDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    referenceNumber?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    tenantId?: StringWithAggregatesFilter<"Payment"> | string
    createdBy?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type LabTestWhereInput = {
    AND?: LabTestWhereInput | LabTestWhereInput[]
    OR?: LabTestWhereInput[]
    NOT?: LabTestWhereInput | LabTestWhereInput[]
    id?: StringFilter<"LabTest"> | string
    name?: StringFilter<"LabTest"> | string
    code?: StringFilter<"LabTest"> | string
    description?: StringNullableFilter<"LabTest"> | string | null
    category?: StringFilter<"LabTest"> | string
    price?: FloatNullableFilter<"LabTest"> | number | null
    isActive?: BoolFilter<"LabTest"> | boolean
    tenantId?: StringFilter<"LabTest"> | string
    createdAt?: DateTimeFilter<"LabTest"> | Date | string
    updatedAt?: DateTimeFilter<"LabTest"> | Date | string
    labOrders?: LabOrderTestListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type LabTestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    price?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    labOrders?: LabOrderTestOrderByRelationAggregateInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type LabTestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: LabTestWhereInput | LabTestWhereInput[]
    OR?: LabTestWhereInput[]
    NOT?: LabTestWhereInput | LabTestWhereInput[]
    name?: StringFilter<"LabTest"> | string
    description?: StringNullableFilter<"LabTest"> | string | null
    category?: StringFilter<"LabTest"> | string
    price?: FloatNullableFilter<"LabTest"> | number | null
    isActive?: BoolFilter<"LabTest"> | boolean
    tenantId?: StringFilter<"LabTest"> | string
    createdAt?: DateTimeFilter<"LabTest"> | Date | string
    updatedAt?: DateTimeFilter<"LabTest"> | Date | string
    labOrders?: LabOrderTestListRelationFilter
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "code">

  export type LabTestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    price?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LabTestCountOrderByAggregateInput
    _avg?: LabTestAvgOrderByAggregateInput
    _max?: LabTestMaxOrderByAggregateInput
    _min?: LabTestMinOrderByAggregateInput
    _sum?: LabTestSumOrderByAggregateInput
  }

  export type LabTestScalarWhereWithAggregatesInput = {
    AND?: LabTestScalarWhereWithAggregatesInput | LabTestScalarWhereWithAggregatesInput[]
    OR?: LabTestScalarWhereWithAggregatesInput[]
    NOT?: LabTestScalarWhereWithAggregatesInput | LabTestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LabTest"> | string
    name?: StringWithAggregatesFilter<"LabTest"> | string
    code?: StringWithAggregatesFilter<"LabTest"> | string
    description?: StringNullableWithAggregatesFilter<"LabTest"> | string | null
    category?: StringWithAggregatesFilter<"LabTest"> | string
    price?: FloatNullableWithAggregatesFilter<"LabTest"> | number | null
    isActive?: BoolWithAggregatesFilter<"LabTest"> | boolean
    tenantId?: StringWithAggregatesFilter<"LabTest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LabTest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LabTest"> | Date | string
  }

  export type LabOrderWhereInput = {
    AND?: LabOrderWhereInput | LabOrderWhereInput[]
    OR?: LabOrderWhereInput[]
    NOT?: LabOrderWhereInput | LabOrderWhereInput[]
    id?: StringFilter<"LabOrder"> | string
    orderNumber?: StringFilter<"LabOrder"> | string
    patientId?: StringFilter<"LabOrder"> | string
    doctorId?: StringNullableFilter<"LabOrder"> | string | null
    status?: EnumLabOrderStatusFilter<"LabOrder"> | $Enums.LabOrderStatus
    orderDate?: DateTimeFilter<"LabOrder"> | Date | string
    completedDate?: DateTimeNullableFilter<"LabOrder"> | Date | string | null
    notes?: StringNullableFilter<"LabOrder"> | string | null
    tenantId?: StringFilter<"LabOrder"> | string
    createdAt?: DateTimeFilter<"LabOrder"> | Date | string
    updatedAt?: DateTimeFilter<"LabOrder"> | Date | string
    consultationId?: StringNullableFilter<"LabOrder"> | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    doctor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    tests?: LabOrderTestListRelationFilter
    consultation?: XOR<TelemedicineConsultationNullableScalarRelationFilter, TelemedicineConsultationWhereInput> | null
  }

  export type LabOrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    completedDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    consultationId?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    doctor?: UserOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    tests?: LabOrderTestOrderByRelationAggregateInput
    consultation?: TelemedicineConsultationOrderByWithRelationInput
  }

  export type LabOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    AND?: LabOrderWhereInput | LabOrderWhereInput[]
    OR?: LabOrderWhereInput[]
    NOT?: LabOrderWhereInput | LabOrderWhereInput[]
    patientId?: StringFilter<"LabOrder"> | string
    doctorId?: StringNullableFilter<"LabOrder"> | string | null
    status?: EnumLabOrderStatusFilter<"LabOrder"> | $Enums.LabOrderStatus
    orderDate?: DateTimeFilter<"LabOrder"> | Date | string
    completedDate?: DateTimeNullableFilter<"LabOrder"> | Date | string | null
    notes?: StringNullableFilter<"LabOrder"> | string | null
    tenantId?: StringFilter<"LabOrder"> | string
    createdAt?: DateTimeFilter<"LabOrder"> | Date | string
    updatedAt?: DateTimeFilter<"LabOrder"> | Date | string
    consultationId?: StringNullableFilter<"LabOrder"> | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    doctor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    tests?: LabOrderTestListRelationFilter
    consultation?: XOR<TelemedicineConsultationNullableScalarRelationFilter, TelemedicineConsultationWhereInput> | null
  }, "id" | "orderNumber">

  export type LabOrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    completedDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    consultationId?: SortOrderInput | SortOrder
    _count?: LabOrderCountOrderByAggregateInput
    _max?: LabOrderMaxOrderByAggregateInput
    _min?: LabOrderMinOrderByAggregateInput
  }

  export type LabOrderScalarWhereWithAggregatesInput = {
    AND?: LabOrderScalarWhereWithAggregatesInput | LabOrderScalarWhereWithAggregatesInput[]
    OR?: LabOrderScalarWhereWithAggregatesInput[]
    NOT?: LabOrderScalarWhereWithAggregatesInput | LabOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LabOrder"> | string
    orderNumber?: StringWithAggregatesFilter<"LabOrder"> | string
    patientId?: StringWithAggregatesFilter<"LabOrder"> | string
    doctorId?: StringNullableWithAggregatesFilter<"LabOrder"> | string | null
    status?: EnumLabOrderStatusWithAggregatesFilter<"LabOrder"> | $Enums.LabOrderStatus
    orderDate?: DateTimeWithAggregatesFilter<"LabOrder"> | Date | string
    completedDate?: DateTimeNullableWithAggregatesFilter<"LabOrder"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"LabOrder"> | string | null
    tenantId?: StringWithAggregatesFilter<"LabOrder"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LabOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LabOrder"> | Date | string
    consultationId?: StringNullableWithAggregatesFilter<"LabOrder"> | string | null
  }

  export type LabOrderTestWhereInput = {
    AND?: LabOrderTestWhereInput | LabOrderTestWhereInput[]
    OR?: LabOrderTestWhereInput[]
    NOT?: LabOrderTestWhereInput | LabOrderTestWhereInput[]
    id?: StringFilter<"LabOrderTest"> | string
    orderId?: StringFilter<"LabOrderTest"> | string
    testId?: StringFilter<"LabOrderTest"> | string
    status?: EnumLabTestStatusFilter<"LabOrderTest"> | $Enums.LabTestStatus
    result?: StringNullableFilter<"LabOrderTest"> | string | null
    resultDate?: DateTimeNullableFilter<"LabOrderTest"> | Date | string | null
    referenceRange?: StringNullableFilter<"LabOrderTest"> | string | null
    notes?: StringNullableFilter<"LabOrderTest"> | string | null
    tenantId?: StringFilter<"LabOrderTest"> | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    test?: XOR<LabTestScalarRelationFilter, LabTestWhereInput>
    order?: XOR<LabOrderScalarRelationFilter, LabOrderWhereInput>
  }

  export type LabOrderTestOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    resultDate?: SortOrderInput | SortOrder
    referenceRange?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    test?: LabTestOrderByWithRelationInput
    order?: LabOrderOrderByWithRelationInput
  }

  export type LabOrderTestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LabOrderTestWhereInput | LabOrderTestWhereInput[]
    OR?: LabOrderTestWhereInput[]
    NOT?: LabOrderTestWhereInput | LabOrderTestWhereInput[]
    orderId?: StringFilter<"LabOrderTest"> | string
    testId?: StringFilter<"LabOrderTest"> | string
    status?: EnumLabTestStatusFilter<"LabOrderTest"> | $Enums.LabTestStatus
    result?: StringNullableFilter<"LabOrderTest"> | string | null
    resultDate?: DateTimeNullableFilter<"LabOrderTest"> | Date | string | null
    referenceRange?: StringNullableFilter<"LabOrderTest"> | string | null
    notes?: StringNullableFilter<"LabOrderTest"> | string | null
    tenantId?: StringFilter<"LabOrderTest"> | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    test?: XOR<LabTestScalarRelationFilter, LabTestWhereInput>
    order?: XOR<LabOrderScalarRelationFilter, LabOrderWhereInput>
  }, "id">

  export type LabOrderTestOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    resultDate?: SortOrderInput | SortOrder
    referenceRange?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    _count?: LabOrderTestCountOrderByAggregateInput
    _max?: LabOrderTestMaxOrderByAggregateInput
    _min?: LabOrderTestMinOrderByAggregateInput
  }

  export type LabOrderTestScalarWhereWithAggregatesInput = {
    AND?: LabOrderTestScalarWhereWithAggregatesInput | LabOrderTestScalarWhereWithAggregatesInput[]
    OR?: LabOrderTestScalarWhereWithAggregatesInput[]
    NOT?: LabOrderTestScalarWhereWithAggregatesInput | LabOrderTestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LabOrderTest"> | string
    orderId?: StringWithAggregatesFilter<"LabOrderTest"> | string
    testId?: StringWithAggregatesFilter<"LabOrderTest"> | string
    status?: EnumLabTestStatusWithAggregatesFilter<"LabOrderTest"> | $Enums.LabTestStatus
    result?: StringNullableWithAggregatesFilter<"LabOrderTest"> | string | null
    resultDate?: DateTimeNullableWithAggregatesFilter<"LabOrderTest"> | Date | string | null
    referenceRange?: StringNullableWithAggregatesFilter<"LabOrderTest"> | string | null
    notes?: StringNullableWithAggregatesFilter<"LabOrderTest"> | string | null
    tenantId?: StringWithAggregatesFilter<"LabOrderTest"> | string
  }

  export type MedicationWhereInput = {
    AND?: MedicationWhereInput | MedicationWhereInput[]
    OR?: MedicationWhereInput[]
    NOT?: MedicationWhereInput | MedicationWhereInput[]
    id?: StringFilter<"Medication"> | string
    name?: StringFilter<"Medication"> | string
    genericName?: StringNullableFilter<"Medication"> | string | null
    description?: StringNullableFilter<"Medication"> | string | null
    strength?: StringNullableFilter<"Medication"> | string | null
    unit?: StringNullableFilter<"Medication"> | string | null
    dosageForm?: StringNullableFilter<"Medication"> | string | null
    route?: StringNullableFilter<"Medication"> | string | null
    schedule?: JsonNullableFilter<"Medication">
    isActive?: BoolFilter<"Medication"> | boolean
    tenantId?: StringFilter<"Medication"> | string
    createdAt?: DateTimeFilter<"Medication"> | Date | string
    updatedAt?: DateTimeFilter<"Medication"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    pharmacyOrderItems?: PharmacyOrderItemListRelationFilter
    prescriptionItems?: PrescriptionItemListRelationFilter
  }

  export type MedicationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    genericName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    strength?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    dosageForm?: SortOrderInput | SortOrder
    route?: SortOrderInput | SortOrder
    schedule?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    pharmacyOrderItems?: PharmacyOrderItemOrderByRelationAggregateInput
    prescriptionItems?: PrescriptionItemOrderByRelationAggregateInput
  }

  export type MedicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicationWhereInput | MedicationWhereInput[]
    OR?: MedicationWhereInput[]
    NOT?: MedicationWhereInput | MedicationWhereInput[]
    name?: StringFilter<"Medication"> | string
    genericName?: StringNullableFilter<"Medication"> | string | null
    description?: StringNullableFilter<"Medication"> | string | null
    strength?: StringNullableFilter<"Medication"> | string | null
    unit?: StringNullableFilter<"Medication"> | string | null
    dosageForm?: StringNullableFilter<"Medication"> | string | null
    route?: StringNullableFilter<"Medication"> | string | null
    schedule?: JsonNullableFilter<"Medication">
    isActive?: BoolFilter<"Medication"> | boolean
    tenantId?: StringFilter<"Medication"> | string
    createdAt?: DateTimeFilter<"Medication"> | Date | string
    updatedAt?: DateTimeFilter<"Medication"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    pharmacyOrderItems?: PharmacyOrderItemListRelationFilter
    prescriptionItems?: PrescriptionItemListRelationFilter
  }, "id">

  export type MedicationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    genericName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    strength?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    dosageForm?: SortOrderInput | SortOrder
    route?: SortOrderInput | SortOrder
    schedule?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicationCountOrderByAggregateInput
    _max?: MedicationMaxOrderByAggregateInput
    _min?: MedicationMinOrderByAggregateInput
  }

  export type MedicationScalarWhereWithAggregatesInput = {
    AND?: MedicationScalarWhereWithAggregatesInput | MedicationScalarWhereWithAggregatesInput[]
    OR?: MedicationScalarWhereWithAggregatesInput[]
    NOT?: MedicationScalarWhereWithAggregatesInput | MedicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Medication"> | string
    name?: StringWithAggregatesFilter<"Medication"> | string
    genericName?: StringNullableWithAggregatesFilter<"Medication"> | string | null
    description?: StringNullableWithAggregatesFilter<"Medication"> | string | null
    strength?: StringNullableWithAggregatesFilter<"Medication"> | string | null
    unit?: StringNullableWithAggregatesFilter<"Medication"> | string | null
    dosageForm?: StringNullableWithAggregatesFilter<"Medication"> | string | null
    route?: StringNullableWithAggregatesFilter<"Medication"> | string | null
    schedule?: JsonNullableWithAggregatesFilter<"Medication">
    isActive?: BoolWithAggregatesFilter<"Medication"> | boolean
    tenantId?: StringWithAggregatesFilter<"Medication"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Medication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Medication"> | Date | string
  }

  export type PharmacyOrderWhereInput = {
    AND?: PharmacyOrderWhereInput | PharmacyOrderWhereInput[]
    OR?: PharmacyOrderWhereInput[]
    NOT?: PharmacyOrderWhereInput | PharmacyOrderWhereInput[]
    id?: StringFilter<"PharmacyOrder"> | string
    orderNumber?: StringFilter<"PharmacyOrder"> | string
    patientId?: StringFilter<"PharmacyOrder"> | string
    doctorId?: StringNullableFilter<"PharmacyOrder"> | string | null
    status?: EnumPharmacyOrderStatusFilter<"PharmacyOrder"> | $Enums.PharmacyOrderStatus
    orderDate?: DateTimeFilter<"PharmacyOrder"> | Date | string
    dispensedDate?: DateTimeNullableFilter<"PharmacyOrder"> | Date | string | null
    notes?: StringNullableFilter<"PharmacyOrder"> | string | null
    tenantId?: StringFilter<"PharmacyOrder"> | string
    createdAt?: DateTimeFilter<"PharmacyOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PharmacyOrder"> | Date | string
    invoiceId?: StringNullableFilter<"PharmacyOrder"> | string | null
    createdBy?: StringNullableFilter<"PharmacyOrder"> | string | null
    updatedBy?: StringNullableFilter<"PharmacyOrder"> | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    doctor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    items?: PharmacyOrderItemListRelationFilter
  }

  export type PharmacyOrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    dispensedDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    doctor?: UserOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
    items?: PharmacyOrderItemOrderByRelationAggregateInput
  }

  export type PharmacyOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    invoiceId?: string
    AND?: PharmacyOrderWhereInput | PharmacyOrderWhereInput[]
    OR?: PharmacyOrderWhereInput[]
    NOT?: PharmacyOrderWhereInput | PharmacyOrderWhereInput[]
    patientId?: StringFilter<"PharmacyOrder"> | string
    doctorId?: StringNullableFilter<"PharmacyOrder"> | string | null
    status?: EnumPharmacyOrderStatusFilter<"PharmacyOrder"> | $Enums.PharmacyOrderStatus
    orderDate?: DateTimeFilter<"PharmacyOrder"> | Date | string
    dispensedDate?: DateTimeNullableFilter<"PharmacyOrder"> | Date | string | null
    notes?: StringNullableFilter<"PharmacyOrder"> | string | null
    tenantId?: StringFilter<"PharmacyOrder"> | string
    createdAt?: DateTimeFilter<"PharmacyOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PharmacyOrder"> | Date | string
    createdBy?: StringNullableFilter<"PharmacyOrder"> | string | null
    updatedBy?: StringNullableFilter<"PharmacyOrder"> | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    doctor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    items?: PharmacyOrderItemListRelationFilter
  }, "id" | "orderNumber" | "invoiceId">

  export type PharmacyOrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    dispensedDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: PharmacyOrderCountOrderByAggregateInput
    _max?: PharmacyOrderMaxOrderByAggregateInput
    _min?: PharmacyOrderMinOrderByAggregateInput
  }

  export type PharmacyOrderScalarWhereWithAggregatesInput = {
    AND?: PharmacyOrderScalarWhereWithAggregatesInput | PharmacyOrderScalarWhereWithAggregatesInput[]
    OR?: PharmacyOrderScalarWhereWithAggregatesInput[]
    NOT?: PharmacyOrderScalarWhereWithAggregatesInput | PharmacyOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PharmacyOrder"> | string
    orderNumber?: StringWithAggregatesFilter<"PharmacyOrder"> | string
    patientId?: StringWithAggregatesFilter<"PharmacyOrder"> | string
    doctorId?: StringNullableWithAggregatesFilter<"PharmacyOrder"> | string | null
    status?: EnumPharmacyOrderStatusWithAggregatesFilter<"PharmacyOrder"> | $Enums.PharmacyOrderStatus
    orderDate?: DateTimeWithAggregatesFilter<"PharmacyOrder"> | Date | string
    dispensedDate?: DateTimeNullableWithAggregatesFilter<"PharmacyOrder"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"PharmacyOrder"> | string | null
    tenantId?: StringWithAggregatesFilter<"PharmacyOrder"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PharmacyOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PharmacyOrder"> | Date | string
    invoiceId?: StringNullableWithAggregatesFilter<"PharmacyOrder"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"PharmacyOrder"> | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"PharmacyOrder"> | string | null
  }

  export type PharmacyOrderItemWhereInput = {
    AND?: PharmacyOrderItemWhereInput | PharmacyOrderItemWhereInput[]
    OR?: PharmacyOrderItemWhereInput[]
    NOT?: PharmacyOrderItemWhereInput | PharmacyOrderItemWhereInput[]
    id?: StringFilter<"PharmacyOrderItem"> | string
    orderId?: StringFilter<"PharmacyOrderItem"> | string
    medicationId?: StringFilter<"PharmacyOrderItem"> | string
    quantity?: IntFilter<"PharmacyOrderItem"> | number
    dosage?: StringNullableFilter<"PharmacyOrderItem"> | string | null
    frequency?: StringNullableFilter<"PharmacyOrderItem"> | string | null
    duration?: StringNullableFilter<"PharmacyOrderItem"> | string | null
    instructions?: StringNullableFilter<"PharmacyOrderItem"> | string | null
    status?: EnumPharmacyItemStatusFilter<"PharmacyOrderItem"> | $Enums.PharmacyItemStatus
    tenantId?: StringFilter<"PharmacyOrderItem"> | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    medication?: XOR<MedicationScalarRelationFilter, MedicationWhereInput>
    order?: XOR<PharmacyOrderScalarRelationFilter, PharmacyOrderWhereInput>
  }

  export type PharmacyOrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicationId?: SortOrder
    quantity?: SortOrder
    dosage?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    medication?: MedicationOrderByWithRelationInput
    order?: PharmacyOrderOrderByWithRelationInput
  }

  export type PharmacyOrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PharmacyOrderItemWhereInput | PharmacyOrderItemWhereInput[]
    OR?: PharmacyOrderItemWhereInput[]
    NOT?: PharmacyOrderItemWhereInput | PharmacyOrderItemWhereInput[]
    orderId?: StringFilter<"PharmacyOrderItem"> | string
    medicationId?: StringFilter<"PharmacyOrderItem"> | string
    quantity?: IntFilter<"PharmacyOrderItem"> | number
    dosage?: StringNullableFilter<"PharmacyOrderItem"> | string | null
    frequency?: StringNullableFilter<"PharmacyOrderItem"> | string | null
    duration?: StringNullableFilter<"PharmacyOrderItem"> | string | null
    instructions?: StringNullableFilter<"PharmacyOrderItem"> | string | null
    status?: EnumPharmacyItemStatusFilter<"PharmacyOrderItem"> | $Enums.PharmacyItemStatus
    tenantId?: StringFilter<"PharmacyOrderItem"> | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    medication?: XOR<MedicationScalarRelationFilter, MedicationWhereInput>
    order?: XOR<PharmacyOrderScalarRelationFilter, PharmacyOrderWhereInput>
  }, "id">

  export type PharmacyOrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicationId?: SortOrder
    quantity?: SortOrder
    dosage?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    instructions?: SortOrderInput | SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    _count?: PharmacyOrderItemCountOrderByAggregateInput
    _avg?: PharmacyOrderItemAvgOrderByAggregateInput
    _max?: PharmacyOrderItemMaxOrderByAggregateInput
    _min?: PharmacyOrderItemMinOrderByAggregateInput
    _sum?: PharmacyOrderItemSumOrderByAggregateInput
  }

  export type PharmacyOrderItemScalarWhereWithAggregatesInput = {
    AND?: PharmacyOrderItemScalarWhereWithAggregatesInput | PharmacyOrderItemScalarWhereWithAggregatesInput[]
    OR?: PharmacyOrderItemScalarWhereWithAggregatesInput[]
    NOT?: PharmacyOrderItemScalarWhereWithAggregatesInput | PharmacyOrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PharmacyOrderItem"> | string
    orderId?: StringWithAggregatesFilter<"PharmacyOrderItem"> | string
    medicationId?: StringWithAggregatesFilter<"PharmacyOrderItem"> | string
    quantity?: IntWithAggregatesFilter<"PharmacyOrderItem"> | number
    dosage?: StringNullableWithAggregatesFilter<"PharmacyOrderItem"> | string | null
    frequency?: StringNullableWithAggregatesFilter<"PharmacyOrderItem"> | string | null
    duration?: StringNullableWithAggregatesFilter<"PharmacyOrderItem"> | string | null
    instructions?: StringNullableWithAggregatesFilter<"PharmacyOrderItem"> | string | null
    status?: EnumPharmacyItemStatusWithAggregatesFilter<"PharmacyOrderItem"> | $Enums.PharmacyItemStatus
    tenantId?: StringWithAggregatesFilter<"PharmacyOrderItem"> | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringNullableFilter<"AuditLog"> | string | null
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    tenantId?: StringFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringNullableFilter<"AuditLog"> | string | null
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    tenantId?: StringFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    oldValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    newValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    tenantId?: StringWithAggregatesFilter<"AuditLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type ModalityWhereInput = {
    AND?: ModalityWhereInput | ModalityWhereInput[]
    OR?: ModalityWhereInput[]
    NOT?: ModalityWhereInput | ModalityWhereInput[]
    id?: StringFilter<"Modality"> | string
    name?: StringFilter<"Modality"> | string
    description?: StringNullableFilter<"Modality"> | string | null
    isActive?: BoolFilter<"Modality"> | boolean
    createdAt?: DateTimeFilter<"Modality"> | Date | string
    updatedAt?: DateTimeFilter<"Modality"> | Date | string
    studies?: StudyListRelationFilter
    radiologyOrders?: RadiologyOrderListRelationFilter
  }

  export type ModalityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studies?: StudyOrderByRelationAggregateInput
    radiologyOrders?: RadiologyOrderOrderByRelationAggregateInput
  }

  export type ModalityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ModalityWhereInput | ModalityWhereInput[]
    OR?: ModalityWhereInput[]
    NOT?: ModalityWhereInput | ModalityWhereInput[]
    description?: StringNullableFilter<"Modality"> | string | null
    isActive?: BoolFilter<"Modality"> | boolean
    createdAt?: DateTimeFilter<"Modality"> | Date | string
    updatedAt?: DateTimeFilter<"Modality"> | Date | string
    studies?: StudyListRelationFilter
    radiologyOrders?: RadiologyOrderListRelationFilter
  }, "id" | "name">

  export type ModalityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModalityCountOrderByAggregateInput
    _max?: ModalityMaxOrderByAggregateInput
    _min?: ModalityMinOrderByAggregateInput
  }

  export type ModalityScalarWhereWithAggregatesInput = {
    AND?: ModalityScalarWhereWithAggregatesInput | ModalityScalarWhereWithAggregatesInput[]
    OR?: ModalityScalarWhereWithAggregatesInput[]
    NOT?: ModalityScalarWhereWithAggregatesInput | ModalityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Modality"> | string
    name?: StringWithAggregatesFilter<"Modality"> | string
    description?: StringNullableWithAggregatesFilter<"Modality"> | string | null
    isActive?: BoolWithAggregatesFilter<"Modality"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Modality"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Modality"> | Date | string
  }

  export type StudyWhereInput = {
    AND?: StudyWhereInput | StudyWhereInput[]
    OR?: StudyWhereInput[]
    NOT?: StudyWhereInput | StudyWhereInput[]
    id?: StringFilter<"Study"> | string
    studyId?: StringFilter<"Study"> | string
    patientId?: StringFilter<"Study"> | string
    patientName?: StringFilter<"Study"> | string
    modalityId?: StringFilter<"Study"> | string
    status?: EnumStudyStatusFilter<"Study"> | $Enums.StudyStatus
    studyDate?: DateTimeFilter<"Study"> | Date | string
    priority?: EnumPriorityNullableFilter<"Study"> | $Enums.Priority | null
    description?: StringNullableFilter<"Study"> | string | null
    notes?: StringNullableFilter<"Study"> | string | null
    isActive?: BoolFilter<"Study"> | boolean
    tenantId?: StringFilter<"Study"> | string
    createdAt?: DateTimeFilter<"Study"> | Date | string
    updatedAt?: DateTimeFilter<"Study"> | Date | string
    modality?: XOR<ModalityScalarRelationFilter, ModalityWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    series?: SeriesListRelationFilter
    radReports?: RadReportListRelationFilter
    radiationDoses?: RadiationDoseListRelationFilter
    radiologyOrders?: RadiologyOrderListRelationFilter
  }

  export type StudyOrderByWithRelationInput = {
    id?: SortOrder
    studyId?: SortOrder
    patientId?: SortOrder
    patientName?: SortOrder
    modalityId?: SortOrder
    status?: SortOrder
    studyDate?: SortOrder
    priority?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    modality?: ModalityOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    series?: SeriesOrderByRelationAggregateInput
    radReports?: RadReportOrderByRelationAggregateInput
    radiationDoses?: RadiationDoseOrderByRelationAggregateInput
    radiologyOrders?: RadiologyOrderOrderByRelationAggregateInput
  }

  export type StudyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studyId?: string
    AND?: StudyWhereInput | StudyWhereInput[]
    OR?: StudyWhereInput[]
    NOT?: StudyWhereInput | StudyWhereInput[]
    patientId?: StringFilter<"Study"> | string
    patientName?: StringFilter<"Study"> | string
    modalityId?: StringFilter<"Study"> | string
    status?: EnumStudyStatusFilter<"Study"> | $Enums.StudyStatus
    studyDate?: DateTimeFilter<"Study"> | Date | string
    priority?: EnumPriorityNullableFilter<"Study"> | $Enums.Priority | null
    description?: StringNullableFilter<"Study"> | string | null
    notes?: StringNullableFilter<"Study"> | string | null
    isActive?: BoolFilter<"Study"> | boolean
    tenantId?: StringFilter<"Study"> | string
    createdAt?: DateTimeFilter<"Study"> | Date | string
    updatedAt?: DateTimeFilter<"Study"> | Date | string
    modality?: XOR<ModalityScalarRelationFilter, ModalityWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    series?: SeriesListRelationFilter
    radReports?: RadReportListRelationFilter
    radiationDoses?: RadiationDoseListRelationFilter
    radiologyOrders?: RadiologyOrderListRelationFilter
  }, "id" | "studyId">

  export type StudyOrderByWithAggregationInput = {
    id?: SortOrder
    studyId?: SortOrder
    patientId?: SortOrder
    patientName?: SortOrder
    modalityId?: SortOrder
    status?: SortOrder
    studyDate?: SortOrder
    priority?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudyCountOrderByAggregateInput
    _max?: StudyMaxOrderByAggregateInput
    _min?: StudyMinOrderByAggregateInput
  }

  export type StudyScalarWhereWithAggregatesInput = {
    AND?: StudyScalarWhereWithAggregatesInput | StudyScalarWhereWithAggregatesInput[]
    OR?: StudyScalarWhereWithAggregatesInput[]
    NOT?: StudyScalarWhereWithAggregatesInput | StudyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Study"> | string
    studyId?: StringWithAggregatesFilter<"Study"> | string
    patientId?: StringWithAggregatesFilter<"Study"> | string
    patientName?: StringWithAggregatesFilter<"Study"> | string
    modalityId?: StringWithAggregatesFilter<"Study"> | string
    status?: EnumStudyStatusWithAggregatesFilter<"Study"> | $Enums.StudyStatus
    studyDate?: DateTimeWithAggregatesFilter<"Study"> | Date | string
    priority?: EnumPriorityNullableWithAggregatesFilter<"Study"> | $Enums.Priority | null
    description?: StringNullableWithAggregatesFilter<"Study"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Study"> | string | null
    isActive?: BoolWithAggregatesFilter<"Study"> | boolean
    tenantId?: StringWithAggregatesFilter<"Study"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Study"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Study"> | Date | string
  }

  export type SeriesWhereInput = {
    AND?: SeriesWhereInput | SeriesWhereInput[]
    OR?: SeriesWhereInput[]
    NOT?: SeriesWhereInput | SeriesWhereInput[]
    id?: StringFilter<"Series"> | string
    seriesUid?: StringFilter<"Series"> | string
    studyId?: StringFilter<"Series"> | string
    number?: IntFilter<"Series"> | number
    description?: StringNullableFilter<"Series"> | string | null
    modality?: StringFilter<"Series"> | string
    bodyPart?: StringNullableFilter<"Series"> | string | null
    count?: IntFilter<"Series"> | number
    isActive?: BoolFilter<"Series"> | boolean
    createdAt?: DateTimeFilter<"Series"> | Date | string
    updatedAt?: DateTimeFilter<"Series"> | Date | string
    study?: XOR<StudyScalarRelationFilter, StudyWhereInput>
    images?: ImageListRelationFilter
  }

  export type SeriesOrderByWithRelationInput = {
    id?: SortOrder
    seriesUid?: SortOrder
    studyId?: SortOrder
    number?: SortOrder
    description?: SortOrderInput | SortOrder
    modality?: SortOrder
    bodyPart?: SortOrderInput | SortOrder
    count?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    study?: StudyOrderByWithRelationInput
    images?: ImageOrderByRelationAggregateInput
  }

  export type SeriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    seriesUid?: string
    AND?: SeriesWhereInput | SeriesWhereInput[]
    OR?: SeriesWhereInput[]
    NOT?: SeriesWhereInput | SeriesWhereInput[]
    studyId?: StringFilter<"Series"> | string
    number?: IntFilter<"Series"> | number
    description?: StringNullableFilter<"Series"> | string | null
    modality?: StringFilter<"Series"> | string
    bodyPart?: StringNullableFilter<"Series"> | string | null
    count?: IntFilter<"Series"> | number
    isActive?: BoolFilter<"Series"> | boolean
    createdAt?: DateTimeFilter<"Series"> | Date | string
    updatedAt?: DateTimeFilter<"Series"> | Date | string
    study?: XOR<StudyScalarRelationFilter, StudyWhereInput>
    images?: ImageListRelationFilter
  }, "id" | "seriesUid">

  export type SeriesOrderByWithAggregationInput = {
    id?: SortOrder
    seriesUid?: SortOrder
    studyId?: SortOrder
    number?: SortOrder
    description?: SortOrderInput | SortOrder
    modality?: SortOrder
    bodyPart?: SortOrderInput | SortOrder
    count?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SeriesCountOrderByAggregateInput
    _avg?: SeriesAvgOrderByAggregateInput
    _max?: SeriesMaxOrderByAggregateInput
    _min?: SeriesMinOrderByAggregateInput
    _sum?: SeriesSumOrderByAggregateInput
  }

  export type SeriesScalarWhereWithAggregatesInput = {
    AND?: SeriesScalarWhereWithAggregatesInput | SeriesScalarWhereWithAggregatesInput[]
    OR?: SeriesScalarWhereWithAggregatesInput[]
    NOT?: SeriesScalarWhereWithAggregatesInput | SeriesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Series"> | string
    seriesUid?: StringWithAggregatesFilter<"Series"> | string
    studyId?: StringWithAggregatesFilter<"Series"> | string
    number?: IntWithAggregatesFilter<"Series"> | number
    description?: StringNullableWithAggregatesFilter<"Series"> | string | null
    modality?: StringWithAggregatesFilter<"Series"> | string
    bodyPart?: StringNullableWithAggregatesFilter<"Series"> | string | null
    count?: IntWithAggregatesFilter<"Series"> | number
    isActive?: BoolWithAggregatesFilter<"Series"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Series"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Series"> | Date | string
  }

  export type ImageWhereInput = {
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    id?: StringFilter<"Image"> | string
    sopInstanceUid?: StringFilter<"Image"> | string
    seriesId?: StringFilter<"Image"> | string
    number?: IntFilter<"Image"> | number
    path?: StringFilter<"Image"> | string
    size?: IntFilter<"Image"> | number
    contentType?: StringFilter<"Image"> | string
    width?: IntFilter<"Image"> | number
    height?: IntFilter<"Image"> | number
    windowCenter?: FloatNullableFilter<"Image"> | number | null
    windowWidth?: FloatNullableFilter<"Image"> | number | null
    isActive?: BoolFilter<"Image"> | boolean
    createdAt?: DateTimeFilter<"Image"> | Date | string
    updatedAt?: DateTimeFilter<"Image"> | Date | string
    series?: XOR<SeriesScalarRelationFilter, SeriesWhereInput>
  }

  export type ImageOrderByWithRelationInput = {
    id?: SortOrder
    sopInstanceUid?: SortOrder
    seriesId?: SortOrder
    number?: SortOrder
    path?: SortOrder
    size?: SortOrder
    contentType?: SortOrder
    width?: SortOrder
    height?: SortOrder
    windowCenter?: SortOrderInput | SortOrder
    windowWidth?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    series?: SeriesOrderByWithRelationInput
  }

  export type ImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sopInstanceUid?: string
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    seriesId?: StringFilter<"Image"> | string
    number?: IntFilter<"Image"> | number
    path?: StringFilter<"Image"> | string
    size?: IntFilter<"Image"> | number
    contentType?: StringFilter<"Image"> | string
    width?: IntFilter<"Image"> | number
    height?: IntFilter<"Image"> | number
    windowCenter?: FloatNullableFilter<"Image"> | number | null
    windowWidth?: FloatNullableFilter<"Image"> | number | null
    isActive?: BoolFilter<"Image"> | boolean
    createdAt?: DateTimeFilter<"Image"> | Date | string
    updatedAt?: DateTimeFilter<"Image"> | Date | string
    series?: XOR<SeriesScalarRelationFilter, SeriesWhereInput>
  }, "id" | "sopInstanceUid">

  export type ImageOrderByWithAggregationInput = {
    id?: SortOrder
    sopInstanceUid?: SortOrder
    seriesId?: SortOrder
    number?: SortOrder
    path?: SortOrder
    size?: SortOrder
    contentType?: SortOrder
    width?: SortOrder
    height?: SortOrder
    windowCenter?: SortOrderInput | SortOrder
    windowWidth?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ImageCountOrderByAggregateInput
    _avg?: ImageAvgOrderByAggregateInput
    _max?: ImageMaxOrderByAggregateInput
    _min?: ImageMinOrderByAggregateInput
    _sum?: ImageSumOrderByAggregateInput
  }

  export type ImageScalarWhereWithAggregatesInput = {
    AND?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    OR?: ImageScalarWhereWithAggregatesInput[]
    NOT?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Image"> | string
    sopInstanceUid?: StringWithAggregatesFilter<"Image"> | string
    seriesId?: StringWithAggregatesFilter<"Image"> | string
    number?: IntWithAggregatesFilter<"Image"> | number
    path?: StringWithAggregatesFilter<"Image"> | string
    size?: IntWithAggregatesFilter<"Image"> | number
    contentType?: StringWithAggregatesFilter<"Image"> | string
    width?: IntWithAggregatesFilter<"Image"> | number
    height?: IntWithAggregatesFilter<"Image"> | number
    windowCenter?: FloatNullableWithAggregatesFilter<"Image"> | number | null
    windowWidth?: FloatNullableWithAggregatesFilter<"Image"> | number | null
    isActive?: BoolWithAggregatesFilter<"Image"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Image"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Image"> | Date | string
  }

  export type RadReportWhereInput = {
    AND?: RadReportWhereInput | RadReportWhereInput[]
    OR?: RadReportWhereInput[]
    NOT?: RadReportWhereInput | RadReportWhereInput[]
    id?: StringFilter<"RadReport"> | string
    reportId?: StringFilter<"RadReport"> | string
    studyId?: StringFilter<"RadReport"> | string
    reportTemplateId?: StringNullableFilter<"RadReport"> | string | null
    status?: EnumReportStatusFilter<"RadReport"> | $Enums.ReportStatus
    findings?: StringNullableFilter<"RadReport"> | string | null
    impression?: StringNullableFilter<"RadReport"> | string | null
    conclusion?: StringNullableFilter<"RadReport"> | string | null
    reportDateTime?: DateTimeFilter<"RadReport"> | Date | string
    verifiedBy?: StringNullableFilter<"RadReport"> | string | null
    verifiedAt?: DateTimeNullableFilter<"RadReport"> | Date | string | null
    isActive?: BoolFilter<"RadReport"> | boolean
    tenantId?: StringFilter<"RadReport"> | string
    createdAt?: DateTimeFilter<"RadReport"> | Date | string
    updatedAt?: DateTimeFilter<"RadReport"> | Date | string
    study?: XOR<StudyScalarRelationFilter, StudyWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    reportTemplate?: XOR<ReportTemplateNullableScalarRelationFilter, ReportTemplateWhereInput> | null
  }

  export type RadReportOrderByWithRelationInput = {
    id?: SortOrder
    reportId?: SortOrder
    studyId?: SortOrder
    reportTemplateId?: SortOrderInput | SortOrder
    status?: SortOrder
    findings?: SortOrderInput | SortOrder
    impression?: SortOrderInput | SortOrder
    conclusion?: SortOrderInput | SortOrder
    reportDateTime?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    study?: StudyOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    reportTemplate?: ReportTemplateOrderByWithRelationInput
  }

  export type RadReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reportId?: string
    AND?: RadReportWhereInput | RadReportWhereInput[]
    OR?: RadReportWhereInput[]
    NOT?: RadReportWhereInput | RadReportWhereInput[]
    studyId?: StringFilter<"RadReport"> | string
    reportTemplateId?: StringNullableFilter<"RadReport"> | string | null
    status?: EnumReportStatusFilter<"RadReport"> | $Enums.ReportStatus
    findings?: StringNullableFilter<"RadReport"> | string | null
    impression?: StringNullableFilter<"RadReport"> | string | null
    conclusion?: StringNullableFilter<"RadReport"> | string | null
    reportDateTime?: DateTimeFilter<"RadReport"> | Date | string
    verifiedBy?: StringNullableFilter<"RadReport"> | string | null
    verifiedAt?: DateTimeNullableFilter<"RadReport"> | Date | string | null
    isActive?: BoolFilter<"RadReport"> | boolean
    tenantId?: StringFilter<"RadReport"> | string
    createdAt?: DateTimeFilter<"RadReport"> | Date | string
    updatedAt?: DateTimeFilter<"RadReport"> | Date | string
    study?: XOR<StudyScalarRelationFilter, StudyWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    reportTemplate?: XOR<ReportTemplateNullableScalarRelationFilter, ReportTemplateWhereInput> | null
  }, "id" | "reportId">

  export type RadReportOrderByWithAggregationInput = {
    id?: SortOrder
    reportId?: SortOrder
    studyId?: SortOrder
    reportTemplateId?: SortOrderInput | SortOrder
    status?: SortOrder
    findings?: SortOrderInput | SortOrder
    impression?: SortOrderInput | SortOrder
    conclusion?: SortOrderInput | SortOrder
    reportDateTime?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RadReportCountOrderByAggregateInput
    _max?: RadReportMaxOrderByAggregateInput
    _min?: RadReportMinOrderByAggregateInput
  }

  export type RadReportScalarWhereWithAggregatesInput = {
    AND?: RadReportScalarWhereWithAggregatesInput | RadReportScalarWhereWithAggregatesInput[]
    OR?: RadReportScalarWhereWithAggregatesInput[]
    NOT?: RadReportScalarWhereWithAggregatesInput | RadReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RadReport"> | string
    reportId?: StringWithAggregatesFilter<"RadReport"> | string
    studyId?: StringWithAggregatesFilter<"RadReport"> | string
    reportTemplateId?: StringNullableWithAggregatesFilter<"RadReport"> | string | null
    status?: EnumReportStatusWithAggregatesFilter<"RadReport"> | $Enums.ReportStatus
    findings?: StringNullableWithAggregatesFilter<"RadReport"> | string | null
    impression?: StringNullableWithAggregatesFilter<"RadReport"> | string | null
    conclusion?: StringNullableWithAggregatesFilter<"RadReport"> | string | null
    reportDateTime?: DateTimeWithAggregatesFilter<"RadReport"> | Date | string
    verifiedBy?: StringNullableWithAggregatesFilter<"RadReport"> | string | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"RadReport"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"RadReport"> | boolean
    tenantId?: StringWithAggregatesFilter<"RadReport"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RadReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RadReport"> | Date | string
  }

  export type RadiationDoseWhereInput = {
    AND?: RadiationDoseWhereInput | RadiationDoseWhereInput[]
    OR?: RadiationDoseWhereInput[]
    NOT?: RadiationDoseWhereInput | RadiationDoseWhereInput[]
    id?: StringFilter<"RadiationDose"> | string
    studyId?: StringFilter<"RadiationDose"> | string
    deviceName?: StringNullableFilter<"RadiationDose"> | string | null
    deviceType?: StringNullableFilter<"RadiationDose"> | string | null
    exposureTime?: FloatNullableFilter<"RadiationDose"> | number | null
    kvp?: FloatNullableFilter<"RadiationDose"> | number | null
    ma?: FloatNullableFilter<"RadiationDose"> | number | null
    doseAreaProduct?: FloatNullableFilter<"RadiationDose"> | number | null
    doseLengthProduct?: FloatNullableFilter<"RadiationDose"> | number | null
    ctdiVol?: FloatNullableFilter<"RadiationDose"> | number | null
    dlp?: FloatNullableFilter<"RadiationDose"> | number | null
    effectiveDose?: FloatNullableFilter<"RadiationDose"> | number | null
    isActive?: BoolFilter<"RadiationDose"> | boolean
    createdAt?: DateTimeFilter<"RadiationDose"> | Date | string
    updatedAt?: DateTimeFilter<"RadiationDose"> | Date | string
    study?: XOR<StudyScalarRelationFilter, StudyWhereInput>
  }

  export type RadiationDoseOrderByWithRelationInput = {
    id?: SortOrder
    studyId?: SortOrder
    deviceName?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    exposureTime?: SortOrderInput | SortOrder
    kvp?: SortOrderInput | SortOrder
    ma?: SortOrderInput | SortOrder
    doseAreaProduct?: SortOrderInput | SortOrder
    doseLengthProduct?: SortOrderInput | SortOrder
    ctdiVol?: SortOrderInput | SortOrder
    dlp?: SortOrderInput | SortOrder
    effectiveDose?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    study?: StudyOrderByWithRelationInput
  }

  export type RadiationDoseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RadiationDoseWhereInput | RadiationDoseWhereInput[]
    OR?: RadiationDoseWhereInput[]
    NOT?: RadiationDoseWhereInput | RadiationDoseWhereInput[]
    studyId?: StringFilter<"RadiationDose"> | string
    deviceName?: StringNullableFilter<"RadiationDose"> | string | null
    deviceType?: StringNullableFilter<"RadiationDose"> | string | null
    exposureTime?: FloatNullableFilter<"RadiationDose"> | number | null
    kvp?: FloatNullableFilter<"RadiationDose"> | number | null
    ma?: FloatNullableFilter<"RadiationDose"> | number | null
    doseAreaProduct?: FloatNullableFilter<"RadiationDose"> | number | null
    doseLengthProduct?: FloatNullableFilter<"RadiationDose"> | number | null
    ctdiVol?: FloatNullableFilter<"RadiationDose"> | number | null
    dlp?: FloatNullableFilter<"RadiationDose"> | number | null
    effectiveDose?: FloatNullableFilter<"RadiationDose"> | number | null
    isActive?: BoolFilter<"RadiationDose"> | boolean
    createdAt?: DateTimeFilter<"RadiationDose"> | Date | string
    updatedAt?: DateTimeFilter<"RadiationDose"> | Date | string
    study?: XOR<StudyScalarRelationFilter, StudyWhereInput>
  }, "id">

  export type RadiationDoseOrderByWithAggregationInput = {
    id?: SortOrder
    studyId?: SortOrder
    deviceName?: SortOrderInput | SortOrder
    deviceType?: SortOrderInput | SortOrder
    exposureTime?: SortOrderInput | SortOrder
    kvp?: SortOrderInput | SortOrder
    ma?: SortOrderInput | SortOrder
    doseAreaProduct?: SortOrderInput | SortOrder
    doseLengthProduct?: SortOrderInput | SortOrder
    ctdiVol?: SortOrderInput | SortOrder
    dlp?: SortOrderInput | SortOrder
    effectiveDose?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RadiationDoseCountOrderByAggregateInput
    _avg?: RadiationDoseAvgOrderByAggregateInput
    _max?: RadiationDoseMaxOrderByAggregateInput
    _min?: RadiationDoseMinOrderByAggregateInput
    _sum?: RadiationDoseSumOrderByAggregateInput
  }

  export type RadiationDoseScalarWhereWithAggregatesInput = {
    AND?: RadiationDoseScalarWhereWithAggregatesInput | RadiationDoseScalarWhereWithAggregatesInput[]
    OR?: RadiationDoseScalarWhereWithAggregatesInput[]
    NOT?: RadiationDoseScalarWhereWithAggregatesInput | RadiationDoseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RadiationDose"> | string
    studyId?: StringWithAggregatesFilter<"RadiationDose"> | string
    deviceName?: StringNullableWithAggregatesFilter<"RadiationDose"> | string | null
    deviceType?: StringNullableWithAggregatesFilter<"RadiationDose"> | string | null
    exposureTime?: FloatNullableWithAggregatesFilter<"RadiationDose"> | number | null
    kvp?: FloatNullableWithAggregatesFilter<"RadiationDose"> | number | null
    ma?: FloatNullableWithAggregatesFilter<"RadiationDose"> | number | null
    doseAreaProduct?: FloatNullableWithAggregatesFilter<"RadiationDose"> | number | null
    doseLengthProduct?: FloatNullableWithAggregatesFilter<"RadiationDose"> | number | null
    ctdiVol?: FloatNullableWithAggregatesFilter<"RadiationDose"> | number | null
    dlp?: FloatNullableWithAggregatesFilter<"RadiationDose"> | number | null
    effectiveDose?: FloatNullableWithAggregatesFilter<"RadiationDose"> | number | null
    isActive?: BoolWithAggregatesFilter<"RadiationDose"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RadiationDose"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RadiationDose"> | Date | string
  }

  export type ReportTemplateWhereInput = {
    AND?: ReportTemplateWhereInput | ReportTemplateWhereInput[]
    OR?: ReportTemplateWhereInput[]
    NOT?: ReportTemplateWhereInput | ReportTemplateWhereInput[]
    id?: StringFilter<"ReportTemplate"> | string
    name?: StringFilter<"ReportTemplate"> | string
    description?: StringNullableFilter<"ReportTemplate"> | string | null
    template?: StringFilter<"ReportTemplate"> | string
    isActive?: BoolFilter<"ReportTemplate"> | boolean
    tenantId?: StringFilter<"ReportTemplate"> | string
    createdAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    radReports?: RadReportListRelationFilter
  }

  export type ReportTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    template?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    radReports?: RadReportOrderByRelationAggregateInput
  }

  export type ReportTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportTemplateWhereInput | ReportTemplateWhereInput[]
    OR?: ReportTemplateWhereInput[]
    NOT?: ReportTemplateWhereInput | ReportTemplateWhereInput[]
    name?: StringFilter<"ReportTemplate"> | string
    description?: StringNullableFilter<"ReportTemplate"> | string | null
    template?: StringFilter<"ReportTemplate"> | string
    isActive?: BoolFilter<"ReportTemplate"> | boolean
    tenantId?: StringFilter<"ReportTemplate"> | string
    createdAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    radReports?: RadReportListRelationFilter
  }, "id">

  export type ReportTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    template?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportTemplateCountOrderByAggregateInput
    _max?: ReportTemplateMaxOrderByAggregateInput
    _min?: ReportTemplateMinOrderByAggregateInput
  }

  export type ReportTemplateScalarWhereWithAggregatesInput = {
    AND?: ReportTemplateScalarWhereWithAggregatesInput | ReportTemplateScalarWhereWithAggregatesInput[]
    OR?: ReportTemplateScalarWhereWithAggregatesInput[]
    NOT?: ReportTemplateScalarWhereWithAggregatesInput | ReportTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportTemplate"> | string
    name?: StringWithAggregatesFilter<"ReportTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"ReportTemplate"> | string | null
    template?: StringWithAggregatesFilter<"ReportTemplate"> | string
    isActive?: BoolWithAggregatesFilter<"ReportTemplate"> | boolean
    tenantId?: StringWithAggregatesFilter<"ReportTemplate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReportTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReportTemplate"> | Date | string
  }

  export type TelemedicineConsultationWhereInput = {
    AND?: TelemedicineConsultationWhereInput | TelemedicineConsultationWhereInput[]
    OR?: TelemedicineConsultationWhereInput[]
    NOT?: TelemedicineConsultationWhereInput | TelemedicineConsultationWhereInput[]
    id?: StringFilter<"TelemedicineConsultation"> | string
    patientId?: StringFilter<"TelemedicineConsultation"> | string
    doctorId?: StringNullableFilter<"TelemedicineConsultation"> | string | null
    status?: EnumTelemedicineStatusFilter<"TelemedicineConsultation"> | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFilter<"TelemedicineConsultation"> | Date | string
    startedAt?: DateTimeNullableFilter<"TelemedicineConsultation"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"TelemedicineConsultation"> | Date | string | null
    duration?: IntNullableFilter<"TelemedicineConsultation"> | number | null
    consultationType?: EnumConsultationTypeFilter<"TelemedicineConsultation"> | $Enums.ConsultationType
    reason?: StringNullableFilter<"TelemedicineConsultation"> | string | null
    notes?: StringNullableFilter<"TelemedicineConsultation"> | string | null
    prescription?: StringNullableFilter<"TelemedicineConsultation"> | string | null
    followUpRequired?: BoolFilter<"TelemedicineConsultation"> | boolean
    followUpDate?: DateTimeNullableFilter<"TelemedicineConsultation"> | Date | string | null
    isEmergency?: BoolFilter<"TelemedicineConsultation"> | boolean
    isActive?: BoolFilter<"TelemedicineConsultation"> | boolean
    tenantId?: StringFilter<"TelemedicineConsultation"> | string
    createdAt?: DateTimeFilter<"TelemedicineConsultation"> | Date | string
    updatedAt?: DateTimeFilter<"TelemedicineConsultation"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    videoRoom?: XOR<VideoRoomNullableScalarRelationFilter, VideoRoomWhereInput> | null
    labOrders?: LabOrderListRelationFilter
    radiologyOrders?: RadiologyOrderListRelationFilter
  }

  export type TelemedicineConsultationOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    consultationType?: SortOrder
    reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    prescription?: SortOrderInput | SortOrder
    followUpRequired?: SortOrder
    followUpDate?: SortOrderInput | SortOrder
    isEmergency?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    doctor?: UserOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    videoRoom?: VideoRoomOrderByWithRelationInput
    labOrders?: LabOrderOrderByRelationAggregateInput
    radiologyOrders?: RadiologyOrderOrderByRelationAggregateInput
  }

  export type TelemedicineConsultationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TelemedicineConsultationWhereInput | TelemedicineConsultationWhereInput[]
    OR?: TelemedicineConsultationWhereInput[]
    NOT?: TelemedicineConsultationWhereInput | TelemedicineConsultationWhereInput[]
    patientId?: StringFilter<"TelemedicineConsultation"> | string
    doctorId?: StringNullableFilter<"TelemedicineConsultation"> | string | null
    status?: EnumTelemedicineStatusFilter<"TelemedicineConsultation"> | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFilter<"TelemedicineConsultation"> | Date | string
    startedAt?: DateTimeNullableFilter<"TelemedicineConsultation"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"TelemedicineConsultation"> | Date | string | null
    duration?: IntNullableFilter<"TelemedicineConsultation"> | number | null
    consultationType?: EnumConsultationTypeFilter<"TelemedicineConsultation"> | $Enums.ConsultationType
    reason?: StringNullableFilter<"TelemedicineConsultation"> | string | null
    notes?: StringNullableFilter<"TelemedicineConsultation"> | string | null
    prescription?: StringNullableFilter<"TelemedicineConsultation"> | string | null
    followUpRequired?: BoolFilter<"TelemedicineConsultation"> | boolean
    followUpDate?: DateTimeNullableFilter<"TelemedicineConsultation"> | Date | string | null
    isEmergency?: BoolFilter<"TelemedicineConsultation"> | boolean
    isActive?: BoolFilter<"TelemedicineConsultation"> | boolean
    tenantId?: StringFilter<"TelemedicineConsultation"> | string
    createdAt?: DateTimeFilter<"TelemedicineConsultation"> | Date | string
    updatedAt?: DateTimeFilter<"TelemedicineConsultation"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    videoRoom?: XOR<VideoRoomNullableScalarRelationFilter, VideoRoomWhereInput> | null
    labOrders?: LabOrderListRelationFilter
    radiologyOrders?: RadiologyOrderListRelationFilter
  }, "id">

  export type TelemedicineConsultationOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    consultationType?: SortOrder
    reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    prescription?: SortOrderInput | SortOrder
    followUpRequired?: SortOrder
    followUpDate?: SortOrderInput | SortOrder
    isEmergency?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TelemedicineConsultationCountOrderByAggregateInput
    _avg?: TelemedicineConsultationAvgOrderByAggregateInput
    _max?: TelemedicineConsultationMaxOrderByAggregateInput
    _min?: TelemedicineConsultationMinOrderByAggregateInput
    _sum?: TelemedicineConsultationSumOrderByAggregateInput
  }

  export type TelemedicineConsultationScalarWhereWithAggregatesInput = {
    AND?: TelemedicineConsultationScalarWhereWithAggregatesInput | TelemedicineConsultationScalarWhereWithAggregatesInput[]
    OR?: TelemedicineConsultationScalarWhereWithAggregatesInput[]
    NOT?: TelemedicineConsultationScalarWhereWithAggregatesInput | TelemedicineConsultationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TelemedicineConsultation"> | string
    patientId?: StringWithAggregatesFilter<"TelemedicineConsultation"> | string
    doctorId?: StringNullableWithAggregatesFilter<"TelemedicineConsultation"> | string | null
    status?: EnumTelemedicineStatusWithAggregatesFilter<"TelemedicineConsultation"> | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeWithAggregatesFilter<"TelemedicineConsultation"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"TelemedicineConsultation"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"TelemedicineConsultation"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"TelemedicineConsultation"> | number | null
    consultationType?: EnumConsultationTypeWithAggregatesFilter<"TelemedicineConsultation"> | $Enums.ConsultationType
    reason?: StringNullableWithAggregatesFilter<"TelemedicineConsultation"> | string | null
    notes?: StringNullableWithAggregatesFilter<"TelemedicineConsultation"> | string | null
    prescription?: StringNullableWithAggregatesFilter<"TelemedicineConsultation"> | string | null
    followUpRequired?: BoolWithAggregatesFilter<"TelemedicineConsultation"> | boolean
    followUpDate?: DateTimeNullableWithAggregatesFilter<"TelemedicineConsultation"> | Date | string | null
    isEmergency?: BoolWithAggregatesFilter<"TelemedicineConsultation"> | boolean
    isActive?: BoolWithAggregatesFilter<"TelemedicineConsultation"> | boolean
    tenantId?: StringWithAggregatesFilter<"TelemedicineConsultation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TelemedicineConsultation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TelemedicineConsultation"> | Date | string
  }

  export type VideoRoomWhereInput = {
    AND?: VideoRoomWhereInput | VideoRoomWhereInput[]
    OR?: VideoRoomWhereInput[]
    NOT?: VideoRoomWhereInput | VideoRoomWhereInput[]
    id?: StringFilter<"VideoRoom"> | string
    consultationId?: StringFilter<"VideoRoom"> | string
    roomId?: StringFilter<"VideoRoom"> | string
    status?: EnumVideoRoomStatusFilter<"VideoRoom"> | $Enums.VideoRoomStatus
    startedAt?: DateTimeNullableFilter<"VideoRoom"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"VideoRoom"> | Date | string | null
    maxParticipants?: IntFilter<"VideoRoom"> | number
    recordingEnabled?: BoolFilter<"VideoRoom"> | boolean
    recordingUrl?: StringNullableFilter<"VideoRoom"> | string | null
    isActive?: BoolFilter<"VideoRoom"> | boolean
    tenantId?: StringFilter<"VideoRoom"> | string
    createdAt?: DateTimeFilter<"VideoRoom"> | Date | string
    updatedAt?: DateTimeFilter<"VideoRoom"> | Date | string
    consultation?: XOR<TelemedicineConsultationScalarRelationFilter, TelemedicineConsultationWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    participants?: VideoParticipantListRelationFilter
    recordings?: VideoRecordingListRelationFilter
  }

  export type VideoRoomOrderByWithRelationInput = {
    id?: SortOrder
    consultationId?: SortOrder
    roomId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    maxParticipants?: SortOrder
    recordingEnabled?: SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    consultation?: TelemedicineConsultationOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    participants?: VideoParticipantOrderByRelationAggregateInput
    recordings?: VideoRecordingOrderByRelationAggregateInput
  }

  export type VideoRoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    consultationId?: string
    roomId?: string
    AND?: VideoRoomWhereInput | VideoRoomWhereInput[]
    OR?: VideoRoomWhereInput[]
    NOT?: VideoRoomWhereInput | VideoRoomWhereInput[]
    status?: EnumVideoRoomStatusFilter<"VideoRoom"> | $Enums.VideoRoomStatus
    startedAt?: DateTimeNullableFilter<"VideoRoom"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"VideoRoom"> | Date | string | null
    maxParticipants?: IntFilter<"VideoRoom"> | number
    recordingEnabled?: BoolFilter<"VideoRoom"> | boolean
    recordingUrl?: StringNullableFilter<"VideoRoom"> | string | null
    isActive?: BoolFilter<"VideoRoom"> | boolean
    tenantId?: StringFilter<"VideoRoom"> | string
    createdAt?: DateTimeFilter<"VideoRoom"> | Date | string
    updatedAt?: DateTimeFilter<"VideoRoom"> | Date | string
    consultation?: XOR<TelemedicineConsultationScalarRelationFilter, TelemedicineConsultationWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    participants?: VideoParticipantListRelationFilter
    recordings?: VideoRecordingListRelationFilter
  }, "id" | "consultationId" | "roomId">

  export type VideoRoomOrderByWithAggregationInput = {
    id?: SortOrder
    consultationId?: SortOrder
    roomId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    maxParticipants?: SortOrder
    recordingEnabled?: SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VideoRoomCountOrderByAggregateInput
    _avg?: VideoRoomAvgOrderByAggregateInput
    _max?: VideoRoomMaxOrderByAggregateInput
    _min?: VideoRoomMinOrderByAggregateInput
    _sum?: VideoRoomSumOrderByAggregateInput
  }

  export type VideoRoomScalarWhereWithAggregatesInput = {
    AND?: VideoRoomScalarWhereWithAggregatesInput | VideoRoomScalarWhereWithAggregatesInput[]
    OR?: VideoRoomScalarWhereWithAggregatesInput[]
    NOT?: VideoRoomScalarWhereWithAggregatesInput | VideoRoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoRoom"> | string
    consultationId?: StringWithAggregatesFilter<"VideoRoom"> | string
    roomId?: StringWithAggregatesFilter<"VideoRoom"> | string
    status?: EnumVideoRoomStatusWithAggregatesFilter<"VideoRoom"> | $Enums.VideoRoomStatus
    startedAt?: DateTimeNullableWithAggregatesFilter<"VideoRoom"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"VideoRoom"> | Date | string | null
    maxParticipants?: IntWithAggregatesFilter<"VideoRoom"> | number
    recordingEnabled?: BoolWithAggregatesFilter<"VideoRoom"> | boolean
    recordingUrl?: StringNullableWithAggregatesFilter<"VideoRoom"> | string | null
    isActive?: BoolWithAggregatesFilter<"VideoRoom"> | boolean
    tenantId?: StringWithAggregatesFilter<"VideoRoom"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VideoRoom"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VideoRoom"> | Date | string
  }

  export type VideoParticipantWhereInput = {
    AND?: VideoParticipantWhereInput | VideoParticipantWhereInput[]
    OR?: VideoParticipantWhereInput[]
    NOT?: VideoParticipantWhereInput | VideoParticipantWhereInput[]
    id?: StringFilter<"VideoParticipant"> | string
    roomId?: StringFilter<"VideoParticipant"> | string
    userId?: StringFilter<"VideoParticipant"> | string
    participantType?: EnumParticipantTypeFilter<"VideoParticipant"> | $Enums.ParticipantType
    joinedAt?: DateTimeNullableFilter<"VideoParticipant"> | Date | string | null
    leftAt?: DateTimeNullableFilter<"VideoParticipant"> | Date | string | null
    isActive?: BoolFilter<"VideoParticipant"> | boolean
    tenantId?: StringFilter<"VideoParticipant"> | string
    createdAt?: DateTimeFilter<"VideoParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"VideoParticipant"> | Date | string
    room?: XOR<VideoRoomScalarRelationFilter, VideoRoomWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type VideoParticipantOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    participantType?: SortOrder
    joinedAt?: SortOrderInput | SortOrder
    leftAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    room?: VideoRoomOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type VideoParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roomId_userId?: VideoParticipantRoomIdUserIdCompoundUniqueInput
    AND?: VideoParticipantWhereInput | VideoParticipantWhereInput[]
    OR?: VideoParticipantWhereInput[]
    NOT?: VideoParticipantWhereInput | VideoParticipantWhereInput[]
    roomId?: StringFilter<"VideoParticipant"> | string
    userId?: StringFilter<"VideoParticipant"> | string
    participantType?: EnumParticipantTypeFilter<"VideoParticipant"> | $Enums.ParticipantType
    joinedAt?: DateTimeNullableFilter<"VideoParticipant"> | Date | string | null
    leftAt?: DateTimeNullableFilter<"VideoParticipant"> | Date | string | null
    isActive?: BoolFilter<"VideoParticipant"> | boolean
    tenantId?: StringFilter<"VideoParticipant"> | string
    createdAt?: DateTimeFilter<"VideoParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"VideoParticipant"> | Date | string
    room?: XOR<VideoRoomScalarRelationFilter, VideoRoomWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "roomId_userId">

  export type VideoParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    participantType?: SortOrder
    joinedAt?: SortOrderInput | SortOrder
    leftAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VideoParticipantCountOrderByAggregateInput
    _max?: VideoParticipantMaxOrderByAggregateInput
    _min?: VideoParticipantMinOrderByAggregateInput
  }

  export type VideoParticipantScalarWhereWithAggregatesInput = {
    AND?: VideoParticipantScalarWhereWithAggregatesInput | VideoParticipantScalarWhereWithAggregatesInput[]
    OR?: VideoParticipantScalarWhereWithAggregatesInput[]
    NOT?: VideoParticipantScalarWhereWithAggregatesInput | VideoParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoParticipant"> | string
    roomId?: StringWithAggregatesFilter<"VideoParticipant"> | string
    userId?: StringWithAggregatesFilter<"VideoParticipant"> | string
    participantType?: EnumParticipantTypeWithAggregatesFilter<"VideoParticipant"> | $Enums.ParticipantType
    joinedAt?: DateTimeNullableWithAggregatesFilter<"VideoParticipant"> | Date | string | null
    leftAt?: DateTimeNullableWithAggregatesFilter<"VideoParticipant"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"VideoParticipant"> | boolean
    tenantId?: StringWithAggregatesFilter<"VideoParticipant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VideoParticipant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VideoParticipant"> | Date | string
  }

  export type VideoRecordingWhereInput = {
    AND?: VideoRecordingWhereInput | VideoRecordingWhereInput[]
    OR?: VideoRecordingWhereInput[]
    NOT?: VideoRecordingWhereInput | VideoRecordingWhereInput[]
    id?: StringFilter<"VideoRecording"> | string
    roomId?: StringFilter<"VideoRecording"> | string
    fileName?: StringFilter<"VideoRecording"> | string
    filePath?: StringFilter<"VideoRecording"> | string
    fileSize?: IntFilter<"VideoRecording"> | number
    duration?: IntNullableFilter<"VideoRecording"> | number | null
    status?: EnumRecordingStatusFilter<"VideoRecording"> | $Enums.RecordingStatus
    isActive?: BoolFilter<"VideoRecording"> | boolean
    tenantId?: StringFilter<"VideoRecording"> | string
    createdAt?: DateTimeFilter<"VideoRecording"> | Date | string
    updatedAt?: DateTimeFilter<"VideoRecording"> | Date | string
    room?: XOR<VideoRoomScalarRelationFilter, VideoRoomWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type VideoRecordingOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    duration?: SortOrderInput | SortOrder
    status?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    room?: VideoRoomOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type VideoRecordingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VideoRecordingWhereInput | VideoRecordingWhereInput[]
    OR?: VideoRecordingWhereInput[]
    NOT?: VideoRecordingWhereInput | VideoRecordingWhereInput[]
    roomId?: StringFilter<"VideoRecording"> | string
    fileName?: StringFilter<"VideoRecording"> | string
    filePath?: StringFilter<"VideoRecording"> | string
    fileSize?: IntFilter<"VideoRecording"> | number
    duration?: IntNullableFilter<"VideoRecording"> | number | null
    status?: EnumRecordingStatusFilter<"VideoRecording"> | $Enums.RecordingStatus
    isActive?: BoolFilter<"VideoRecording"> | boolean
    tenantId?: StringFilter<"VideoRecording"> | string
    createdAt?: DateTimeFilter<"VideoRecording"> | Date | string
    updatedAt?: DateTimeFilter<"VideoRecording"> | Date | string
    room?: XOR<VideoRoomScalarRelationFilter, VideoRoomWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type VideoRecordingOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    duration?: SortOrderInput | SortOrder
    status?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VideoRecordingCountOrderByAggregateInput
    _avg?: VideoRecordingAvgOrderByAggregateInput
    _max?: VideoRecordingMaxOrderByAggregateInput
    _min?: VideoRecordingMinOrderByAggregateInput
    _sum?: VideoRecordingSumOrderByAggregateInput
  }

  export type VideoRecordingScalarWhereWithAggregatesInput = {
    AND?: VideoRecordingScalarWhereWithAggregatesInput | VideoRecordingScalarWhereWithAggregatesInput[]
    OR?: VideoRecordingScalarWhereWithAggregatesInput[]
    NOT?: VideoRecordingScalarWhereWithAggregatesInput | VideoRecordingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoRecording"> | string
    roomId?: StringWithAggregatesFilter<"VideoRecording"> | string
    fileName?: StringWithAggregatesFilter<"VideoRecording"> | string
    filePath?: StringWithAggregatesFilter<"VideoRecording"> | string
    fileSize?: IntWithAggregatesFilter<"VideoRecording"> | number
    duration?: IntNullableWithAggregatesFilter<"VideoRecording"> | number | null
    status?: EnumRecordingStatusWithAggregatesFilter<"VideoRecording"> | $Enums.RecordingStatus
    isActive?: BoolWithAggregatesFilter<"VideoRecording"> | boolean
    tenantId?: StringWithAggregatesFilter<"VideoRecording"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VideoRecording"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VideoRecording"> | Date | string
  }

  export type VideoMessageWhereInput = {
    AND?: VideoMessageWhereInput | VideoMessageWhereInput[]
    OR?: VideoMessageWhereInput[]
    NOT?: VideoMessageWhereInput | VideoMessageWhereInput[]
    id?: StringFilter<"VideoMessage"> | string
    roomId?: StringFilter<"VideoMessage"> | string
    senderId?: StringFilter<"VideoMessage"> | string
    message?: StringFilter<"VideoMessage"> | string
    messageType?: EnumMessageTypeFilter<"VideoMessage"> | $Enums.MessageType
    isActive?: BoolFilter<"VideoMessage"> | boolean
    tenantId?: StringFilter<"VideoMessage"> | string
    createdAt?: DateTimeFilter<"VideoMessage"> | Date | string
    updatedAt?: DateTimeFilter<"VideoMessage"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type VideoMessageOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    messageType?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type VideoMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VideoMessageWhereInput | VideoMessageWhereInput[]
    OR?: VideoMessageWhereInput[]
    NOT?: VideoMessageWhereInput | VideoMessageWhereInput[]
    roomId?: StringFilter<"VideoMessage"> | string
    senderId?: StringFilter<"VideoMessage"> | string
    message?: StringFilter<"VideoMessage"> | string
    messageType?: EnumMessageTypeFilter<"VideoMessage"> | $Enums.MessageType
    isActive?: BoolFilter<"VideoMessage"> | boolean
    tenantId?: StringFilter<"VideoMessage"> | string
    createdAt?: DateTimeFilter<"VideoMessage"> | Date | string
    updatedAt?: DateTimeFilter<"VideoMessage"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type VideoMessageOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    messageType?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VideoMessageCountOrderByAggregateInput
    _max?: VideoMessageMaxOrderByAggregateInput
    _min?: VideoMessageMinOrderByAggregateInput
  }

  export type VideoMessageScalarWhereWithAggregatesInput = {
    AND?: VideoMessageScalarWhereWithAggregatesInput | VideoMessageScalarWhereWithAggregatesInput[]
    OR?: VideoMessageScalarWhereWithAggregatesInput[]
    NOT?: VideoMessageScalarWhereWithAggregatesInput | VideoMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VideoMessage"> | string
    roomId?: StringWithAggregatesFilter<"VideoMessage"> | string
    senderId?: StringWithAggregatesFilter<"VideoMessage"> | string
    message?: StringWithAggregatesFilter<"VideoMessage"> | string
    messageType?: EnumMessageTypeWithAggregatesFilter<"VideoMessage"> | $Enums.MessageType
    isActive?: BoolWithAggregatesFilter<"VideoMessage"> | boolean
    tenantId?: StringWithAggregatesFilter<"VideoMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VideoMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VideoMessage"> | Date | string
  }

  export type RadiologyOrderWhereInput = {
    AND?: RadiologyOrderWhereInput | RadiologyOrderWhereInput[]
    OR?: RadiologyOrderWhereInput[]
    NOT?: RadiologyOrderWhereInput | RadiologyOrderWhereInput[]
    id?: StringFilter<"RadiologyOrder"> | string
    consultationId?: StringFilter<"RadiologyOrder"> | string
    patientId?: StringFilter<"RadiologyOrder"> | string
    doctorId?: StringFilter<"RadiologyOrder"> | string
    modalityId?: StringFilter<"RadiologyOrder"> | string
    studyType?: StringFilter<"RadiologyOrder"> | string
    priority?: EnumPriorityFilter<"RadiologyOrder"> | $Enums.Priority
    reason?: StringNullableFilter<"RadiologyOrder"> | string | null
    clinicalHistory?: StringNullableFilter<"RadiologyOrder"> | string | null
    status?: EnumRadiologyOrderStatusFilter<"RadiologyOrder"> | $Enums.RadiologyOrderStatus
    scheduledAt?: DateTimeNullableFilter<"RadiologyOrder"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"RadiologyOrder"> | Date | string | null
    isActive?: BoolFilter<"RadiologyOrder"> | boolean
    tenantId?: StringFilter<"RadiologyOrder"> | string
    createdAt?: DateTimeFilter<"RadiologyOrder"> | Date | string
    updatedAt?: DateTimeFilter<"RadiologyOrder"> | Date | string
    studyId?: StringNullableFilter<"RadiologyOrder"> | string | null
    consultation?: XOR<TelemedicineConsultationScalarRelationFilter, TelemedicineConsultationWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<UserScalarRelationFilter, UserWhereInput>
    modality?: XOR<ModalityScalarRelationFilter, ModalityWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    study?: XOR<StudyNullableScalarRelationFilter, StudyWhereInput> | null
  }

  export type RadiologyOrderOrderByWithRelationInput = {
    id?: SortOrder
    consultationId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    modalityId?: SortOrder
    studyType?: SortOrder
    priority?: SortOrder
    reason?: SortOrderInput | SortOrder
    clinicalHistory?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studyId?: SortOrderInput | SortOrder
    consultation?: TelemedicineConsultationOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    doctor?: UserOrderByWithRelationInput
    modality?: ModalityOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    study?: StudyOrderByWithRelationInput
  }

  export type RadiologyOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RadiologyOrderWhereInput | RadiologyOrderWhereInput[]
    OR?: RadiologyOrderWhereInput[]
    NOT?: RadiologyOrderWhereInput | RadiologyOrderWhereInput[]
    consultationId?: StringFilter<"RadiologyOrder"> | string
    patientId?: StringFilter<"RadiologyOrder"> | string
    doctorId?: StringFilter<"RadiologyOrder"> | string
    modalityId?: StringFilter<"RadiologyOrder"> | string
    studyType?: StringFilter<"RadiologyOrder"> | string
    priority?: EnumPriorityFilter<"RadiologyOrder"> | $Enums.Priority
    reason?: StringNullableFilter<"RadiologyOrder"> | string | null
    clinicalHistory?: StringNullableFilter<"RadiologyOrder"> | string | null
    status?: EnumRadiologyOrderStatusFilter<"RadiologyOrder"> | $Enums.RadiologyOrderStatus
    scheduledAt?: DateTimeNullableFilter<"RadiologyOrder"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"RadiologyOrder"> | Date | string | null
    isActive?: BoolFilter<"RadiologyOrder"> | boolean
    tenantId?: StringFilter<"RadiologyOrder"> | string
    createdAt?: DateTimeFilter<"RadiologyOrder"> | Date | string
    updatedAt?: DateTimeFilter<"RadiologyOrder"> | Date | string
    studyId?: StringNullableFilter<"RadiologyOrder"> | string | null
    consultation?: XOR<TelemedicineConsultationScalarRelationFilter, TelemedicineConsultationWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<UserScalarRelationFilter, UserWhereInput>
    modality?: XOR<ModalityScalarRelationFilter, ModalityWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    study?: XOR<StudyNullableScalarRelationFilter, StudyWhereInput> | null
  }, "id">

  export type RadiologyOrderOrderByWithAggregationInput = {
    id?: SortOrder
    consultationId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    modalityId?: SortOrder
    studyType?: SortOrder
    priority?: SortOrder
    reason?: SortOrderInput | SortOrder
    clinicalHistory?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studyId?: SortOrderInput | SortOrder
    _count?: RadiologyOrderCountOrderByAggregateInput
    _max?: RadiologyOrderMaxOrderByAggregateInput
    _min?: RadiologyOrderMinOrderByAggregateInput
  }

  export type RadiologyOrderScalarWhereWithAggregatesInput = {
    AND?: RadiologyOrderScalarWhereWithAggregatesInput | RadiologyOrderScalarWhereWithAggregatesInput[]
    OR?: RadiologyOrderScalarWhereWithAggregatesInput[]
    NOT?: RadiologyOrderScalarWhereWithAggregatesInput | RadiologyOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RadiologyOrder"> | string
    consultationId?: StringWithAggregatesFilter<"RadiologyOrder"> | string
    patientId?: StringWithAggregatesFilter<"RadiologyOrder"> | string
    doctorId?: StringWithAggregatesFilter<"RadiologyOrder"> | string
    modalityId?: StringWithAggregatesFilter<"RadiologyOrder"> | string
    studyType?: StringWithAggregatesFilter<"RadiologyOrder"> | string
    priority?: EnumPriorityWithAggregatesFilter<"RadiologyOrder"> | $Enums.Priority
    reason?: StringNullableWithAggregatesFilter<"RadiologyOrder"> | string | null
    clinicalHistory?: StringNullableWithAggregatesFilter<"RadiologyOrder"> | string | null
    status?: EnumRadiologyOrderStatusWithAggregatesFilter<"RadiologyOrder"> | $Enums.RadiologyOrderStatus
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"RadiologyOrder"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"RadiologyOrder"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"RadiologyOrder"> | boolean
    tenantId?: StringWithAggregatesFilter<"RadiologyOrder"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RadiologyOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RadiologyOrder"> | Date | string
    studyId?: StringNullableWithAggregatesFilter<"RadiologyOrder"> | string | null
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutDepartmentInput
    tenant: TenantCreateNestedOneWithoutDepartmentsInput
    staff?: StaffCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDepartmentInput
    staff?: StaffUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutDepartmentNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDepartmentsNestedInput
    staff?: StaffUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDepartmentNestedInput
    staff?: StaffUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialtyCreateInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSpecialtiesInput
  }

  export type SpecialtyUncheckedCreateInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialtyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSpecialtiesNestedInput
  }

  export type SpecialtyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialtyCreateManyInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialtyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialtyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffCreateInput = {
    id?: string
    employeeId?: string | null
    designation?: string | null
    joiningDate?: Date | string | null
    qualification?: string | null
    experience?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStaffInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    user: UserCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateInput = {
    id?: string
    userId: string
    employeeId?: string | null
    designation?: string | null
    departmentId?: string | null
    joiningDate?: Date | string | null
    qualification?: string | null
    experience?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStaffNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    user?: UserUpdateOneRequiredWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffCreateManyInput = {
    id?: string
    userId: string
    employeeId?: string | null
    designation?: string | null
    departmentId?: string | null
    joiningDate?: Date | string | null
    qualification?: string | null
    experience?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    staff?: StaffCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordCreateNestedManyWithoutUpdatedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderUncheckedCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    staff?: StaffUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUpdateManyWithoutUpdatedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUncheckedUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    staff?: StaffUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    jti: string
    token: string
    revoked?: boolean
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
    tenant: TenantCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    jti: string
    token: string
    userId: string
    revoked?: boolean
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
    tenant?: TenantUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    jti: string
    token: string
    userId: string
    revoked?: boolean
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutPatientInput
    studies?: StudyCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutPatientInput
    tenant: TenantCreateNestedOneWithoutPatientsInput
  }

  export type PatientUncheckedCreateInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    tenantId: string
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutPatientInput
    studies?: StudyUncheckedCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutPatientNestedInput
    studies?: StudyUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutPatientNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutPatientNestedInput
    studies?: StudyUncheckedUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    tenantId: string
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AppointmentCreateInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    status: $Enums.AppointmentStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAppointmentsInput
    department?: DepartmentCreateNestedOneWithoutAppointmentsInput
    doctor: UserCreateNestedOneWithoutDoctorAppointmentsInput
    patient: PatientCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: string
    patientId: string
    doctorId: string
    departmentId?: string | null
    startTime: Date | string
    endTime: Date | string
    status: $Enums.AppointmentStatus
    reason?: string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAppointmentsNestedInput
    department?: DepartmentUpdateOneWithoutAppointmentsNestedInput
    doctor?: UserUpdateOneRequiredWithoutDoctorAppointmentsNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyInput = {
    id?: string
    patientId: string
    doctorId: string
    departmentId?: string | null
    startTime: Date | string
    endTime: Date | string
    status: $Enums.AppointmentStatus
    reason?: string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionCreateInput = {
    id?: string
    diagnosis?: string | null
    notes?: string | null
    status?: $Enums.PrescriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPrescriptionsInput
    doctor: UserCreateNestedOneWithoutPrescriptionsInput
    patient: PatientCreateNestedOneWithoutPrescriptionsInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateInput = {
    id?: string
    patientId: string
    doctorId: string
    diagnosis?: string | null
    notes?: string | null
    status?: $Enums.PrescriptionStatus
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPrescriptionsNestedInput
    doctor?: UserUpdateOneRequiredWithoutPrescriptionsNestedInput
    patient?: PatientUpdateOneRequiredWithoutPrescriptionsNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionCreateManyInput = {
    id?: string
    patientId: string
    doctorId: string
    diagnosis?: string | null
    notes?: string | null
    status?: $Enums.PrescriptionStatus
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrescriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionItemCreateInput = {
    id?: string
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    isDispensed?: boolean
    tenant: TenantCreateNestedOneWithoutPrescriptionItemsInput
    patient: PatientCreateNestedOneWithoutPrescriptionItemsInput
    medication: MedicationCreateNestedOneWithoutPrescriptionItemsInput
    prescription: PrescriptionCreateNestedOneWithoutPrescriptionItemsInput
  }

  export type PrescriptionItemUncheckedCreateInput = {
    id?: string
    prescriptionId: string
    medicationId: string
    patientId: string
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    isDispensed?: boolean
    tenantId: string
  }

  export type PrescriptionItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    tenant?: TenantUpdateOneRequiredWithoutPrescriptionItemsNestedInput
    patient?: PatientUpdateOneRequiredWithoutPrescriptionItemsNestedInput
    medication?: MedicationUpdateOneRequiredWithoutPrescriptionItemsNestedInput
    prescription?: PrescriptionUpdateOneRequiredWithoutPrescriptionItemsNestedInput
  }

  export type PrescriptionItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionItemCreateManyInput = {
    id?: string
    prescriptionId: string
    medicationId: string
    patientId: string
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    isDispensed?: boolean
    tenantId: string
  }

  export type PrescriptionItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrescriptionItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type MedicalRecordCreateInput = {
    id?: string
    recordType: string
    title: string
    description?: string | null
    date?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMedicalRecordsInput
    patient: PatientCreateNestedOneWithoutMedicalRecordsInput
    doctor?: UserCreateNestedOneWithoutCreatedMedicalRecordsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedMedicalRecordsInput
  }

  export type MedicalRecordUncheckedCreateInput = {
    id?: string
    patientId: string
    recordType: string
    title: string
    description?: string | null
    date?: Date | string
    doctorId?: string | null
    updatedById?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMedicalRecordsNestedInput
    patient?: PatientUpdateOneRequiredWithoutMedicalRecordsNestedInput
    doctor?: UserUpdateOneWithoutCreatedMedicalRecordsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedMedicalRecordsNestedInput
  }

  export type MedicalRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordCreateManyInput = {
    id?: string
    patientId: string
    recordType: string
    title: string
    description?: string | null
    date?: Date | string
    doctorId?: string | null
    updatedById?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    subTotal?: number
    taxAmount?: number
    discountAmount?: number
    totalAmount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    patient: PatientCreateNestedOneWithoutInvoicesInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    pharmacyOrder?: PharmacyOrderCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    invoiceNumber: string
    patientId: string
    date?: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    subTotal?: number
    taxAmount?: number
    discountAmount?: number
    totalAmount?: number
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    pharmacyOrder?: PharmacyOrderUncheckedCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    patient?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    pharmacyOrder?: PharmacyOrderUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    pharmacyOrder?: PharmacyOrderUncheckedUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    invoiceNumber: string
    patientId: string
    date?: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    subTotal?: number
    taxAmount?: number
    discountAmount?: number
    totalAmount?: number
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceItemCreateInput = {
    id?: string
    itemType: string
    itemId: string
    description: string
    quantity?: number
    unitPrice: number
    discount?: number
    taxRate?: number
    totalAmount: number
    tenant: TenantCreateNestedOneWithoutInvoiceItemsInput
    invoice: InvoiceCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: string
    invoiceId: string
    itemType: string
    itemId: string
    description: string
    quantity?: number
    unitPrice: number
    discount?: number
    taxRate?: number
    totalAmount: number
    tenantId: string
  }

  export type InvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    tenant?: TenantUpdateOneRequiredWithoutInvoiceItemsNestedInput
    invoice?: InvoiceUpdateOneRequiredWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceItemCreateManyInput = {
    id?: string
    invoiceId: string
    itemType: string
    itemId: string
    description: string
    quantity?: number
    unitPrice: number
    discount?: number
    taxRate?: number
    totalAmount: number
    tenantId: string
  }

  export type InvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentCreateInput = {
    id?: string
    paymentNumber: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    referenceNumber?: string | null
    notes?: string | null
    status?: $Enums.PaymentStatus
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentsInput
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    paymentNumber: string
    invoiceId: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    referenceNumber?: string | null
    notes?: string | null
    status?: $Enums.PaymentStatus
    tenantId: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    paymentNumber: string
    invoiceId: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    referenceNumber?: string | null
    notes?: string | null
    status?: $Enums.PaymentStatus
    tenantId: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabTestCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    category: string
    price?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    labOrders?: LabOrderTestCreateNestedManyWithoutTestInput
    tenant: TenantCreateNestedOneWithoutLabTestsInput
  }

  export type LabTestUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    category: string
    price?: number | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    labOrders?: LabOrderTestUncheckedCreateNestedManyWithoutTestInput
  }

  export type LabTestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labOrders?: LabOrderTestUpdateManyWithoutTestNestedInput
    tenant?: TenantUpdateOneRequiredWithoutLabTestsNestedInput
  }

  export type LabTestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labOrders?: LabOrderTestUncheckedUpdateManyWithoutTestNestedInput
  }

  export type LabTestCreateManyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    category: string
    price?: number | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabTestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabTestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabOrderCreateInput = {
    id?: string
    orderNumber: string
    status?: $Enums.LabOrderStatus
    orderDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutLabOrdersInput
    doctor?: UserCreateNestedOneWithoutDoctorLabOrdersInput
    patient: PatientCreateNestedOneWithoutLabOrdersInput
    tests?: LabOrderTestCreateNestedManyWithoutOrderInput
    consultation?: TelemedicineConsultationCreateNestedOneWithoutLabOrdersInput
  }

  export type LabOrderUncheckedCreateInput = {
    id?: string
    orderNumber: string
    patientId: string
    doctorId?: string | null
    status?: $Enums.LabOrderStatus
    orderDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationId?: string | null
    tests?: LabOrderTestUncheckedCreateNestedManyWithoutOrderInput
  }

  export type LabOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutLabOrdersNestedInput
    doctor?: UserUpdateOneWithoutDoctorLabOrdersNestedInput
    patient?: PatientUpdateOneRequiredWithoutLabOrdersNestedInput
    tests?: LabOrderTestUpdateManyWithoutOrderNestedInput
    consultation?: TelemedicineConsultationUpdateOneWithoutLabOrdersNestedInput
  }

  export type LabOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    tests?: LabOrderTestUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderCreateManyInput = {
    id?: string
    orderNumber: string
    patientId: string
    doctorId?: string | null
    status?: $Enums.LabOrderStatus
    orderDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationId?: string | null
  }

  export type LabOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabOrderTestCreateInput = {
    id?: string
    status?: $Enums.LabTestStatus
    result?: string | null
    resultDate?: Date | string | null
    referenceRange?: string | null
    notes?: string | null
    tenant: TenantCreateNestedOneWithoutLabOrderTestsInput
    test: LabTestCreateNestedOneWithoutLabOrdersInput
    order: LabOrderCreateNestedOneWithoutTestsInput
  }

  export type LabOrderTestUncheckedCreateInput = {
    id?: string
    orderId: string
    testId: string
    status?: $Enums.LabTestStatus
    result?: string | null
    resultDate?: Date | string | null
    referenceRange?: string | null
    notes?: string | null
    tenantId: string
  }

  export type LabOrderTestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLabTestStatusFieldUpdateOperationsInput | $Enums.LabTestStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutLabOrderTestsNestedInput
    test?: LabTestUpdateOneRequiredWithoutLabOrdersNestedInput
    order?: LabOrderUpdateOneRequiredWithoutTestsNestedInput
  }

  export type LabOrderTestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumLabTestStatusFieldUpdateOperationsInput | $Enums.LabTestStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type LabOrderTestCreateManyInput = {
    id?: string
    orderId: string
    testId: string
    status?: $Enums.LabTestStatus
    result?: string | null
    resultDate?: Date | string | null
    referenceRange?: string | null
    notes?: string | null
    tenantId: string
  }

  export type LabOrderTestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLabTestStatusFieldUpdateOperationsInput | $Enums.LabTestStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabOrderTestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumLabTestStatusFieldUpdateOperationsInput | $Enums.LabTestStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type MedicationCreateInput = {
    id?: string
    name: string
    genericName?: string | null
    description?: string | null
    strength?: string | null
    unit?: string | null
    dosageForm?: string | null
    route?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMedicationsInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutMedicationInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutMedicationInput
  }

  export type MedicationUncheckedCreateInput = {
    id?: string
    name: string
    genericName?: string | null
    description?: string | null
    strength?: string | null
    unit?: string | null
    dosageForm?: string | null
    route?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutMedicationInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutMedicationInput
  }

  export type MedicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMedicationsNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutMedicationNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutMedicationNestedInput
  }

  export type MedicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutMedicationNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutMedicationNestedInput
  }

  export type MedicationCreateManyInput = {
    id?: string
    name: string
    genericName?: string | null
    description?: string | null
    strength?: string | null
    unit?: string | null
    dosageForm?: string | null
    route?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PharmacyOrderCreateInput = {
    id?: string
    orderNumber: string
    status?: $Enums.PharmacyOrderStatus
    orderDate?: Date | string
    dispensedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    tenant: TenantCreateNestedOneWithoutPharmacyOrdersInput
    doctor?: UserCreateNestedOneWithoutDoctorPrescriptionsInput
    patient: PatientCreateNestedOneWithoutPharmacyOrdersInput
    invoice?: InvoiceCreateNestedOneWithoutPharmacyOrderInput
    items?: PharmacyOrderItemCreateNestedManyWithoutOrderInput
  }

  export type PharmacyOrderUncheckedCreateInput = {
    id?: string
    orderNumber: string
    patientId: string
    doctorId?: string | null
    status?: $Enums.PharmacyOrderStatus
    orderDate?: Date | string
    dispensedDate?: Date | string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    items?: PharmacyOrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type PharmacyOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumPharmacyOrderStatusFieldUpdateOperationsInput | $Enums.PharmacyOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dispensedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutPharmacyOrdersNestedInput
    doctor?: UserUpdateOneWithoutDoctorPrescriptionsNestedInput
    patient?: PatientUpdateOneRequiredWithoutPharmacyOrdersNestedInput
    invoice?: InvoiceUpdateOneWithoutPharmacyOrderNestedInput
    items?: PharmacyOrderItemUpdateManyWithoutOrderNestedInput
  }

  export type PharmacyOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPharmacyOrderStatusFieldUpdateOperationsInput | $Enums.PharmacyOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dispensedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    items?: PharmacyOrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type PharmacyOrderCreateManyInput = {
    id?: string
    orderNumber: string
    patientId: string
    doctorId?: string | null
    status?: $Enums.PharmacyOrderStatus
    orderDate?: Date | string
    dispensedDate?: Date | string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type PharmacyOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumPharmacyOrderStatusFieldUpdateOperationsInput | $Enums.PharmacyOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dispensedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PharmacyOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPharmacyOrderStatusFieldUpdateOperationsInput | $Enums.PharmacyOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dispensedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PharmacyOrderItemCreateInput = {
    id?: string
    quantity?: number
    dosage?: string | null
    frequency?: string | null
    duration?: string | null
    instructions?: string | null
    status?: $Enums.PharmacyItemStatus
    tenant: TenantCreateNestedOneWithoutPharmacyOrderItemsInput
    medication: MedicationCreateNestedOneWithoutPharmacyOrderItemsInput
    order: PharmacyOrderCreateNestedOneWithoutItemsInput
  }

  export type PharmacyOrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    medicationId: string
    quantity?: number
    dosage?: string | null
    frequency?: string | null
    duration?: string | null
    instructions?: string | null
    status?: $Enums.PharmacyItemStatus
    tenantId: string
  }

  export type PharmacyOrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPharmacyItemStatusFieldUpdateOperationsInput | $Enums.PharmacyItemStatus
    tenant?: TenantUpdateOneRequiredWithoutPharmacyOrderItemsNestedInput
    medication?: MedicationUpdateOneRequiredWithoutPharmacyOrderItemsNestedInput
    order?: PharmacyOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PharmacyOrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPharmacyItemStatusFieldUpdateOperationsInput | $Enums.PharmacyItemStatus
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type PharmacyOrderItemCreateManyInput = {
    id?: string
    orderId: string
    medicationId: string
    quantity?: number
    dosage?: string | null
    frequency?: string | null
    duration?: string | null
    instructions?: string | null
    status?: $Enums.PharmacyItemStatus
    tenantId: string
  }

  export type PharmacyOrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPharmacyItemStatusFieldUpdateOperationsInput | $Enums.PharmacyItemStatus
  }

  export type PharmacyOrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPharmacyItemStatusFieldUpdateOperationsInput | $Enums.PharmacyItemStatus
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType?: string | null
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAuditLogsInput
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    entityType?: string | null
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    tenantId: string
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAuditLogsNestedInput
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    entityType?: string | null
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    tenantId: string
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModalityCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studies?: StudyCreateNestedManyWithoutModalityInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutModalityInput
  }

  export type ModalityUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studies?: StudyUncheckedCreateNestedManyWithoutModalityInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutModalityInput
  }

  export type ModalityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studies?: StudyUpdateManyWithoutModalityNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutModalityNestedInput
  }

  export type ModalityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studies?: StudyUncheckedUpdateManyWithoutModalityNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutModalityNestedInput
  }

  export type ModalityCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModalityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModalityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyCreateInput = {
    id?: string
    studyId: string
    patientName: string
    status?: $Enums.StudyStatus
    studyDate?: Date | string
    priority?: $Enums.Priority | null
    description?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modality: ModalityCreateNestedOneWithoutStudiesInput
    patient: PatientCreateNestedOneWithoutStudiesInput
    tenant: TenantCreateNestedOneWithoutStudiesInput
    series?: SeriesCreateNestedManyWithoutStudyInput
    radReports?: RadReportCreateNestedManyWithoutStudyInput
    radiationDoses?: RadiationDoseCreateNestedManyWithoutStudyInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutStudyInput
  }

  export type StudyUncheckedCreateInput = {
    id?: string
    studyId: string
    patientId: string
    patientName: string
    modalityId: string
    status?: $Enums.StudyStatus
    studyDate?: Date | string
    priority?: $Enums.Priority | null
    description?: string | null
    notes?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    series?: SeriesUncheckedCreateNestedManyWithoutStudyInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutStudyInput
    radiationDoses?: RadiationDoseUncheckedCreateNestedManyWithoutStudyInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutStudyInput
  }

  export type StudyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    patientName?: StringFieldUpdateOperationsInput | string
    status?: EnumStudyStatusFieldUpdateOperationsInput | $Enums.StudyStatus
    studyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modality?: ModalityUpdateOneRequiredWithoutStudiesNestedInput
    patient?: PatientUpdateOneRequiredWithoutStudiesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutStudiesNestedInput
    series?: SeriesUpdateManyWithoutStudyNestedInput
    radReports?: RadReportUpdateManyWithoutStudyNestedInput
    radiationDoses?: RadiationDoseUpdateManyWithoutStudyNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutStudyNestedInput
  }

  export type StudyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientName?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    status?: EnumStudyStatusFieldUpdateOperationsInput | $Enums.StudyStatus
    studyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: SeriesUncheckedUpdateManyWithoutStudyNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutStudyNestedInput
    radiationDoses?: RadiationDoseUncheckedUpdateManyWithoutStudyNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutStudyNestedInput
  }

  export type StudyCreateManyInput = {
    id?: string
    studyId: string
    patientId: string
    patientName: string
    modalityId: string
    status?: $Enums.StudyStatus
    studyDate?: Date | string
    priority?: $Enums.Priority | null
    description?: string | null
    notes?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    patientName?: StringFieldUpdateOperationsInput | string
    status?: EnumStudyStatusFieldUpdateOperationsInput | $Enums.StudyStatus
    studyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientName?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    status?: EnumStudyStatusFieldUpdateOperationsInput | $Enums.StudyStatus
    studyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeriesCreateInput = {
    id?: string
    seriesUid: string
    number: number
    description?: string | null
    modality: string
    bodyPart?: string | null
    count?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    study: StudyCreateNestedOneWithoutSeriesInput
    images?: ImageCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUncheckedCreateInput = {
    id?: string
    seriesUid: string
    studyId: string
    number: number
    description?: string | null
    modality: string
    bodyPart?: string | null
    count?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesUid?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    modality?: StringFieldUpdateOperationsInput | string
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    count?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    study?: StudyUpdateOneRequiredWithoutSeriesNestedInput
    images?: ImageUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesUid?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    modality?: StringFieldUpdateOperationsInput | string
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    count?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesCreateManyInput = {
    id?: string
    seriesUid: string
    studyId: string
    number: number
    description?: string | null
    modality: string
    bodyPart?: string | null
    count?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesUid?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    modality?: StringFieldUpdateOperationsInput | string
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    count?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesUid?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    modality?: StringFieldUpdateOperationsInput | string
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    count?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageCreateInput = {
    id?: string
    sopInstanceUid: string
    number: number
    path: string
    size: number
    contentType: string
    width: number
    height: number
    windowCenter?: number | null
    windowWidth?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    series: SeriesCreateNestedOneWithoutImagesInput
  }

  export type ImageUncheckedCreateInput = {
    id?: string
    sopInstanceUid: string
    seriesId: string
    number: number
    path: string
    size: number
    contentType: string
    width: number
    height: number
    windowCenter?: number | null
    windowWidth?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sopInstanceUid?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentType?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    windowCenter?: NullableFloatFieldUpdateOperationsInput | number | null
    windowWidth?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: SeriesUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sopInstanceUid?: StringFieldUpdateOperationsInput | string
    seriesId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentType?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    windowCenter?: NullableFloatFieldUpdateOperationsInput | number | null
    windowWidth?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageCreateManyInput = {
    id?: string
    sopInstanceUid: string
    seriesId: string
    number: number
    path: string
    size: number
    contentType: string
    width: number
    height: number
    windowCenter?: number | null
    windowWidth?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sopInstanceUid?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentType?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    windowCenter?: NullableFloatFieldUpdateOperationsInput | number | null
    windowWidth?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sopInstanceUid?: StringFieldUpdateOperationsInput | string
    seriesId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentType?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    windowCenter?: NullableFloatFieldUpdateOperationsInput | number | null
    windowWidth?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadReportCreateInput = {
    id?: string
    reportId: string
    status?: $Enums.ReportStatus
    findings?: string | null
    impression?: string | null
    conclusion?: string | null
    reportDateTime?: Date | string
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    study: StudyCreateNestedOneWithoutRadReportsInput
    tenant: TenantCreateNestedOneWithoutRadReportsInput
    reportTemplate?: ReportTemplateCreateNestedOneWithoutRadReportsInput
  }

  export type RadReportUncheckedCreateInput = {
    id?: string
    reportId: string
    studyId: string
    reportTemplateId?: string | null
    status?: $Enums.ReportStatus
    findings?: string | null
    impression?: string | null
    conclusion?: string | null
    reportDateTime?: Date | string
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conclusion?: NullableStringFieldUpdateOperationsInput | string | null
    reportDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    study?: StudyUpdateOneRequiredWithoutRadReportsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutRadReportsNestedInput
    reportTemplate?: ReportTemplateUpdateOneWithoutRadReportsNestedInput
  }

  export type RadReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    reportTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conclusion?: NullableStringFieldUpdateOperationsInput | string | null
    reportDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadReportCreateManyInput = {
    id?: string
    reportId: string
    studyId: string
    reportTemplateId?: string | null
    status?: $Enums.ReportStatus
    findings?: string | null
    impression?: string | null
    conclusion?: string | null
    reportDateTime?: Date | string
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conclusion?: NullableStringFieldUpdateOperationsInput | string | null
    reportDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    reportTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conclusion?: NullableStringFieldUpdateOperationsInput | string | null
    reportDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiationDoseCreateInput = {
    id?: string
    deviceName?: string | null
    deviceType?: string | null
    exposureTime?: number | null
    kvp?: number | null
    ma?: number | null
    doseAreaProduct?: number | null
    doseLengthProduct?: number | null
    ctdiVol?: number | null
    dlp?: number | null
    effectiveDose?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    study: StudyCreateNestedOneWithoutRadiationDosesInput
  }

  export type RadiationDoseUncheckedCreateInput = {
    id?: string
    studyId: string
    deviceName?: string | null
    deviceType?: string | null
    exposureTime?: number | null
    kvp?: number | null
    ma?: number | null
    doseAreaProduct?: number | null
    doseLengthProduct?: number | null
    ctdiVol?: number | null
    dlp?: number | null
    effectiveDose?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiationDoseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    exposureTime?: NullableFloatFieldUpdateOperationsInput | number | null
    kvp?: NullableFloatFieldUpdateOperationsInput | number | null
    ma?: NullableFloatFieldUpdateOperationsInput | number | null
    doseAreaProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    doseLengthProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    ctdiVol?: NullableFloatFieldUpdateOperationsInput | number | null
    dlp?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveDose?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    study?: StudyUpdateOneRequiredWithoutRadiationDosesNestedInput
  }

  export type RadiationDoseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    exposureTime?: NullableFloatFieldUpdateOperationsInput | number | null
    kvp?: NullableFloatFieldUpdateOperationsInput | number | null
    ma?: NullableFloatFieldUpdateOperationsInput | number | null
    doseAreaProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    doseLengthProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    ctdiVol?: NullableFloatFieldUpdateOperationsInput | number | null
    dlp?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveDose?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiationDoseCreateManyInput = {
    id?: string
    studyId: string
    deviceName?: string | null
    deviceType?: string | null
    exposureTime?: number | null
    kvp?: number | null
    ma?: number | null
    doseAreaProduct?: number | null
    doseLengthProduct?: number | null
    ctdiVol?: number | null
    dlp?: number | null
    effectiveDose?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiationDoseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    exposureTime?: NullableFloatFieldUpdateOperationsInput | number | null
    kvp?: NullableFloatFieldUpdateOperationsInput | number | null
    ma?: NullableFloatFieldUpdateOperationsInput | number | null
    doseAreaProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    doseLengthProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    ctdiVol?: NullableFloatFieldUpdateOperationsInput | number | null
    dlp?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveDose?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiationDoseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    exposureTime?: NullableFloatFieldUpdateOperationsInput | number | null
    kvp?: NullableFloatFieldUpdateOperationsInput | number | null
    ma?: NullableFloatFieldUpdateOperationsInput | number | null
    doseAreaProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    doseLengthProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    ctdiVol?: NullableFloatFieldUpdateOperationsInput | number | null
    dlp?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveDose?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    template: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutReportTemplatesInput
    radReports?: RadReportCreateNestedManyWithoutReportTemplateInput
  }

  export type ReportTemplateUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    template: string
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    radReports?: RadReportUncheckedCreateNestedManyWithoutReportTemplateInput
  }

  export type ReportTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    template?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutReportTemplatesNestedInput
    radReports?: RadReportUpdateManyWithoutReportTemplateNestedInput
  }

  export type ReportTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    template?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    radReports?: RadReportUncheckedUpdateManyWithoutReportTemplateNestedInput
  }

  export type ReportTemplateCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    template: string
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    template?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    template?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelemedicineConsultationCreateInput = {
    id?: string
    status?: $Enums.TelemedicineStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    consultationType?: $Enums.ConsultationType
    reason?: string | null
    notes?: string | null
    prescription?: string | null
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    isEmergency?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutTelemedicineConsultationsInput
    doctor?: UserCreateNestedOneWithoutDoctorTelemedicineInput
    tenant: TenantCreateNestedOneWithoutTelemedicineConsultationsInput
    videoRoom?: VideoRoomCreateNestedOneWithoutConsultationInput
    labOrders?: LabOrderCreateNestedManyWithoutConsultationInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutConsultationInput
  }

  export type TelemedicineConsultationUncheckedCreateInput = {
    id?: string
    patientId: string
    doctorId?: string | null
    status?: $Enums.TelemedicineStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    consultationType?: $Enums.ConsultationType
    reason?: string | null
    notes?: string | null
    prescription?: string | null
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    isEmergency?: boolean
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    videoRoom?: VideoRoomUncheckedCreateNestedOneWithoutConsultationInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutConsultationInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type TelemedicineConsultationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTelemedicineStatusFieldUpdateOperationsInput | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    consultationType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutTelemedicineConsultationsNestedInput
    doctor?: UserUpdateOneWithoutDoctorTelemedicineNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTelemedicineConsultationsNestedInput
    videoRoom?: VideoRoomUpdateOneWithoutConsultationNestedInput
    labOrders?: LabOrderUpdateManyWithoutConsultationNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutConsultationNestedInput
  }

  export type TelemedicineConsultationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTelemedicineStatusFieldUpdateOperationsInput | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    consultationType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoRoom?: VideoRoomUncheckedUpdateOneWithoutConsultationNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutConsultationNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type TelemedicineConsultationCreateManyInput = {
    id?: string
    patientId: string
    doctorId?: string | null
    status?: $Enums.TelemedicineStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    consultationType?: $Enums.ConsultationType
    reason?: string | null
    notes?: string | null
    prescription?: string | null
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    isEmergency?: boolean
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelemedicineConsultationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTelemedicineStatusFieldUpdateOperationsInput | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    consultationType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelemedicineConsultationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTelemedicineStatusFieldUpdateOperationsInput | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    consultationType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoRoomCreateInput = {
    id?: string
    roomId: string
    status?: $Enums.VideoRoomStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    maxParticipants?: number
    recordingEnabled?: boolean
    recordingUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    consultation: TelemedicineConsultationCreateNestedOneWithoutVideoRoomInput
    tenant: TenantCreateNestedOneWithoutVideoRoomsInput
    participants?: VideoParticipantCreateNestedManyWithoutRoomInput
    recordings?: VideoRecordingCreateNestedManyWithoutRoomInput
  }

  export type VideoRoomUncheckedCreateInput = {
    id?: string
    consultationId: string
    roomId: string
    status?: $Enums.VideoRoomStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    maxParticipants?: number
    recordingEnabled?: boolean
    recordingUrl?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: VideoParticipantUncheckedCreateNestedManyWithoutRoomInput
    recordings?: VideoRecordingUncheckedCreateNestedManyWithoutRoomInput
  }

  export type VideoRoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    status?: EnumVideoRoomStatusFieldUpdateOperationsInput | $Enums.VideoRoomStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultation?: TelemedicineConsultationUpdateOneRequiredWithoutVideoRoomNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVideoRoomsNestedInput
    participants?: VideoParticipantUpdateManyWithoutRoomNestedInput
    recordings?: VideoRecordingUpdateManyWithoutRoomNestedInput
  }

  export type VideoRoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    status?: EnumVideoRoomStatusFieldUpdateOperationsInput | $Enums.VideoRoomStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: VideoParticipantUncheckedUpdateManyWithoutRoomNestedInput
    recordings?: VideoRecordingUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type VideoRoomCreateManyInput = {
    id?: string
    consultationId: string
    roomId: string
    status?: $Enums.VideoRoomStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    maxParticipants?: number
    recordingEnabled?: boolean
    recordingUrl?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoRoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    status?: EnumVideoRoomStatusFieldUpdateOperationsInput | $Enums.VideoRoomStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoRoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    status?: EnumVideoRoomStatusFieldUpdateOperationsInput | $Enums.VideoRoomStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoParticipantCreateInput = {
    id?: string
    userId: string
    participantType: $Enums.ParticipantType
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    room: VideoRoomCreateNestedOneWithoutParticipantsInput
    tenant: TenantCreateNestedOneWithoutVideoParticipantsInput
  }

  export type VideoParticipantUncheckedCreateInput = {
    id?: string
    roomId: string
    userId: string
    participantType: $Enums.ParticipantType
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: VideoRoomUpdateOneRequiredWithoutParticipantsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVideoParticipantsNestedInput
  }

  export type VideoParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoParticipantCreateManyInput = {
    id?: string
    roomId: string
    userId: string
    participantType: $Enums.ParticipantType
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoRecordingCreateInput = {
    id?: string
    fileName: string
    filePath: string
    fileSize: number
    duration?: number | null
    status?: $Enums.RecordingStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    room: VideoRoomCreateNestedOneWithoutRecordingsInput
    tenant: TenantCreateNestedOneWithoutVideoRecordingsInput
  }

  export type VideoRecordingUncheckedCreateInput = {
    id?: string
    roomId: string
    fileName: string
    filePath: string
    fileSize: number
    duration?: number | null
    status?: $Enums.RecordingStatus
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoRecordingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: VideoRoomUpdateOneRequiredWithoutRecordingsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVideoRecordingsNestedInput
  }

  export type VideoRecordingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoRecordingCreateManyInput = {
    id?: string
    roomId: string
    fileName: string
    filePath: string
    fileSize: number
    duration?: number | null
    status?: $Enums.RecordingStatus
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoRecordingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoRecordingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoMessageCreateInput = {
    id?: string
    roomId: string
    senderId: string
    message: string
    messageType?: $Enums.MessageType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVideoMessagesInput
  }

  export type VideoMessageUncheckedCreateInput = {
    id?: string
    roomId: string
    senderId: string
    message: string
    messageType?: $Enums.MessageType
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVideoMessagesNestedInput
  }

  export type VideoMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoMessageCreateManyInput = {
    id?: string
    roomId: string
    senderId: string
    message: string
    messageType?: $Enums.MessageType
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiologyOrderCreateInput = {
    id?: string
    studyType: string
    priority?: $Enums.Priority
    reason?: string | null
    clinicalHistory?: string | null
    status?: $Enums.RadiologyOrderStatus
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    consultation: TelemedicineConsultationCreateNestedOneWithoutRadiologyOrdersInput
    patient: PatientCreateNestedOneWithoutRadiologyOrdersInput
    doctor: UserCreateNestedOneWithoutDoctorRadiologyOrdersInput
    modality: ModalityCreateNestedOneWithoutRadiologyOrdersInput
    tenant: TenantCreateNestedOneWithoutRadiologyOrdersInput
    study?: StudyCreateNestedOneWithoutRadiologyOrdersInput
  }

  export type RadiologyOrderUncheckedCreateInput = {
    id?: string
    consultationId: string
    patientId: string
    doctorId: string
    modalityId: string
    studyType: string
    priority?: $Enums.Priority
    reason?: string | null
    clinicalHistory?: string | null
    status?: $Enums.RadiologyOrderStatus
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studyId?: string | null
  }

  export type RadiologyOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultation?: TelemedicineConsultationUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    patient?: PatientUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    doctor?: UserUpdateOneRequiredWithoutDoctorRadiologyOrdersNestedInput
    modality?: ModalityUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    tenant?: TenantUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    study?: StudyUpdateOneWithoutRadiologyOrdersNestedInput
  }

  export type RadiologyOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RadiologyOrderCreateManyInput = {
    id?: string
    consultationId: string
    patientId: string
    doctorId: string
    modalityId: string
    studyType: string
    priority?: $Enums.Priority
    reason?: string | null
    clinicalHistory?: string | null
    status?: $Enums.RadiologyOrderStatus
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studyId?: string | null
  }

  export type RadiologyOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiologyOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type StaffListRelationFilter = {
    every?: StaffWhereInput
    some?: StaffWhereInput
    none?: StaffWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type SpecialtyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialtyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialtyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type StaffCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    designation?: SortOrder
    departmentId?: SortOrder
    joiningDate?: SortOrder
    qualification?: SortOrder
    experience?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    designation?: SortOrder
    departmentId?: SortOrder
    joiningDate?: SortOrder
    qualification?: SortOrder
    experience?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    designation?: SortOrder
    departmentId?: SortOrder
    joiningDate?: SortOrder
    qualification?: SortOrder
    experience?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumTenantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantType | EnumTenantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantTypeFilter<$PrismaModel> | $Enums.TenantType
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type LabOrderListRelationFilter = {
    every?: LabOrderWhereInput
    some?: LabOrderWhereInput
    none?: LabOrderWhereInput
  }

  export type LabOrderTestListRelationFilter = {
    every?: LabOrderTestWhereInput
    some?: LabOrderTestWhereInput
    none?: LabOrderTestWhereInput
  }

  export type LabTestListRelationFilter = {
    every?: LabTestWhereInput
    some?: LabTestWhereInput
    none?: LabTestWhereInput
  }

  export type MedicalRecordListRelationFilter = {
    every?: MedicalRecordWhereInput
    some?: MedicalRecordWhereInput
    none?: MedicalRecordWhereInput
  }

  export type MedicationListRelationFilter = {
    every?: MedicationWhereInput
    some?: MedicationWhereInput
    none?: MedicationWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PharmacyOrderListRelationFilter = {
    every?: PharmacyOrderWhereInput
    some?: PharmacyOrderWhereInput
    none?: PharmacyOrderWhereInput
  }

  export type PharmacyOrderItemListRelationFilter = {
    every?: PharmacyOrderItemWhereInput
    some?: PharmacyOrderItemWhereInput
    none?: PharmacyOrderItemWhereInput
  }

  export type PrescriptionListRelationFilter = {
    every?: PrescriptionWhereInput
    some?: PrescriptionWhereInput
    none?: PrescriptionWhereInput
  }

  export type PrescriptionItemListRelationFilter = {
    every?: PrescriptionItemWhereInput
    some?: PrescriptionItemWhereInput
    none?: PrescriptionItemWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type SpecialtyListRelationFilter = {
    every?: SpecialtyWhereInput
    some?: SpecialtyWhereInput
    none?: SpecialtyWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type PatientListRelationFilter = {
    every?: PatientWhereInput
    some?: PatientWhereInput
    none?: PatientWhereInput
  }

  export type StudyListRelationFilter = {
    every?: StudyWhereInput
    some?: StudyWhereInput
    none?: StudyWhereInput
  }

  export type RadReportListRelationFilter = {
    every?: RadReportWhereInput
    some?: RadReportWhereInput
    none?: RadReportWhereInput
  }

  export type ReportTemplateListRelationFilter = {
    every?: ReportTemplateWhereInput
    some?: ReportTemplateWhereInput
    none?: ReportTemplateWhereInput
  }

  export type TelemedicineConsultationListRelationFilter = {
    every?: TelemedicineConsultationWhereInput
    some?: TelemedicineConsultationWhereInput
    none?: TelemedicineConsultationWhereInput
  }

  export type VideoRoomListRelationFilter = {
    every?: VideoRoomWhereInput
    some?: VideoRoomWhereInput
    none?: VideoRoomWhereInput
  }

  export type VideoParticipantListRelationFilter = {
    every?: VideoParticipantWhereInput
    some?: VideoParticipantWhereInput
    none?: VideoParticipantWhereInput
  }

  export type VideoRecordingListRelationFilter = {
    every?: VideoRecordingWhereInput
    some?: VideoRecordingWhereInput
    none?: VideoRecordingWhereInput
  }

  export type VideoMessageListRelationFilter = {
    every?: VideoMessageWhereInput
    some?: VideoMessageWhereInput
    none?: VideoMessageWhereInput
  }

  export type RadiologyOrderListRelationFilter = {
    every?: RadiologyOrderWhereInput
    some?: RadiologyOrderWhereInput
    none?: RadiologyOrderWhereInput
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabOrderTestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabTestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicalRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PharmacyOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PharmacyOrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrescriptionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpecialtyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RadReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TelemedicineConsultationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoRoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoRecordingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RadiologyOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    logo?: SortOrder
    deletedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    logo?: SortOrder
    deletedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    type?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    logo?: SortOrder
    deletedAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTenantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantType | EnumTenantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantTypeWithAggregatesFilter<$PrismaModel> | $Enums.TenantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantTypeFilter<$PrismaModel>
    _max?: NestedEnumTenantTypeFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StaffNullableScalarRelationFilter = {
    is?: StaffWhereInput | null
    isNot?: StaffWhereInput | null
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    specialization?: SortOrder
    experience?: SortOrder
    licenseNumber?: SortOrder
    signature?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    deletedAt?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    experience?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    specialization?: SortOrder
    experience?: SortOrder
    licenseNumber?: SortOrder
    signature?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    deletedAt?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    specialization?: SortOrder
    experience?: SortOrder
    licenseNumber?: SortOrder
    signature?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    deletedAt?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    experience?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    jti?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    revoked?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    jti?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    revoked?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    jti?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    revoked?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type EnumBloodTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BloodType | EnumBloodTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.BloodType[] | ListEnumBloodTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BloodType[] | ListEnumBloodTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBloodTypeNullableFilter<$PrismaModel> | $Enums.BloodType | null
  }

  export type EnumMaritalStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableFilter<$PrismaModel> | $Enums.MaritalStatus | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumInsuranceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.InsuranceType | EnumInsuranceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.InsuranceType[] | ListEnumInsuranceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InsuranceType[] | ListEnumInsuranceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInsuranceTypeNullableFilter<$PrismaModel> | $Enums.InsuranceType | null
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    medicalRecordNumber?: SortOrder
    registrationNumber?: SortOrder
    externalId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodType?: SortOrder
    maritalStatus?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    phoneVerified?: SortOrder
    emailVerified?: SortOrder
    allergies?: SortOrder
    chronicConditions?: SortOrder
    currentMedications?: SortOrder
    knownAllergies?: SortOrder
    familyHistory?: SortOrder
    insuranceProvider?: SortOrder
    insuranceId?: SortOrder
    insuranceGroup?: SortOrder
    insuranceValidUntil?: SortOrder
    insuranceType?: SortOrder
    tenantId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    medicalRecordNumber?: SortOrder
    registrationNumber?: SortOrder
    externalId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodType?: SortOrder
    maritalStatus?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    phoneVerified?: SortOrder
    emailVerified?: SortOrder
    insuranceProvider?: SortOrder
    insuranceId?: SortOrder
    insuranceGroup?: SortOrder
    insuranceValidUntil?: SortOrder
    insuranceType?: SortOrder
    tenantId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    medicalRecordNumber?: SortOrder
    registrationNumber?: SortOrder
    externalId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodType?: SortOrder
    maritalStatus?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    pincode?: SortOrder
    phoneVerified?: SortOrder
    emailVerified?: SortOrder
    insuranceProvider?: SortOrder
    insuranceId?: SortOrder
    insuranceGroup?: SortOrder
    insuranceValidUntil?: SortOrder
    insuranceType?: SortOrder
    tenantId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
    isActive?: SortOrder
    isVerified?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type EnumBloodTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BloodType | EnumBloodTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.BloodType[] | ListEnumBloodTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BloodType[] | ListEnumBloodTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBloodTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.BloodType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBloodTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumBloodTypeNullableFilter<$PrismaModel>
  }

  export type EnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.MaritalStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumInsuranceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsuranceType | EnumInsuranceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.InsuranceType[] | ListEnumInsuranceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InsuranceType[] | ListEnumInsuranceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInsuranceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.InsuranceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumInsuranceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumInsuranceTypeNullableFilter<$PrismaModel>
  }

  export type EnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type PatientScalarRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    departmentId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    departmentId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    departmentId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type EnumPrescriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PrescriptionStatus | EnumPrescriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPrescriptionStatusFilter<$PrismaModel> | $Enums.PrescriptionStatus
  }

  export type PrescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    diagnosis?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    diagnosis?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    diagnosis?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPrescriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrescriptionStatus | EnumPrescriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPrescriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.PrescriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrescriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumPrescriptionStatusFilter<$PrismaModel>
  }

  export type MedicationScalarRelationFilter = {
    is?: MedicationWhereInput
    isNot?: MedicationWhereInput
  }

  export type PrescriptionScalarRelationFilter = {
    is?: PrescriptionWhereInput
    isNot?: PrescriptionWhereInput
  }

  export type PrescriptionItemCountOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    medicationId?: SortOrder
    patientId?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instructions?: SortOrder
    isDispensed?: SortOrder
    tenantId?: SortOrder
  }

  export type PrescriptionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    medicationId?: SortOrder
    patientId?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instructions?: SortOrder
    isDispensed?: SortOrder
    tenantId?: SortOrder
  }

  export type PrescriptionItemMinOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    medicationId?: SortOrder
    patientId?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instructions?: SortOrder
    isDispensed?: SortOrder
    tenantId?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type MedicalRecordCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    recordType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    doctorId?: SortOrder
    updatedById?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    recordType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    doctorId?: SortOrder
    updatedById?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalRecordMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    recordType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    doctorId?: SortOrder
    updatedById?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type PharmacyOrderNullableScalarRelationFilter = {
    is?: PharmacyOrderWhereInput | null
    isNot?: PharmacyOrderWhereInput | null
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    subTotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    subTotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    subTotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    patientId?: SortOrder
    date?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    subTotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    totalAmount?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    subTotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    taxRate?: SortOrder
    totalAmount?: SortOrder
    tenantId?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    taxRate?: SortOrder
    totalAmount?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    taxRate?: SortOrder
    totalAmount?: SortOrder
    tenantId?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemType?: SortOrder
    itemId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    taxRate?: SortOrder
    totalAmount?: SortOrder
    tenantId?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    discount?: SortOrder
    taxRate?: SortOrder
    totalAmount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    paymentNumber?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    referenceNumber?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentNumber?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    referenceNumber?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    paymentNumber?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    referenceNumber?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type LabTestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LabTestAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type LabTestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LabTestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LabTestSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumLabOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LabOrderStatus | EnumLabOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabOrderStatus[] | ListEnumLabOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabOrderStatus[] | ListEnumLabOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabOrderStatusFilter<$PrismaModel> | $Enums.LabOrderStatus
  }

  export type TelemedicineConsultationNullableScalarRelationFilter = {
    is?: TelemedicineConsultationWhereInput | null
    isNot?: TelemedicineConsultationWhereInput | null
  }

  export type LabOrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    completedDate?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    consultationId?: SortOrder
  }

  export type LabOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    completedDate?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    consultationId?: SortOrder
  }

  export type LabOrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    completedDate?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    consultationId?: SortOrder
  }

  export type EnumLabOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LabOrderStatus | EnumLabOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabOrderStatus[] | ListEnumLabOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabOrderStatus[] | ListEnumLabOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.LabOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumLabOrderStatusFilter<$PrismaModel>
  }

  export type EnumLabTestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LabTestStatus | EnumLabTestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabTestStatus[] | ListEnumLabTestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabTestStatus[] | ListEnumLabTestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabTestStatusFilter<$PrismaModel> | $Enums.LabTestStatus
  }

  export type LabTestScalarRelationFilter = {
    is?: LabTestWhereInput
    isNot?: LabTestWhereInput
  }

  export type LabOrderScalarRelationFilter = {
    is?: LabOrderWhereInput
    isNot?: LabOrderWhereInput
  }

  export type LabOrderTestCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    result?: SortOrder
    resultDate?: SortOrder
    referenceRange?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
  }

  export type LabOrderTestMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    result?: SortOrder
    resultDate?: SortOrder
    referenceRange?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
  }

  export type LabOrderTestMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    testId?: SortOrder
    status?: SortOrder
    result?: SortOrder
    resultDate?: SortOrder
    referenceRange?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
  }

  export type EnumLabTestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LabTestStatus | EnumLabTestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabTestStatus[] | ListEnumLabTestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabTestStatus[] | ListEnumLabTestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabTestStatusWithAggregatesFilter<$PrismaModel> | $Enums.LabTestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabTestStatusFilter<$PrismaModel>
    _max?: NestedEnumLabTestStatusFilter<$PrismaModel>
  }

  export type MedicationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genericName?: SortOrder
    description?: SortOrder
    strength?: SortOrder
    unit?: SortOrder
    dosageForm?: SortOrder
    route?: SortOrder
    schedule?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genericName?: SortOrder
    description?: SortOrder
    strength?: SortOrder
    unit?: SortOrder
    dosageForm?: SortOrder
    route?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genericName?: SortOrder
    description?: SortOrder
    strength?: SortOrder
    unit?: SortOrder
    dosageForm?: SortOrder
    route?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPharmacyOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PharmacyOrderStatus | EnumPharmacyOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PharmacyOrderStatus[] | ListEnumPharmacyOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PharmacyOrderStatus[] | ListEnumPharmacyOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPharmacyOrderStatusFilter<$PrismaModel> | $Enums.PharmacyOrderStatus
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type PharmacyOrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    dispensedDate?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type PharmacyOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    dispensedDate?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type PharmacyOrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    dispensedDate?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceId?: SortOrder
    createdBy?: SortOrder
    updatedBy?: SortOrder
  }

  export type EnumPharmacyOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PharmacyOrderStatus | EnumPharmacyOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PharmacyOrderStatus[] | ListEnumPharmacyOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PharmacyOrderStatus[] | ListEnumPharmacyOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPharmacyOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.PharmacyOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPharmacyOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumPharmacyOrderStatusFilter<$PrismaModel>
  }

  export type EnumPharmacyItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PharmacyItemStatus | EnumPharmacyItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PharmacyItemStatus[] | ListEnumPharmacyItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PharmacyItemStatus[] | ListEnumPharmacyItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPharmacyItemStatusFilter<$PrismaModel> | $Enums.PharmacyItemStatus
  }

  export type PharmacyOrderScalarRelationFilter = {
    is?: PharmacyOrderWhereInput
    isNot?: PharmacyOrderWhereInput
  }

  export type PharmacyOrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicationId?: SortOrder
    quantity?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instructions?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
  }

  export type PharmacyOrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type PharmacyOrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicationId?: SortOrder
    quantity?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instructions?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
  }

  export type PharmacyOrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicationId?: SortOrder
    quantity?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instructions?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
  }

  export type PharmacyOrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumPharmacyItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PharmacyItemStatus | EnumPharmacyItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PharmacyItemStatus[] | ListEnumPharmacyItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PharmacyItemStatus[] | ListEnumPharmacyItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPharmacyItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.PharmacyItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPharmacyItemStatusFilter<$PrismaModel>
    _max?: NestedEnumPharmacyItemStatusFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
  }

  export type ModalityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModalityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModalityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStudyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudyStatus | EnumStudyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudyStatus[] | ListEnumStudyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudyStatus[] | ListEnumStudyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudyStatusFilter<$PrismaModel> | $Enums.StudyStatus
  }

  export type EnumPriorityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriorityNullableFilter<$PrismaModel> | $Enums.Priority | null
  }

  export type ModalityScalarRelationFilter = {
    is?: ModalityWhereInput
    isNot?: ModalityWhereInput
  }

  export type SeriesListRelationFilter = {
    every?: SeriesWhereInput
    some?: SeriesWhereInput
    none?: SeriesWhereInput
  }

  export type RadiationDoseListRelationFilter = {
    every?: RadiationDoseWhereInput
    some?: RadiationDoseWhereInput
    none?: RadiationDoseWhereInput
  }

  export type SeriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RadiationDoseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudyCountOrderByAggregateInput = {
    id?: SortOrder
    studyId?: SortOrder
    patientId?: SortOrder
    patientName?: SortOrder
    modalityId?: SortOrder
    status?: SortOrder
    studyDate?: SortOrder
    priority?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudyMaxOrderByAggregateInput = {
    id?: SortOrder
    studyId?: SortOrder
    patientId?: SortOrder
    patientName?: SortOrder
    modalityId?: SortOrder
    status?: SortOrder
    studyDate?: SortOrder
    priority?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudyMinOrderByAggregateInput = {
    id?: SortOrder
    studyId?: SortOrder
    patientId?: SortOrder
    patientName?: SortOrder
    modalityId?: SortOrder
    status?: SortOrder
    studyDate?: SortOrder
    priority?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStudyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudyStatus | EnumStudyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudyStatus[] | ListEnumStudyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudyStatus[] | ListEnumStudyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudyStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudyStatusFilter<$PrismaModel>
    _max?: NestedEnumStudyStatusFilter<$PrismaModel>
  }

  export type EnumPriorityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriorityNullableWithAggregatesFilter<$PrismaModel> | $Enums.Priority | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPriorityNullableFilter<$PrismaModel>
    _max?: NestedEnumPriorityNullableFilter<$PrismaModel>
  }

  export type StudyScalarRelationFilter = {
    is?: StudyWhereInput
    isNot?: StudyWhereInput
  }

  export type ImageListRelationFilter = {
    every?: ImageWhereInput
    some?: ImageWhereInput
    none?: ImageWhereInput
  }

  export type ImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeriesCountOrderByAggregateInput = {
    id?: SortOrder
    seriesUid?: SortOrder
    studyId?: SortOrder
    number?: SortOrder
    description?: SortOrder
    modality?: SortOrder
    bodyPart?: SortOrder
    count?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeriesAvgOrderByAggregateInput = {
    number?: SortOrder
    count?: SortOrder
  }

  export type SeriesMaxOrderByAggregateInput = {
    id?: SortOrder
    seriesUid?: SortOrder
    studyId?: SortOrder
    number?: SortOrder
    description?: SortOrder
    modality?: SortOrder
    bodyPart?: SortOrder
    count?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeriesMinOrderByAggregateInput = {
    id?: SortOrder
    seriesUid?: SortOrder
    studyId?: SortOrder
    number?: SortOrder
    description?: SortOrder
    modality?: SortOrder
    bodyPart?: SortOrder
    count?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeriesSumOrderByAggregateInput = {
    number?: SortOrder
    count?: SortOrder
  }

  export type SeriesScalarRelationFilter = {
    is?: SeriesWhereInput
    isNot?: SeriesWhereInput
  }

  export type ImageCountOrderByAggregateInput = {
    id?: SortOrder
    sopInstanceUid?: SortOrder
    seriesId?: SortOrder
    number?: SortOrder
    path?: SortOrder
    size?: SortOrder
    contentType?: SortOrder
    width?: SortOrder
    height?: SortOrder
    windowCenter?: SortOrder
    windowWidth?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageAvgOrderByAggregateInput = {
    number?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    windowCenter?: SortOrder
    windowWidth?: SortOrder
  }

  export type ImageMaxOrderByAggregateInput = {
    id?: SortOrder
    sopInstanceUid?: SortOrder
    seriesId?: SortOrder
    number?: SortOrder
    path?: SortOrder
    size?: SortOrder
    contentType?: SortOrder
    width?: SortOrder
    height?: SortOrder
    windowCenter?: SortOrder
    windowWidth?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageMinOrderByAggregateInput = {
    id?: SortOrder
    sopInstanceUid?: SortOrder
    seriesId?: SortOrder
    number?: SortOrder
    path?: SortOrder
    size?: SortOrder
    contentType?: SortOrder
    width?: SortOrder
    height?: SortOrder
    windowCenter?: SortOrder
    windowWidth?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageSumOrderByAggregateInput = {
    number?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    windowCenter?: SortOrder
    windowWidth?: SortOrder
  }

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type ReportTemplateNullableScalarRelationFilter = {
    is?: ReportTemplateWhereInput | null
    isNot?: ReportTemplateWhereInput | null
  }

  export type RadReportCountOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    studyId?: SortOrder
    reportTemplateId?: SortOrder
    status?: SortOrder
    findings?: SortOrder
    impression?: SortOrder
    conclusion?: SortOrder
    reportDateTime?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RadReportMaxOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    studyId?: SortOrder
    reportTemplateId?: SortOrder
    status?: SortOrder
    findings?: SortOrder
    impression?: SortOrder
    conclusion?: SortOrder
    reportDateTime?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RadReportMinOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    studyId?: SortOrder
    reportTemplateId?: SortOrder
    status?: SortOrder
    findings?: SortOrder
    impression?: SortOrder
    conclusion?: SortOrder
    reportDateTime?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type RadiationDoseCountOrderByAggregateInput = {
    id?: SortOrder
    studyId?: SortOrder
    deviceName?: SortOrder
    deviceType?: SortOrder
    exposureTime?: SortOrder
    kvp?: SortOrder
    ma?: SortOrder
    doseAreaProduct?: SortOrder
    doseLengthProduct?: SortOrder
    ctdiVol?: SortOrder
    dlp?: SortOrder
    effectiveDose?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RadiationDoseAvgOrderByAggregateInput = {
    exposureTime?: SortOrder
    kvp?: SortOrder
    ma?: SortOrder
    doseAreaProduct?: SortOrder
    doseLengthProduct?: SortOrder
    ctdiVol?: SortOrder
    dlp?: SortOrder
    effectiveDose?: SortOrder
  }

  export type RadiationDoseMaxOrderByAggregateInput = {
    id?: SortOrder
    studyId?: SortOrder
    deviceName?: SortOrder
    deviceType?: SortOrder
    exposureTime?: SortOrder
    kvp?: SortOrder
    ma?: SortOrder
    doseAreaProduct?: SortOrder
    doseLengthProduct?: SortOrder
    ctdiVol?: SortOrder
    dlp?: SortOrder
    effectiveDose?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RadiationDoseMinOrderByAggregateInput = {
    id?: SortOrder
    studyId?: SortOrder
    deviceName?: SortOrder
    deviceType?: SortOrder
    exposureTime?: SortOrder
    kvp?: SortOrder
    ma?: SortOrder
    doseAreaProduct?: SortOrder
    doseLengthProduct?: SortOrder
    ctdiVol?: SortOrder
    dlp?: SortOrder
    effectiveDose?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RadiationDoseSumOrderByAggregateInput = {
    exposureTime?: SortOrder
    kvp?: SortOrder
    ma?: SortOrder
    doseAreaProduct?: SortOrder
    doseLengthProduct?: SortOrder
    ctdiVol?: SortOrder
    dlp?: SortOrder
    effectiveDose?: SortOrder
  }

  export type ReportTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    template?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    template?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    template?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTelemedicineStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TelemedicineStatus | EnumTelemedicineStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TelemedicineStatus[] | ListEnumTelemedicineStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TelemedicineStatus[] | ListEnumTelemedicineStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTelemedicineStatusFilter<$PrismaModel> | $Enums.TelemedicineStatus
  }

  export type EnumConsultationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsultationType | EnumConsultationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsultationType[] | ListEnumConsultationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsultationType[] | ListEnumConsultationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsultationTypeFilter<$PrismaModel> | $Enums.ConsultationType
  }

  export type VideoRoomNullableScalarRelationFilter = {
    is?: VideoRoomWhereInput | null
    isNot?: VideoRoomWhereInput | null
  }

  export type TelemedicineConsultationCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    duration?: SortOrder
    consultationType?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    prescription?: SortOrder
    followUpRequired?: SortOrder
    followUpDate?: SortOrder
    isEmergency?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelemedicineConsultationAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type TelemedicineConsultationMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    duration?: SortOrder
    consultationType?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    prescription?: SortOrder
    followUpRequired?: SortOrder
    followUpDate?: SortOrder
    isEmergency?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelemedicineConsultationMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    duration?: SortOrder
    consultationType?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    prescription?: SortOrder
    followUpRequired?: SortOrder
    followUpDate?: SortOrder
    isEmergency?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelemedicineConsultationSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumTelemedicineStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TelemedicineStatus | EnumTelemedicineStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TelemedicineStatus[] | ListEnumTelemedicineStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TelemedicineStatus[] | ListEnumTelemedicineStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTelemedicineStatusWithAggregatesFilter<$PrismaModel> | $Enums.TelemedicineStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTelemedicineStatusFilter<$PrismaModel>
    _max?: NestedEnumTelemedicineStatusFilter<$PrismaModel>
  }

  export type EnumConsultationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsultationType | EnumConsultationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsultationType[] | ListEnumConsultationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsultationType[] | ListEnumConsultationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsultationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConsultationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsultationTypeFilter<$PrismaModel>
    _max?: NestedEnumConsultationTypeFilter<$PrismaModel>
  }

  export type EnumVideoRoomStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoRoomStatus | EnumVideoRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VideoRoomStatus[] | ListEnumVideoRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoRoomStatus[] | ListEnumVideoRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoRoomStatusFilter<$PrismaModel> | $Enums.VideoRoomStatus
  }

  export type TelemedicineConsultationScalarRelationFilter = {
    is?: TelemedicineConsultationWhereInput
    isNot?: TelemedicineConsultationWhereInput
  }

  export type VideoRoomCountOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    roomId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    maxParticipants?: SortOrder
    recordingEnabled?: SortOrder
    recordingUrl?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoRoomAvgOrderByAggregateInput = {
    maxParticipants?: SortOrder
  }

  export type VideoRoomMaxOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    roomId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    maxParticipants?: SortOrder
    recordingEnabled?: SortOrder
    recordingUrl?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoRoomMinOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    roomId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    maxParticipants?: SortOrder
    recordingEnabled?: SortOrder
    recordingUrl?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoRoomSumOrderByAggregateInput = {
    maxParticipants?: SortOrder
  }

  export type EnumVideoRoomStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoRoomStatus | EnumVideoRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VideoRoomStatus[] | ListEnumVideoRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoRoomStatus[] | ListEnumVideoRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoRoomStatusWithAggregatesFilter<$PrismaModel> | $Enums.VideoRoomStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVideoRoomStatusFilter<$PrismaModel>
    _max?: NestedEnumVideoRoomStatusFilter<$PrismaModel>
  }

  export type EnumParticipantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantType | EnumParticipantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParticipantType[] | ListEnumParticipantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParticipantType[] | ListEnumParticipantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumParticipantTypeFilter<$PrismaModel> | $Enums.ParticipantType
  }

  export type VideoRoomScalarRelationFilter = {
    is?: VideoRoomWhereInput
    isNot?: VideoRoomWhereInput
  }

  export type VideoParticipantRoomIdUserIdCompoundUniqueInput = {
    roomId: string
    userId: string
  }

  export type VideoParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    participantType?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    participantType?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    participantType?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumParticipantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantType | EnumParticipantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParticipantType[] | ListEnumParticipantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParticipantType[] | ListEnumParticipantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumParticipantTypeWithAggregatesFilter<$PrismaModel> | $Enums.ParticipantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParticipantTypeFilter<$PrismaModel>
    _max?: NestedEnumParticipantTypeFilter<$PrismaModel>
  }

  export type EnumRecordingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RecordingStatus | EnumRecordingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecordingStatusFilter<$PrismaModel> | $Enums.RecordingStatus
  }

  export type VideoRecordingCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoRecordingAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    duration?: SortOrder
  }

  export type VideoRecordingMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoRecordingMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoRecordingSumOrderByAggregateInput = {
    fileSize?: SortOrder
    duration?: SortOrder
  }

  export type EnumRecordingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecordingStatus | EnumRecordingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecordingStatusWithAggregatesFilter<$PrismaModel> | $Enums.RecordingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecordingStatusFilter<$PrismaModel>
    _max?: NestedEnumRecordingStatusFilter<$PrismaModel>
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type VideoMessageCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    messageType?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    messageType?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VideoMessageMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    messageType?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type EnumRadiologyOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RadiologyOrderStatus | EnumRadiologyOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RadiologyOrderStatus[] | ListEnumRadiologyOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RadiologyOrderStatus[] | ListEnumRadiologyOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRadiologyOrderStatusFilter<$PrismaModel> | $Enums.RadiologyOrderStatus
  }

  export type StudyNullableScalarRelationFilter = {
    is?: StudyWhereInput | null
    isNot?: StudyWhereInput | null
  }

  export type RadiologyOrderCountOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    modalityId?: SortOrder
    studyType?: SortOrder
    priority?: SortOrder
    reason?: SortOrder
    clinicalHistory?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studyId?: SortOrder
  }

  export type RadiologyOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    modalityId?: SortOrder
    studyType?: SortOrder
    priority?: SortOrder
    reason?: SortOrder
    clinicalHistory?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studyId?: SortOrder
  }

  export type RadiologyOrderMinOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    modalityId?: SortOrder
    studyType?: SortOrder
    priority?: SortOrder
    reason?: SortOrder
    clinicalHistory?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    completedAt?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studyId?: SortOrder
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type EnumRadiologyOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RadiologyOrderStatus | EnumRadiologyOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RadiologyOrderStatus[] | ListEnumRadiologyOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RadiologyOrderStatus[] | ListEnumRadiologyOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRadiologyOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.RadiologyOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRadiologyOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumRadiologyOrderStatusFilter<$PrismaModel>
  }

  export type AppointmentCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<AppointmentCreateWithoutDepartmentInput, AppointmentUncheckedCreateWithoutDepartmentInput> | AppointmentCreateWithoutDepartmentInput[] | AppointmentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDepartmentInput | AppointmentCreateOrConnectWithoutDepartmentInput[]
    createMany?: AppointmentCreateManyDepartmentInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<TenantCreateWithoutDepartmentsInput, TenantUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDepartmentsInput
    connect?: TenantWhereUniqueInput
  }

  export type StaffCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput> | StaffCreateWithoutDepartmentInput[] | StaffUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutDepartmentInput | StaffCreateOrConnectWithoutDepartmentInput[]
    createMany?: StaffCreateManyDepartmentInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<AppointmentCreateWithoutDepartmentInput, AppointmentUncheckedCreateWithoutDepartmentInput> | AppointmentCreateWithoutDepartmentInput[] | AppointmentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDepartmentInput | AppointmentCreateOrConnectWithoutDepartmentInput[]
    createMany?: AppointmentCreateManyDepartmentInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type StaffUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput> | StaffCreateWithoutDepartmentInput[] | StaffUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutDepartmentInput | StaffCreateOrConnectWithoutDepartmentInput[]
    createMany?: StaffCreateManyDepartmentInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AppointmentUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<AppointmentCreateWithoutDepartmentInput, AppointmentUncheckedCreateWithoutDepartmentInput> | AppointmentCreateWithoutDepartmentInput[] | AppointmentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDepartmentInput | AppointmentCreateOrConnectWithoutDepartmentInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDepartmentInput | AppointmentUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: AppointmentCreateManyDepartmentInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDepartmentInput | AppointmentUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDepartmentInput | AppointmentUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutDepartmentsNestedInput = {
    create?: XOR<TenantCreateWithoutDepartmentsInput, TenantUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDepartmentsInput
    upsert?: TenantUpsertWithoutDepartmentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDepartmentsInput, TenantUpdateWithoutDepartmentsInput>, TenantUncheckedUpdateWithoutDepartmentsInput>
  }

  export type StaffUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput> | StaffCreateWithoutDepartmentInput[] | StaffUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutDepartmentInput | StaffCreateOrConnectWithoutDepartmentInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutDepartmentInput | StaffUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: StaffCreateManyDepartmentInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutDepartmentInput | StaffUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutDepartmentInput | StaffUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<AppointmentCreateWithoutDepartmentInput, AppointmentUncheckedCreateWithoutDepartmentInput> | AppointmentCreateWithoutDepartmentInput[] | AppointmentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDepartmentInput | AppointmentCreateOrConnectWithoutDepartmentInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDepartmentInput | AppointmentUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: AppointmentCreateManyDepartmentInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDepartmentInput | AppointmentUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDepartmentInput | AppointmentUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type StaffUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput> | StaffCreateWithoutDepartmentInput[] | StaffUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutDepartmentInput | StaffCreateOrConnectWithoutDepartmentInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutDepartmentInput | StaffUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: StaffCreateManyDepartmentInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutDepartmentInput | StaffUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutDepartmentInput | StaffUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutSpecialtiesInput = {
    create?: XOR<TenantCreateWithoutSpecialtiesInput, TenantUncheckedCreateWithoutSpecialtiesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSpecialtiesInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutSpecialtiesNestedInput = {
    create?: XOR<TenantCreateWithoutSpecialtiesInput, TenantUncheckedCreateWithoutSpecialtiesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSpecialtiesInput
    upsert?: TenantUpsertWithoutSpecialtiesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSpecialtiesInput, TenantUpdateWithoutSpecialtiesInput>, TenantUncheckedUpdateWithoutSpecialtiesInput>
  }

  export type TenantCreateNestedOneWithoutStaffInput = {
    create?: XOR<TenantCreateWithoutStaffInput, TenantUncheckedCreateWithoutStaffInput>
    connectOrCreate?: TenantCreateOrConnectWithoutStaffInput
    connect?: TenantWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutStaffInput = {
    create?: XOR<DepartmentCreateWithoutStaffInput, DepartmentUncheckedCreateWithoutStaffInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutStaffInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStaffInput = {
    create?: XOR<UserCreateWithoutStaffInput, UserUncheckedCreateWithoutStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TenantUpdateOneRequiredWithoutStaffNestedInput = {
    create?: XOR<TenantCreateWithoutStaffInput, TenantUncheckedCreateWithoutStaffInput>
    connectOrCreate?: TenantCreateOrConnectWithoutStaffInput
    upsert?: TenantUpsertWithoutStaffInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutStaffInput, TenantUpdateWithoutStaffInput>, TenantUncheckedUpdateWithoutStaffInput>
  }

  export type DepartmentUpdateOneWithoutStaffNestedInput = {
    create?: XOR<DepartmentCreateWithoutStaffInput, DepartmentUncheckedCreateWithoutStaffInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutStaffInput
    upsert?: DepartmentUpsertWithoutStaffInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutStaffInput, DepartmentUpdateWithoutStaffInput>, DepartmentUncheckedUpdateWithoutStaffInput>
  }

  export type UserUpdateOneRequiredWithoutStaffNestedInput = {
    create?: XOR<UserCreateWithoutStaffInput, UserUncheckedCreateWithoutStaffInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffInput
    upsert?: UserUpsertWithoutStaffInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStaffInput, UserUpdateWithoutStaffInput>, UserUncheckedUpdateWithoutStaffInput>
  }

  export type AppointmentCreateNestedManyWithoutTenantInput = {
    create?: XOR<AppointmentCreateWithoutTenantInput, AppointmentUncheckedCreateWithoutTenantInput> | AppointmentCreateWithoutTenantInput[] | AppointmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutTenantInput | AppointmentCreateOrConnectWithoutTenantInput[]
    createMany?: AppointmentCreateManyTenantInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DepartmentCreateNestedManyWithoutTenantInput = {
    create?: XOR<DepartmentCreateWithoutTenantInput, DepartmentUncheckedCreateWithoutTenantInput> | DepartmentCreateWithoutTenantInput[] | DepartmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutTenantInput | DepartmentCreateOrConnectWithoutTenantInput[]
    createMany?: DepartmentCreateManyTenantInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InvoiceItemCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoiceItemCreateWithoutTenantInput, InvoiceItemUncheckedCreateWithoutTenantInput> | InvoiceItemCreateWithoutTenantInput[] | InvoiceItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutTenantInput | InvoiceItemCreateOrConnectWithoutTenantInput[]
    createMany?: InvoiceItemCreateManyTenantInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type LabOrderCreateNestedManyWithoutTenantInput = {
    create?: XOR<LabOrderCreateWithoutTenantInput, LabOrderUncheckedCreateWithoutTenantInput> | LabOrderCreateWithoutTenantInput[] | LabOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutTenantInput | LabOrderCreateOrConnectWithoutTenantInput[]
    createMany?: LabOrderCreateManyTenantInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type LabOrderTestCreateNestedManyWithoutTenantInput = {
    create?: XOR<LabOrderTestCreateWithoutTenantInput, LabOrderTestUncheckedCreateWithoutTenantInput> | LabOrderTestCreateWithoutTenantInput[] | LabOrderTestUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutTenantInput | LabOrderTestCreateOrConnectWithoutTenantInput[]
    createMany?: LabOrderTestCreateManyTenantInputEnvelope
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
  }

  export type LabTestCreateNestedManyWithoutTenantInput = {
    create?: XOR<LabTestCreateWithoutTenantInput, LabTestUncheckedCreateWithoutTenantInput> | LabTestCreateWithoutTenantInput[] | LabTestUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LabTestCreateOrConnectWithoutTenantInput | LabTestCreateOrConnectWithoutTenantInput[]
    createMany?: LabTestCreateManyTenantInputEnvelope
    connect?: LabTestWhereUniqueInput | LabTestWhereUniqueInput[]
  }

  export type MedicalRecordCreateNestedManyWithoutTenantInput = {
    create?: XOR<MedicalRecordCreateWithoutTenantInput, MedicalRecordUncheckedCreateWithoutTenantInput> | MedicalRecordCreateWithoutTenantInput[] | MedicalRecordUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutTenantInput | MedicalRecordCreateOrConnectWithoutTenantInput[]
    createMany?: MedicalRecordCreateManyTenantInputEnvelope
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
  }

  export type MedicationCreateNestedManyWithoutTenantInput = {
    create?: XOR<MedicationCreateWithoutTenantInput, MedicationUncheckedCreateWithoutTenantInput> | MedicationCreateWithoutTenantInput[] | MedicationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutTenantInput | MedicationCreateOrConnectWithoutTenantInput[]
    createMany?: MedicationCreateManyTenantInputEnvelope
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PharmacyOrderCreateNestedManyWithoutTenantInput = {
    create?: XOR<PharmacyOrderCreateWithoutTenantInput, PharmacyOrderUncheckedCreateWithoutTenantInput> | PharmacyOrderCreateWithoutTenantInput[] | PharmacyOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PharmacyOrderCreateOrConnectWithoutTenantInput | PharmacyOrderCreateOrConnectWithoutTenantInput[]
    createMany?: PharmacyOrderCreateManyTenantInputEnvelope
    connect?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
  }

  export type PharmacyOrderItemCreateNestedManyWithoutTenantInput = {
    create?: XOR<PharmacyOrderItemCreateWithoutTenantInput, PharmacyOrderItemUncheckedCreateWithoutTenantInput> | PharmacyOrderItemCreateWithoutTenantInput[] | PharmacyOrderItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PharmacyOrderItemCreateOrConnectWithoutTenantInput | PharmacyOrderItemCreateOrConnectWithoutTenantInput[]
    createMany?: PharmacyOrderItemCreateManyTenantInputEnvelope
    connect?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
  }

  export type PrescriptionCreateNestedManyWithoutTenantInput = {
    create?: XOR<PrescriptionCreateWithoutTenantInput, PrescriptionUncheckedCreateWithoutTenantInput> | PrescriptionCreateWithoutTenantInput[] | PrescriptionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutTenantInput | PrescriptionCreateOrConnectWithoutTenantInput[]
    createMany?: PrescriptionCreateManyTenantInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type PrescriptionItemCreateNestedManyWithoutTenantInput = {
    create?: XOR<PrescriptionItemCreateWithoutTenantInput, PrescriptionItemUncheckedCreateWithoutTenantInput> | PrescriptionItemCreateWithoutTenantInput[] | PrescriptionItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutTenantInput | PrescriptionItemCreateOrConnectWithoutTenantInput[]
    createMany?: PrescriptionItemCreateManyTenantInputEnvelope
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutTenantInput = {
    create?: XOR<RefreshTokenCreateWithoutTenantInput, RefreshTokenUncheckedCreateWithoutTenantInput> | RefreshTokenCreateWithoutTenantInput[] | RefreshTokenUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutTenantInput | RefreshTokenCreateOrConnectWithoutTenantInput[]
    createMany?: RefreshTokenCreateManyTenantInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type SpecialtyCreateNestedManyWithoutTenantInput = {
    create?: XOR<SpecialtyCreateWithoutTenantInput, SpecialtyUncheckedCreateWithoutTenantInput> | SpecialtyCreateWithoutTenantInput[] | SpecialtyUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SpecialtyCreateOrConnectWithoutTenantInput | SpecialtyCreateOrConnectWithoutTenantInput[]
    createMany?: SpecialtyCreateManyTenantInputEnvelope
    connect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
  }

  export type StaffCreateNestedManyWithoutTenantInput = {
    create?: XOR<StaffCreateWithoutTenantInput, StaffUncheckedCreateWithoutTenantInput> | StaffCreateWithoutTenantInput[] | StaffUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutTenantInput | StaffCreateOrConnectWithoutTenantInput[]
    createMany?: StaffCreateManyTenantInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PatientCreateNestedManyWithoutTenantInput = {
    create?: XOR<PatientCreateWithoutTenantInput, PatientUncheckedCreateWithoutTenantInput> | PatientCreateWithoutTenantInput[] | PatientUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutTenantInput | PatientCreateOrConnectWithoutTenantInput[]
    createMany?: PatientCreateManyTenantInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type StudyCreateNestedManyWithoutTenantInput = {
    create?: XOR<StudyCreateWithoutTenantInput, StudyUncheckedCreateWithoutTenantInput> | StudyCreateWithoutTenantInput[] | StudyUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StudyCreateOrConnectWithoutTenantInput | StudyCreateOrConnectWithoutTenantInput[]
    createMany?: StudyCreateManyTenantInputEnvelope
    connect?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
  }

  export type RadReportCreateNestedManyWithoutTenantInput = {
    create?: XOR<RadReportCreateWithoutTenantInput, RadReportUncheckedCreateWithoutTenantInput> | RadReportCreateWithoutTenantInput[] | RadReportUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RadReportCreateOrConnectWithoutTenantInput | RadReportCreateOrConnectWithoutTenantInput[]
    createMany?: RadReportCreateManyTenantInputEnvelope
    connect?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
  }

  export type ReportTemplateCreateNestedManyWithoutTenantInput = {
    create?: XOR<ReportTemplateCreateWithoutTenantInput, ReportTemplateUncheckedCreateWithoutTenantInput> | ReportTemplateCreateWithoutTenantInput[] | ReportTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutTenantInput | ReportTemplateCreateOrConnectWithoutTenantInput[]
    createMany?: ReportTemplateCreateManyTenantInputEnvelope
    connect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
  }

  export type TelemedicineConsultationCreateNestedManyWithoutTenantInput = {
    create?: XOR<TelemedicineConsultationCreateWithoutTenantInput, TelemedicineConsultationUncheckedCreateWithoutTenantInput> | TelemedicineConsultationCreateWithoutTenantInput[] | TelemedicineConsultationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TelemedicineConsultationCreateOrConnectWithoutTenantInput | TelemedicineConsultationCreateOrConnectWithoutTenantInput[]
    createMany?: TelemedicineConsultationCreateManyTenantInputEnvelope
    connect?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
  }

  export type VideoRoomCreateNestedManyWithoutTenantInput = {
    create?: XOR<VideoRoomCreateWithoutTenantInput, VideoRoomUncheckedCreateWithoutTenantInput> | VideoRoomCreateWithoutTenantInput[] | VideoRoomUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VideoRoomCreateOrConnectWithoutTenantInput | VideoRoomCreateOrConnectWithoutTenantInput[]
    createMany?: VideoRoomCreateManyTenantInputEnvelope
    connect?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
  }

  export type VideoParticipantCreateNestedManyWithoutTenantInput = {
    create?: XOR<VideoParticipantCreateWithoutTenantInput, VideoParticipantUncheckedCreateWithoutTenantInput> | VideoParticipantCreateWithoutTenantInput[] | VideoParticipantUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VideoParticipantCreateOrConnectWithoutTenantInput | VideoParticipantCreateOrConnectWithoutTenantInput[]
    createMany?: VideoParticipantCreateManyTenantInputEnvelope
    connect?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
  }

  export type VideoRecordingCreateNestedManyWithoutTenantInput = {
    create?: XOR<VideoRecordingCreateWithoutTenantInput, VideoRecordingUncheckedCreateWithoutTenantInput> | VideoRecordingCreateWithoutTenantInput[] | VideoRecordingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VideoRecordingCreateOrConnectWithoutTenantInput | VideoRecordingCreateOrConnectWithoutTenantInput[]
    createMany?: VideoRecordingCreateManyTenantInputEnvelope
    connect?: VideoRecordingWhereUniqueInput | VideoRecordingWhereUniqueInput[]
  }

  export type VideoMessageCreateNestedManyWithoutTenantInput = {
    create?: XOR<VideoMessageCreateWithoutTenantInput, VideoMessageUncheckedCreateWithoutTenantInput> | VideoMessageCreateWithoutTenantInput[] | VideoMessageUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VideoMessageCreateOrConnectWithoutTenantInput | VideoMessageCreateOrConnectWithoutTenantInput[]
    createMany?: VideoMessageCreateManyTenantInputEnvelope
    connect?: VideoMessageWhereUniqueInput | VideoMessageWhereUniqueInput[]
  }

  export type RadiologyOrderCreateNestedManyWithoutTenantInput = {
    create?: XOR<RadiologyOrderCreateWithoutTenantInput, RadiologyOrderUncheckedCreateWithoutTenantInput> | RadiologyOrderCreateWithoutTenantInput[] | RadiologyOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutTenantInput | RadiologyOrderCreateOrConnectWithoutTenantInput[]
    createMany?: RadiologyOrderCreateManyTenantInputEnvelope
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AppointmentCreateWithoutTenantInput, AppointmentUncheckedCreateWithoutTenantInput> | AppointmentCreateWithoutTenantInput[] | AppointmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutTenantInput | AppointmentCreateOrConnectWithoutTenantInput[]
    createMany?: AppointmentCreateManyTenantInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<DepartmentCreateWithoutTenantInput, DepartmentUncheckedCreateWithoutTenantInput> | DepartmentCreateWithoutTenantInput[] | DepartmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutTenantInput | DepartmentCreateOrConnectWithoutTenantInput[]
    createMany?: DepartmentCreateManyTenantInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoiceItemCreateWithoutTenantInput, InvoiceItemUncheckedCreateWithoutTenantInput> | InvoiceItemCreateWithoutTenantInput[] | InvoiceItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutTenantInput | InvoiceItemCreateOrConnectWithoutTenantInput[]
    createMany?: InvoiceItemCreateManyTenantInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type LabOrderUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<LabOrderCreateWithoutTenantInput, LabOrderUncheckedCreateWithoutTenantInput> | LabOrderCreateWithoutTenantInput[] | LabOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutTenantInput | LabOrderCreateOrConnectWithoutTenantInput[]
    createMany?: LabOrderCreateManyTenantInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type LabOrderTestUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<LabOrderTestCreateWithoutTenantInput, LabOrderTestUncheckedCreateWithoutTenantInput> | LabOrderTestCreateWithoutTenantInput[] | LabOrderTestUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutTenantInput | LabOrderTestCreateOrConnectWithoutTenantInput[]
    createMany?: LabOrderTestCreateManyTenantInputEnvelope
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
  }

  export type LabTestUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<LabTestCreateWithoutTenantInput, LabTestUncheckedCreateWithoutTenantInput> | LabTestCreateWithoutTenantInput[] | LabTestUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LabTestCreateOrConnectWithoutTenantInput | LabTestCreateOrConnectWithoutTenantInput[]
    createMany?: LabTestCreateManyTenantInputEnvelope
    connect?: LabTestWhereUniqueInput | LabTestWhereUniqueInput[]
  }

  export type MedicalRecordUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<MedicalRecordCreateWithoutTenantInput, MedicalRecordUncheckedCreateWithoutTenantInput> | MedicalRecordCreateWithoutTenantInput[] | MedicalRecordUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutTenantInput | MedicalRecordCreateOrConnectWithoutTenantInput[]
    createMany?: MedicalRecordCreateManyTenantInputEnvelope
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
  }

  export type MedicationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<MedicationCreateWithoutTenantInput, MedicationUncheckedCreateWithoutTenantInput> | MedicationCreateWithoutTenantInput[] | MedicationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutTenantInput | MedicationCreateOrConnectWithoutTenantInput[]
    createMany?: MedicationCreateManyTenantInputEnvelope
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PharmacyOrderCreateWithoutTenantInput, PharmacyOrderUncheckedCreateWithoutTenantInput> | PharmacyOrderCreateWithoutTenantInput[] | PharmacyOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PharmacyOrderCreateOrConnectWithoutTenantInput | PharmacyOrderCreateOrConnectWithoutTenantInput[]
    createMany?: PharmacyOrderCreateManyTenantInputEnvelope
    connect?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
  }

  export type PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PharmacyOrderItemCreateWithoutTenantInput, PharmacyOrderItemUncheckedCreateWithoutTenantInput> | PharmacyOrderItemCreateWithoutTenantInput[] | PharmacyOrderItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PharmacyOrderItemCreateOrConnectWithoutTenantInput | PharmacyOrderItemCreateOrConnectWithoutTenantInput[]
    createMany?: PharmacyOrderItemCreateManyTenantInputEnvelope
    connect?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PrescriptionCreateWithoutTenantInput, PrescriptionUncheckedCreateWithoutTenantInput> | PrescriptionCreateWithoutTenantInput[] | PrescriptionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutTenantInput | PrescriptionCreateOrConnectWithoutTenantInput[]
    createMany?: PrescriptionCreateManyTenantInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PrescriptionItemCreateWithoutTenantInput, PrescriptionItemUncheckedCreateWithoutTenantInput> | PrescriptionItemCreateWithoutTenantInput[] | PrescriptionItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutTenantInput | PrescriptionItemCreateOrConnectWithoutTenantInput[]
    createMany?: PrescriptionItemCreateManyTenantInputEnvelope
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<RefreshTokenCreateWithoutTenantInput, RefreshTokenUncheckedCreateWithoutTenantInput> | RefreshTokenCreateWithoutTenantInput[] | RefreshTokenUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutTenantInput | RefreshTokenCreateOrConnectWithoutTenantInput[]
    createMany?: RefreshTokenCreateManyTenantInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type SpecialtyUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SpecialtyCreateWithoutTenantInput, SpecialtyUncheckedCreateWithoutTenantInput> | SpecialtyCreateWithoutTenantInput[] | SpecialtyUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SpecialtyCreateOrConnectWithoutTenantInput | SpecialtyCreateOrConnectWithoutTenantInput[]
    createMany?: SpecialtyCreateManyTenantInputEnvelope
    connect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
  }

  export type StaffUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<StaffCreateWithoutTenantInput, StaffUncheckedCreateWithoutTenantInput> | StaffCreateWithoutTenantInput[] | StaffUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutTenantInput | StaffCreateOrConnectWithoutTenantInput[]
    createMany?: StaffCreateManyTenantInputEnvelope
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PatientUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PatientCreateWithoutTenantInput, PatientUncheckedCreateWithoutTenantInput> | PatientCreateWithoutTenantInput[] | PatientUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutTenantInput | PatientCreateOrConnectWithoutTenantInput[]
    createMany?: PatientCreateManyTenantInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type StudyUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<StudyCreateWithoutTenantInput, StudyUncheckedCreateWithoutTenantInput> | StudyCreateWithoutTenantInput[] | StudyUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StudyCreateOrConnectWithoutTenantInput | StudyCreateOrConnectWithoutTenantInput[]
    createMany?: StudyCreateManyTenantInputEnvelope
    connect?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
  }

  export type RadReportUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<RadReportCreateWithoutTenantInput, RadReportUncheckedCreateWithoutTenantInput> | RadReportCreateWithoutTenantInput[] | RadReportUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RadReportCreateOrConnectWithoutTenantInput | RadReportCreateOrConnectWithoutTenantInput[]
    createMany?: RadReportCreateManyTenantInputEnvelope
    connect?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
  }

  export type ReportTemplateUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ReportTemplateCreateWithoutTenantInput, ReportTemplateUncheckedCreateWithoutTenantInput> | ReportTemplateCreateWithoutTenantInput[] | ReportTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutTenantInput | ReportTemplateCreateOrConnectWithoutTenantInput[]
    createMany?: ReportTemplateCreateManyTenantInputEnvelope
    connect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
  }

  export type TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TelemedicineConsultationCreateWithoutTenantInput, TelemedicineConsultationUncheckedCreateWithoutTenantInput> | TelemedicineConsultationCreateWithoutTenantInput[] | TelemedicineConsultationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TelemedicineConsultationCreateOrConnectWithoutTenantInput | TelemedicineConsultationCreateOrConnectWithoutTenantInput[]
    createMany?: TelemedicineConsultationCreateManyTenantInputEnvelope
    connect?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
  }

  export type VideoRoomUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<VideoRoomCreateWithoutTenantInput, VideoRoomUncheckedCreateWithoutTenantInput> | VideoRoomCreateWithoutTenantInput[] | VideoRoomUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VideoRoomCreateOrConnectWithoutTenantInput | VideoRoomCreateOrConnectWithoutTenantInput[]
    createMany?: VideoRoomCreateManyTenantInputEnvelope
    connect?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
  }

  export type VideoParticipantUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<VideoParticipantCreateWithoutTenantInput, VideoParticipantUncheckedCreateWithoutTenantInput> | VideoParticipantCreateWithoutTenantInput[] | VideoParticipantUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VideoParticipantCreateOrConnectWithoutTenantInput | VideoParticipantCreateOrConnectWithoutTenantInput[]
    createMany?: VideoParticipantCreateManyTenantInputEnvelope
    connect?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
  }

  export type VideoRecordingUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<VideoRecordingCreateWithoutTenantInput, VideoRecordingUncheckedCreateWithoutTenantInput> | VideoRecordingCreateWithoutTenantInput[] | VideoRecordingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VideoRecordingCreateOrConnectWithoutTenantInput | VideoRecordingCreateOrConnectWithoutTenantInput[]
    createMany?: VideoRecordingCreateManyTenantInputEnvelope
    connect?: VideoRecordingWhereUniqueInput | VideoRecordingWhereUniqueInput[]
  }

  export type VideoMessageUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<VideoMessageCreateWithoutTenantInput, VideoMessageUncheckedCreateWithoutTenantInput> | VideoMessageCreateWithoutTenantInput[] | VideoMessageUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VideoMessageCreateOrConnectWithoutTenantInput | VideoMessageCreateOrConnectWithoutTenantInput[]
    createMany?: VideoMessageCreateManyTenantInputEnvelope
    connect?: VideoMessageWhereUniqueInput | VideoMessageWhereUniqueInput[]
  }

  export type RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<RadiologyOrderCreateWithoutTenantInput, RadiologyOrderUncheckedCreateWithoutTenantInput> | RadiologyOrderCreateWithoutTenantInput[] | RadiologyOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutTenantInput | RadiologyOrderCreateOrConnectWithoutTenantInput[]
    createMany?: RadiologyOrderCreateManyTenantInputEnvelope
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
  }

  export type EnumTenantTypeFieldUpdateOperationsInput = {
    set?: $Enums.TenantType
  }

  export type AppointmentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AppointmentCreateWithoutTenantInput, AppointmentUncheckedCreateWithoutTenantInput> | AppointmentCreateWithoutTenantInput[] | AppointmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutTenantInput | AppointmentCreateOrConnectWithoutTenantInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutTenantInput | AppointmentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AppointmentCreateManyTenantInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutTenantInput | AppointmentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutTenantInput | AppointmentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DepartmentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DepartmentCreateWithoutTenantInput, DepartmentUncheckedCreateWithoutTenantInput> | DepartmentCreateWithoutTenantInput[] | DepartmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutTenantInput | DepartmentCreateOrConnectWithoutTenantInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutTenantInput | DepartmentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DepartmentCreateManyTenantInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutTenantInput | DepartmentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutTenantInput | DepartmentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTenantInput | InvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTenantInput | InvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTenantInput | InvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InvoiceItemUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutTenantInput, InvoiceItemUncheckedCreateWithoutTenantInput> | InvoiceItemCreateWithoutTenantInput[] | InvoiceItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutTenantInput | InvoiceItemCreateOrConnectWithoutTenantInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutTenantInput | InvoiceItemUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoiceItemCreateManyTenantInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutTenantInput | InvoiceItemUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutTenantInput | InvoiceItemUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type LabOrderUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LabOrderCreateWithoutTenantInput, LabOrderUncheckedCreateWithoutTenantInput> | LabOrderCreateWithoutTenantInput[] | LabOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutTenantInput | LabOrderCreateOrConnectWithoutTenantInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutTenantInput | LabOrderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LabOrderCreateManyTenantInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutTenantInput | LabOrderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutTenantInput | LabOrderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type LabOrderTestUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LabOrderTestCreateWithoutTenantInput, LabOrderTestUncheckedCreateWithoutTenantInput> | LabOrderTestCreateWithoutTenantInput[] | LabOrderTestUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutTenantInput | LabOrderTestCreateOrConnectWithoutTenantInput[]
    upsert?: LabOrderTestUpsertWithWhereUniqueWithoutTenantInput | LabOrderTestUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LabOrderTestCreateManyTenantInputEnvelope
    set?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    disconnect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    delete?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    update?: LabOrderTestUpdateWithWhereUniqueWithoutTenantInput | LabOrderTestUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LabOrderTestUpdateManyWithWhereWithoutTenantInput | LabOrderTestUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LabOrderTestScalarWhereInput | LabOrderTestScalarWhereInput[]
  }

  export type LabTestUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LabTestCreateWithoutTenantInput, LabTestUncheckedCreateWithoutTenantInput> | LabTestCreateWithoutTenantInput[] | LabTestUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LabTestCreateOrConnectWithoutTenantInput | LabTestCreateOrConnectWithoutTenantInput[]
    upsert?: LabTestUpsertWithWhereUniqueWithoutTenantInput | LabTestUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LabTestCreateManyTenantInputEnvelope
    set?: LabTestWhereUniqueInput | LabTestWhereUniqueInput[]
    disconnect?: LabTestWhereUniqueInput | LabTestWhereUniqueInput[]
    delete?: LabTestWhereUniqueInput | LabTestWhereUniqueInput[]
    connect?: LabTestWhereUniqueInput | LabTestWhereUniqueInput[]
    update?: LabTestUpdateWithWhereUniqueWithoutTenantInput | LabTestUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LabTestUpdateManyWithWhereWithoutTenantInput | LabTestUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LabTestScalarWhereInput | LabTestScalarWhereInput[]
  }

  export type MedicalRecordUpdateManyWithoutTenantNestedInput = {
    create?: XOR<MedicalRecordCreateWithoutTenantInput, MedicalRecordUncheckedCreateWithoutTenantInput> | MedicalRecordCreateWithoutTenantInput[] | MedicalRecordUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutTenantInput | MedicalRecordCreateOrConnectWithoutTenantInput[]
    upsert?: MedicalRecordUpsertWithWhereUniqueWithoutTenantInput | MedicalRecordUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: MedicalRecordCreateManyTenantInputEnvelope
    set?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    disconnect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    delete?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    update?: MedicalRecordUpdateWithWhereUniqueWithoutTenantInput | MedicalRecordUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: MedicalRecordUpdateManyWithWhereWithoutTenantInput | MedicalRecordUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
  }

  export type MedicationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<MedicationCreateWithoutTenantInput, MedicationUncheckedCreateWithoutTenantInput> | MedicationCreateWithoutTenantInput[] | MedicationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutTenantInput | MedicationCreateOrConnectWithoutTenantInput[]
    upsert?: MedicationUpsertWithWhereUniqueWithoutTenantInput | MedicationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: MedicationCreateManyTenantInputEnvelope
    set?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    disconnect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    delete?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    update?: MedicationUpdateWithWhereUniqueWithoutTenantInput | MedicationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: MedicationUpdateManyWithWhereWithoutTenantInput | MedicationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutTenantInput | PaymentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutTenantInput | PaymentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutTenantInput | PaymentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PharmacyOrderUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PharmacyOrderCreateWithoutTenantInput, PharmacyOrderUncheckedCreateWithoutTenantInput> | PharmacyOrderCreateWithoutTenantInput[] | PharmacyOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PharmacyOrderCreateOrConnectWithoutTenantInput | PharmacyOrderCreateOrConnectWithoutTenantInput[]
    upsert?: PharmacyOrderUpsertWithWhereUniqueWithoutTenantInput | PharmacyOrderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PharmacyOrderCreateManyTenantInputEnvelope
    set?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    disconnect?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    delete?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    connect?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    update?: PharmacyOrderUpdateWithWhereUniqueWithoutTenantInput | PharmacyOrderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PharmacyOrderUpdateManyWithWhereWithoutTenantInput | PharmacyOrderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PharmacyOrderScalarWhereInput | PharmacyOrderScalarWhereInput[]
  }

  export type PharmacyOrderItemUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PharmacyOrderItemCreateWithoutTenantInput, PharmacyOrderItemUncheckedCreateWithoutTenantInput> | PharmacyOrderItemCreateWithoutTenantInput[] | PharmacyOrderItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PharmacyOrderItemCreateOrConnectWithoutTenantInput | PharmacyOrderItemCreateOrConnectWithoutTenantInput[]
    upsert?: PharmacyOrderItemUpsertWithWhereUniqueWithoutTenantInput | PharmacyOrderItemUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PharmacyOrderItemCreateManyTenantInputEnvelope
    set?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    disconnect?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    delete?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    connect?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    update?: PharmacyOrderItemUpdateWithWhereUniqueWithoutTenantInput | PharmacyOrderItemUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PharmacyOrderItemUpdateManyWithWhereWithoutTenantInput | PharmacyOrderItemUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PharmacyOrderItemScalarWhereInput | PharmacyOrderItemScalarWhereInput[]
  }

  export type PrescriptionUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PrescriptionCreateWithoutTenantInput, PrescriptionUncheckedCreateWithoutTenantInput> | PrescriptionCreateWithoutTenantInput[] | PrescriptionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutTenantInput | PrescriptionCreateOrConnectWithoutTenantInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutTenantInput | PrescriptionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PrescriptionCreateManyTenantInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutTenantInput | PrescriptionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutTenantInput | PrescriptionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type PrescriptionItemUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PrescriptionItemCreateWithoutTenantInput, PrescriptionItemUncheckedCreateWithoutTenantInput> | PrescriptionItemCreateWithoutTenantInput[] | PrescriptionItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutTenantInput | PrescriptionItemCreateOrConnectWithoutTenantInput[]
    upsert?: PrescriptionItemUpsertWithWhereUniqueWithoutTenantInput | PrescriptionItemUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PrescriptionItemCreateManyTenantInputEnvelope
    set?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    disconnect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    delete?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    update?: PrescriptionItemUpdateWithWhereUniqueWithoutTenantInput | PrescriptionItemUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PrescriptionItemUpdateManyWithWhereWithoutTenantInput | PrescriptionItemUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutTenantInput, RefreshTokenUncheckedCreateWithoutTenantInput> | RefreshTokenCreateWithoutTenantInput[] | RefreshTokenUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutTenantInput | RefreshTokenCreateOrConnectWithoutTenantInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutTenantInput | RefreshTokenUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RefreshTokenCreateManyTenantInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutTenantInput | RefreshTokenUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutTenantInput | RefreshTokenUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type SpecialtyUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SpecialtyCreateWithoutTenantInput, SpecialtyUncheckedCreateWithoutTenantInput> | SpecialtyCreateWithoutTenantInput[] | SpecialtyUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SpecialtyCreateOrConnectWithoutTenantInput | SpecialtyCreateOrConnectWithoutTenantInput[]
    upsert?: SpecialtyUpsertWithWhereUniqueWithoutTenantInput | SpecialtyUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SpecialtyCreateManyTenantInputEnvelope
    set?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    disconnect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    delete?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    connect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    update?: SpecialtyUpdateWithWhereUniqueWithoutTenantInput | SpecialtyUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SpecialtyUpdateManyWithWhereWithoutTenantInput | SpecialtyUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SpecialtyScalarWhereInput | SpecialtyScalarWhereInput[]
  }

  export type StaffUpdateManyWithoutTenantNestedInput = {
    create?: XOR<StaffCreateWithoutTenantInput, StaffUncheckedCreateWithoutTenantInput> | StaffCreateWithoutTenantInput[] | StaffUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutTenantInput | StaffCreateOrConnectWithoutTenantInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutTenantInput | StaffUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: StaffCreateManyTenantInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutTenantInput | StaffUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutTenantInput | StaffUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PatientUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PatientCreateWithoutTenantInput, PatientUncheckedCreateWithoutTenantInput> | PatientCreateWithoutTenantInput[] | PatientUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutTenantInput | PatientCreateOrConnectWithoutTenantInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutTenantInput | PatientUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PatientCreateManyTenantInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutTenantInput | PatientUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutTenantInput | PatientUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type StudyUpdateManyWithoutTenantNestedInput = {
    create?: XOR<StudyCreateWithoutTenantInput, StudyUncheckedCreateWithoutTenantInput> | StudyCreateWithoutTenantInput[] | StudyUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StudyCreateOrConnectWithoutTenantInput | StudyCreateOrConnectWithoutTenantInput[]
    upsert?: StudyUpsertWithWhereUniqueWithoutTenantInput | StudyUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: StudyCreateManyTenantInputEnvelope
    set?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    disconnect?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    delete?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    connect?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    update?: StudyUpdateWithWhereUniqueWithoutTenantInput | StudyUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: StudyUpdateManyWithWhereWithoutTenantInput | StudyUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: StudyScalarWhereInput | StudyScalarWhereInput[]
  }

  export type RadReportUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RadReportCreateWithoutTenantInput, RadReportUncheckedCreateWithoutTenantInput> | RadReportCreateWithoutTenantInput[] | RadReportUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RadReportCreateOrConnectWithoutTenantInput | RadReportCreateOrConnectWithoutTenantInput[]
    upsert?: RadReportUpsertWithWhereUniqueWithoutTenantInput | RadReportUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RadReportCreateManyTenantInputEnvelope
    set?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    disconnect?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    delete?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    connect?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    update?: RadReportUpdateWithWhereUniqueWithoutTenantInput | RadReportUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RadReportUpdateManyWithWhereWithoutTenantInput | RadReportUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RadReportScalarWhereInput | RadReportScalarWhereInput[]
  }

  export type ReportTemplateUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ReportTemplateCreateWithoutTenantInput, ReportTemplateUncheckedCreateWithoutTenantInput> | ReportTemplateCreateWithoutTenantInput[] | ReportTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutTenantInput | ReportTemplateCreateOrConnectWithoutTenantInput[]
    upsert?: ReportTemplateUpsertWithWhereUniqueWithoutTenantInput | ReportTemplateUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ReportTemplateCreateManyTenantInputEnvelope
    set?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    disconnect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    delete?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    connect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    update?: ReportTemplateUpdateWithWhereUniqueWithoutTenantInput | ReportTemplateUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ReportTemplateUpdateManyWithWhereWithoutTenantInput | ReportTemplateUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ReportTemplateScalarWhereInput | ReportTemplateScalarWhereInput[]
  }

  export type TelemedicineConsultationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TelemedicineConsultationCreateWithoutTenantInput, TelemedicineConsultationUncheckedCreateWithoutTenantInput> | TelemedicineConsultationCreateWithoutTenantInput[] | TelemedicineConsultationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TelemedicineConsultationCreateOrConnectWithoutTenantInput | TelemedicineConsultationCreateOrConnectWithoutTenantInput[]
    upsert?: TelemedicineConsultationUpsertWithWhereUniqueWithoutTenantInput | TelemedicineConsultationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TelemedicineConsultationCreateManyTenantInputEnvelope
    set?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    disconnect?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    delete?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    connect?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    update?: TelemedicineConsultationUpdateWithWhereUniqueWithoutTenantInput | TelemedicineConsultationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TelemedicineConsultationUpdateManyWithWhereWithoutTenantInput | TelemedicineConsultationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TelemedicineConsultationScalarWhereInput | TelemedicineConsultationScalarWhereInput[]
  }

  export type VideoRoomUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VideoRoomCreateWithoutTenantInput, VideoRoomUncheckedCreateWithoutTenantInput> | VideoRoomCreateWithoutTenantInput[] | VideoRoomUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VideoRoomCreateOrConnectWithoutTenantInput | VideoRoomCreateOrConnectWithoutTenantInput[]
    upsert?: VideoRoomUpsertWithWhereUniqueWithoutTenantInput | VideoRoomUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VideoRoomCreateManyTenantInputEnvelope
    set?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    disconnect?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    delete?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    connect?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    update?: VideoRoomUpdateWithWhereUniqueWithoutTenantInput | VideoRoomUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VideoRoomUpdateManyWithWhereWithoutTenantInput | VideoRoomUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VideoRoomScalarWhereInput | VideoRoomScalarWhereInput[]
  }

  export type VideoParticipantUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VideoParticipantCreateWithoutTenantInput, VideoParticipantUncheckedCreateWithoutTenantInput> | VideoParticipantCreateWithoutTenantInput[] | VideoParticipantUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VideoParticipantCreateOrConnectWithoutTenantInput | VideoParticipantCreateOrConnectWithoutTenantInput[]
    upsert?: VideoParticipantUpsertWithWhereUniqueWithoutTenantInput | VideoParticipantUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VideoParticipantCreateManyTenantInputEnvelope
    set?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    disconnect?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    delete?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    connect?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    update?: VideoParticipantUpdateWithWhereUniqueWithoutTenantInput | VideoParticipantUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VideoParticipantUpdateManyWithWhereWithoutTenantInput | VideoParticipantUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VideoParticipantScalarWhereInput | VideoParticipantScalarWhereInput[]
  }

  export type VideoRecordingUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VideoRecordingCreateWithoutTenantInput, VideoRecordingUncheckedCreateWithoutTenantInput> | VideoRecordingCreateWithoutTenantInput[] | VideoRecordingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VideoRecordingCreateOrConnectWithoutTenantInput | VideoRecordingCreateOrConnectWithoutTenantInput[]
    upsert?: VideoRecordingUpsertWithWhereUniqueWithoutTenantInput | VideoRecordingUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VideoRecordingCreateManyTenantInputEnvelope
    set?: VideoRecordingWhereUniqueInput | VideoRecordingWhereUniqueInput[]
    disconnect?: VideoRecordingWhereUniqueInput | VideoRecordingWhereUniqueInput[]
    delete?: VideoRecordingWhereUniqueInput | VideoRecordingWhereUniqueInput[]
    connect?: VideoRecordingWhereUniqueInput | VideoRecordingWhereUniqueInput[]
    update?: VideoRecordingUpdateWithWhereUniqueWithoutTenantInput | VideoRecordingUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VideoRecordingUpdateManyWithWhereWithoutTenantInput | VideoRecordingUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VideoRecordingScalarWhereInput | VideoRecordingScalarWhereInput[]
  }

  export type VideoMessageUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VideoMessageCreateWithoutTenantInput, VideoMessageUncheckedCreateWithoutTenantInput> | VideoMessageCreateWithoutTenantInput[] | VideoMessageUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VideoMessageCreateOrConnectWithoutTenantInput | VideoMessageCreateOrConnectWithoutTenantInput[]
    upsert?: VideoMessageUpsertWithWhereUniqueWithoutTenantInput | VideoMessageUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VideoMessageCreateManyTenantInputEnvelope
    set?: VideoMessageWhereUniqueInput | VideoMessageWhereUniqueInput[]
    disconnect?: VideoMessageWhereUniqueInput | VideoMessageWhereUniqueInput[]
    delete?: VideoMessageWhereUniqueInput | VideoMessageWhereUniqueInput[]
    connect?: VideoMessageWhereUniqueInput | VideoMessageWhereUniqueInput[]
    update?: VideoMessageUpdateWithWhereUniqueWithoutTenantInput | VideoMessageUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VideoMessageUpdateManyWithWhereWithoutTenantInput | VideoMessageUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VideoMessageScalarWhereInput | VideoMessageScalarWhereInput[]
  }

  export type RadiologyOrderUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RadiologyOrderCreateWithoutTenantInput, RadiologyOrderUncheckedCreateWithoutTenantInput> | RadiologyOrderCreateWithoutTenantInput[] | RadiologyOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutTenantInput | RadiologyOrderCreateOrConnectWithoutTenantInput[]
    upsert?: RadiologyOrderUpsertWithWhereUniqueWithoutTenantInput | RadiologyOrderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RadiologyOrderCreateManyTenantInputEnvelope
    set?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    disconnect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    delete?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    update?: RadiologyOrderUpdateWithWhereUniqueWithoutTenantInput | RadiologyOrderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RadiologyOrderUpdateManyWithWhereWithoutTenantInput | RadiologyOrderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RadiologyOrderScalarWhereInput | RadiologyOrderScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AppointmentCreateWithoutTenantInput, AppointmentUncheckedCreateWithoutTenantInput> | AppointmentCreateWithoutTenantInput[] | AppointmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutTenantInput | AppointmentCreateOrConnectWithoutTenantInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutTenantInput | AppointmentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AppointmentCreateManyTenantInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutTenantInput | AppointmentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutTenantInput | AppointmentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DepartmentCreateWithoutTenantInput, DepartmentUncheckedCreateWithoutTenantInput> | DepartmentCreateWithoutTenantInput[] | DepartmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutTenantInput | DepartmentCreateOrConnectWithoutTenantInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutTenantInput | DepartmentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DepartmentCreateManyTenantInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutTenantInput | DepartmentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutTenantInput | DepartmentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTenantInput | InvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTenantInput | InvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTenantInput | InvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutTenantInput, InvoiceItemUncheckedCreateWithoutTenantInput> | InvoiceItemCreateWithoutTenantInput[] | InvoiceItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutTenantInput | InvoiceItemCreateOrConnectWithoutTenantInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutTenantInput | InvoiceItemUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoiceItemCreateManyTenantInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutTenantInput | InvoiceItemUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutTenantInput | InvoiceItemUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type LabOrderUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LabOrderCreateWithoutTenantInput, LabOrderUncheckedCreateWithoutTenantInput> | LabOrderCreateWithoutTenantInput[] | LabOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutTenantInput | LabOrderCreateOrConnectWithoutTenantInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutTenantInput | LabOrderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LabOrderCreateManyTenantInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutTenantInput | LabOrderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutTenantInput | LabOrderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LabOrderTestCreateWithoutTenantInput, LabOrderTestUncheckedCreateWithoutTenantInput> | LabOrderTestCreateWithoutTenantInput[] | LabOrderTestUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutTenantInput | LabOrderTestCreateOrConnectWithoutTenantInput[]
    upsert?: LabOrderTestUpsertWithWhereUniqueWithoutTenantInput | LabOrderTestUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LabOrderTestCreateManyTenantInputEnvelope
    set?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    disconnect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    delete?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    update?: LabOrderTestUpdateWithWhereUniqueWithoutTenantInput | LabOrderTestUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LabOrderTestUpdateManyWithWhereWithoutTenantInput | LabOrderTestUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LabOrderTestScalarWhereInput | LabOrderTestScalarWhereInput[]
  }

  export type LabTestUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LabTestCreateWithoutTenantInput, LabTestUncheckedCreateWithoutTenantInput> | LabTestCreateWithoutTenantInput[] | LabTestUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LabTestCreateOrConnectWithoutTenantInput | LabTestCreateOrConnectWithoutTenantInput[]
    upsert?: LabTestUpsertWithWhereUniqueWithoutTenantInput | LabTestUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LabTestCreateManyTenantInputEnvelope
    set?: LabTestWhereUniqueInput | LabTestWhereUniqueInput[]
    disconnect?: LabTestWhereUniqueInput | LabTestWhereUniqueInput[]
    delete?: LabTestWhereUniqueInput | LabTestWhereUniqueInput[]
    connect?: LabTestWhereUniqueInput | LabTestWhereUniqueInput[]
    update?: LabTestUpdateWithWhereUniqueWithoutTenantInput | LabTestUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LabTestUpdateManyWithWhereWithoutTenantInput | LabTestUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LabTestScalarWhereInput | LabTestScalarWhereInput[]
  }

  export type MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<MedicalRecordCreateWithoutTenantInput, MedicalRecordUncheckedCreateWithoutTenantInput> | MedicalRecordCreateWithoutTenantInput[] | MedicalRecordUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutTenantInput | MedicalRecordCreateOrConnectWithoutTenantInput[]
    upsert?: MedicalRecordUpsertWithWhereUniqueWithoutTenantInput | MedicalRecordUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: MedicalRecordCreateManyTenantInputEnvelope
    set?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    disconnect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    delete?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    update?: MedicalRecordUpdateWithWhereUniqueWithoutTenantInput | MedicalRecordUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: MedicalRecordUpdateManyWithWhereWithoutTenantInput | MedicalRecordUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
  }

  export type MedicationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<MedicationCreateWithoutTenantInput, MedicationUncheckedCreateWithoutTenantInput> | MedicationCreateWithoutTenantInput[] | MedicationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutTenantInput | MedicationCreateOrConnectWithoutTenantInput[]
    upsert?: MedicationUpsertWithWhereUniqueWithoutTenantInput | MedicationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: MedicationCreateManyTenantInputEnvelope
    set?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    disconnect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    delete?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    update?: MedicationUpdateWithWhereUniqueWithoutTenantInput | MedicationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: MedicationUpdateManyWithWhereWithoutTenantInput | MedicationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput> | PaymentCreateWithoutTenantInput[] | PaymentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTenantInput | PaymentCreateOrConnectWithoutTenantInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutTenantInput | PaymentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PaymentCreateManyTenantInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutTenantInput | PaymentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutTenantInput | PaymentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PharmacyOrderCreateWithoutTenantInput, PharmacyOrderUncheckedCreateWithoutTenantInput> | PharmacyOrderCreateWithoutTenantInput[] | PharmacyOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PharmacyOrderCreateOrConnectWithoutTenantInput | PharmacyOrderCreateOrConnectWithoutTenantInput[]
    upsert?: PharmacyOrderUpsertWithWhereUniqueWithoutTenantInput | PharmacyOrderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PharmacyOrderCreateManyTenantInputEnvelope
    set?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    disconnect?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    delete?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    connect?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    update?: PharmacyOrderUpdateWithWhereUniqueWithoutTenantInput | PharmacyOrderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PharmacyOrderUpdateManyWithWhereWithoutTenantInput | PharmacyOrderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PharmacyOrderScalarWhereInput | PharmacyOrderScalarWhereInput[]
  }

  export type PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PharmacyOrderItemCreateWithoutTenantInput, PharmacyOrderItemUncheckedCreateWithoutTenantInput> | PharmacyOrderItemCreateWithoutTenantInput[] | PharmacyOrderItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PharmacyOrderItemCreateOrConnectWithoutTenantInput | PharmacyOrderItemCreateOrConnectWithoutTenantInput[]
    upsert?: PharmacyOrderItemUpsertWithWhereUniqueWithoutTenantInput | PharmacyOrderItemUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PharmacyOrderItemCreateManyTenantInputEnvelope
    set?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    disconnect?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    delete?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    connect?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    update?: PharmacyOrderItemUpdateWithWhereUniqueWithoutTenantInput | PharmacyOrderItemUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PharmacyOrderItemUpdateManyWithWhereWithoutTenantInput | PharmacyOrderItemUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PharmacyOrderItemScalarWhereInput | PharmacyOrderItemScalarWhereInput[]
  }

  export type PrescriptionUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PrescriptionCreateWithoutTenantInput, PrescriptionUncheckedCreateWithoutTenantInput> | PrescriptionCreateWithoutTenantInput[] | PrescriptionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutTenantInput | PrescriptionCreateOrConnectWithoutTenantInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutTenantInput | PrescriptionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PrescriptionCreateManyTenantInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutTenantInput | PrescriptionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutTenantInput | PrescriptionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PrescriptionItemCreateWithoutTenantInput, PrescriptionItemUncheckedCreateWithoutTenantInput> | PrescriptionItemCreateWithoutTenantInput[] | PrescriptionItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutTenantInput | PrescriptionItemCreateOrConnectWithoutTenantInput[]
    upsert?: PrescriptionItemUpsertWithWhereUniqueWithoutTenantInput | PrescriptionItemUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PrescriptionItemCreateManyTenantInputEnvelope
    set?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    disconnect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    delete?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    update?: PrescriptionItemUpdateWithWhereUniqueWithoutTenantInput | PrescriptionItemUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PrescriptionItemUpdateManyWithWhereWithoutTenantInput | PrescriptionItemUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutTenantInput, RefreshTokenUncheckedCreateWithoutTenantInput> | RefreshTokenCreateWithoutTenantInput[] | RefreshTokenUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutTenantInput | RefreshTokenCreateOrConnectWithoutTenantInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutTenantInput | RefreshTokenUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RefreshTokenCreateManyTenantInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutTenantInput | RefreshTokenUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutTenantInput | RefreshTokenUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type SpecialtyUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SpecialtyCreateWithoutTenantInput, SpecialtyUncheckedCreateWithoutTenantInput> | SpecialtyCreateWithoutTenantInput[] | SpecialtyUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SpecialtyCreateOrConnectWithoutTenantInput | SpecialtyCreateOrConnectWithoutTenantInput[]
    upsert?: SpecialtyUpsertWithWhereUniqueWithoutTenantInput | SpecialtyUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SpecialtyCreateManyTenantInputEnvelope
    set?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    disconnect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    delete?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    connect?: SpecialtyWhereUniqueInput | SpecialtyWhereUniqueInput[]
    update?: SpecialtyUpdateWithWhereUniqueWithoutTenantInput | SpecialtyUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SpecialtyUpdateManyWithWhereWithoutTenantInput | SpecialtyUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SpecialtyScalarWhereInput | SpecialtyScalarWhereInput[]
  }

  export type StaffUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<StaffCreateWithoutTenantInput, StaffUncheckedCreateWithoutTenantInput> | StaffCreateWithoutTenantInput[] | StaffUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StaffCreateOrConnectWithoutTenantInput | StaffCreateOrConnectWithoutTenantInput[]
    upsert?: StaffUpsertWithWhereUniqueWithoutTenantInput | StaffUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: StaffCreateManyTenantInputEnvelope
    set?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    disconnect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    delete?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    connect?: StaffWhereUniqueInput | StaffWhereUniqueInput[]
    update?: StaffUpdateWithWhereUniqueWithoutTenantInput | StaffUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: StaffUpdateManyWithWhereWithoutTenantInput | StaffUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: StaffScalarWhereInput | StaffScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PatientUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PatientCreateWithoutTenantInput, PatientUncheckedCreateWithoutTenantInput> | PatientCreateWithoutTenantInput[] | PatientUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutTenantInput | PatientCreateOrConnectWithoutTenantInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutTenantInput | PatientUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PatientCreateManyTenantInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutTenantInput | PatientUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutTenantInput | PatientUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type StudyUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<StudyCreateWithoutTenantInput, StudyUncheckedCreateWithoutTenantInput> | StudyCreateWithoutTenantInput[] | StudyUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StudyCreateOrConnectWithoutTenantInput | StudyCreateOrConnectWithoutTenantInput[]
    upsert?: StudyUpsertWithWhereUniqueWithoutTenantInput | StudyUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: StudyCreateManyTenantInputEnvelope
    set?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    disconnect?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    delete?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    connect?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    update?: StudyUpdateWithWhereUniqueWithoutTenantInput | StudyUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: StudyUpdateManyWithWhereWithoutTenantInput | StudyUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: StudyScalarWhereInput | StudyScalarWhereInput[]
  }

  export type RadReportUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RadReportCreateWithoutTenantInput, RadReportUncheckedCreateWithoutTenantInput> | RadReportCreateWithoutTenantInput[] | RadReportUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RadReportCreateOrConnectWithoutTenantInput | RadReportCreateOrConnectWithoutTenantInput[]
    upsert?: RadReportUpsertWithWhereUniqueWithoutTenantInput | RadReportUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RadReportCreateManyTenantInputEnvelope
    set?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    disconnect?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    delete?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    connect?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    update?: RadReportUpdateWithWhereUniqueWithoutTenantInput | RadReportUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RadReportUpdateManyWithWhereWithoutTenantInput | RadReportUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RadReportScalarWhereInput | RadReportScalarWhereInput[]
  }

  export type ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ReportTemplateCreateWithoutTenantInput, ReportTemplateUncheckedCreateWithoutTenantInput> | ReportTemplateCreateWithoutTenantInput[] | ReportTemplateUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutTenantInput | ReportTemplateCreateOrConnectWithoutTenantInput[]
    upsert?: ReportTemplateUpsertWithWhereUniqueWithoutTenantInput | ReportTemplateUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ReportTemplateCreateManyTenantInputEnvelope
    set?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    disconnect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    delete?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    connect?: ReportTemplateWhereUniqueInput | ReportTemplateWhereUniqueInput[]
    update?: ReportTemplateUpdateWithWhereUniqueWithoutTenantInput | ReportTemplateUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ReportTemplateUpdateManyWithWhereWithoutTenantInput | ReportTemplateUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ReportTemplateScalarWhereInput | ReportTemplateScalarWhereInput[]
  }

  export type TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TelemedicineConsultationCreateWithoutTenantInput, TelemedicineConsultationUncheckedCreateWithoutTenantInput> | TelemedicineConsultationCreateWithoutTenantInput[] | TelemedicineConsultationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TelemedicineConsultationCreateOrConnectWithoutTenantInput | TelemedicineConsultationCreateOrConnectWithoutTenantInput[]
    upsert?: TelemedicineConsultationUpsertWithWhereUniqueWithoutTenantInput | TelemedicineConsultationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TelemedicineConsultationCreateManyTenantInputEnvelope
    set?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    disconnect?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    delete?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    connect?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    update?: TelemedicineConsultationUpdateWithWhereUniqueWithoutTenantInput | TelemedicineConsultationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TelemedicineConsultationUpdateManyWithWhereWithoutTenantInput | TelemedicineConsultationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TelemedicineConsultationScalarWhereInput | TelemedicineConsultationScalarWhereInput[]
  }

  export type VideoRoomUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VideoRoomCreateWithoutTenantInput, VideoRoomUncheckedCreateWithoutTenantInput> | VideoRoomCreateWithoutTenantInput[] | VideoRoomUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VideoRoomCreateOrConnectWithoutTenantInput | VideoRoomCreateOrConnectWithoutTenantInput[]
    upsert?: VideoRoomUpsertWithWhereUniqueWithoutTenantInput | VideoRoomUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VideoRoomCreateManyTenantInputEnvelope
    set?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    disconnect?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    delete?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    connect?: VideoRoomWhereUniqueInput | VideoRoomWhereUniqueInput[]
    update?: VideoRoomUpdateWithWhereUniqueWithoutTenantInput | VideoRoomUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VideoRoomUpdateManyWithWhereWithoutTenantInput | VideoRoomUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VideoRoomScalarWhereInput | VideoRoomScalarWhereInput[]
  }

  export type VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VideoParticipantCreateWithoutTenantInput, VideoParticipantUncheckedCreateWithoutTenantInput> | VideoParticipantCreateWithoutTenantInput[] | VideoParticipantUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VideoParticipantCreateOrConnectWithoutTenantInput | VideoParticipantCreateOrConnectWithoutTenantInput[]
    upsert?: VideoParticipantUpsertWithWhereUniqueWithoutTenantInput | VideoParticipantUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VideoParticipantCreateManyTenantInputEnvelope
    set?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    disconnect?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    delete?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    connect?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    update?: VideoParticipantUpdateWithWhereUniqueWithoutTenantInput | VideoParticipantUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VideoParticipantUpdateManyWithWhereWithoutTenantInput | VideoParticipantUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VideoParticipantScalarWhereInput | VideoParticipantScalarWhereInput[]
  }

  export type VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VideoRecordingCreateWithoutTenantInput, VideoRecordingUncheckedCreateWithoutTenantInput> | VideoRecordingCreateWithoutTenantInput[] | VideoRecordingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VideoRecordingCreateOrConnectWithoutTenantInput | VideoRecordingCreateOrConnectWithoutTenantInput[]
    upsert?: VideoRecordingUpsertWithWhereUniqueWithoutTenantInput | VideoRecordingUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VideoRecordingCreateManyTenantInputEnvelope
    set?: VideoRecordingWhereUniqueInput | VideoRecordingWhereUniqueInput[]
    disconnect?: VideoRecordingWhereUniqueInput | VideoRecordingWhereUniqueInput[]
    delete?: VideoRecordingWhereUniqueInput | VideoRecordingWhereUniqueInput[]
    connect?: VideoRecordingWhereUniqueInput | VideoRecordingWhereUniqueInput[]
    update?: VideoRecordingUpdateWithWhereUniqueWithoutTenantInput | VideoRecordingUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VideoRecordingUpdateManyWithWhereWithoutTenantInput | VideoRecordingUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VideoRecordingScalarWhereInput | VideoRecordingScalarWhereInput[]
  }

  export type VideoMessageUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<VideoMessageCreateWithoutTenantInput, VideoMessageUncheckedCreateWithoutTenantInput> | VideoMessageCreateWithoutTenantInput[] | VideoMessageUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: VideoMessageCreateOrConnectWithoutTenantInput | VideoMessageCreateOrConnectWithoutTenantInput[]
    upsert?: VideoMessageUpsertWithWhereUniqueWithoutTenantInput | VideoMessageUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: VideoMessageCreateManyTenantInputEnvelope
    set?: VideoMessageWhereUniqueInput | VideoMessageWhereUniqueInput[]
    disconnect?: VideoMessageWhereUniqueInput | VideoMessageWhereUniqueInput[]
    delete?: VideoMessageWhereUniqueInput | VideoMessageWhereUniqueInput[]
    connect?: VideoMessageWhereUniqueInput | VideoMessageWhereUniqueInput[]
    update?: VideoMessageUpdateWithWhereUniqueWithoutTenantInput | VideoMessageUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: VideoMessageUpdateManyWithWhereWithoutTenantInput | VideoMessageUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: VideoMessageScalarWhereInput | VideoMessageScalarWhereInput[]
  }

  export type RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RadiologyOrderCreateWithoutTenantInput, RadiologyOrderUncheckedCreateWithoutTenantInput> | RadiologyOrderCreateWithoutTenantInput[] | RadiologyOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutTenantInput | RadiologyOrderCreateOrConnectWithoutTenantInput[]
    upsert?: RadiologyOrderUpsertWithWhereUniqueWithoutTenantInput | RadiologyOrderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RadiologyOrderCreateManyTenantInputEnvelope
    set?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    disconnect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    delete?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    update?: RadiologyOrderUpdateWithWhereUniqueWithoutTenantInput | RadiologyOrderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RadiologyOrderUpdateManyWithWhereWithoutTenantInput | RadiologyOrderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RadiologyOrderScalarWhereInput | RadiologyOrderScalarWhereInput[]
  }

  export type AppointmentCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type LabOrderCreateNestedManyWithoutDoctorInput = {
    create?: XOR<LabOrderCreateWithoutDoctorInput, LabOrderUncheckedCreateWithoutDoctorInput> | LabOrderCreateWithoutDoctorInput[] | LabOrderUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutDoctorInput | LabOrderCreateOrConnectWithoutDoctorInput[]
    createMany?: LabOrderCreateManyDoctorInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type PharmacyOrderCreateNestedManyWithoutDoctorInput = {
    create?: XOR<PharmacyOrderCreateWithoutDoctorInput, PharmacyOrderUncheckedCreateWithoutDoctorInput> | PharmacyOrderCreateWithoutDoctorInput[] | PharmacyOrderUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PharmacyOrderCreateOrConnectWithoutDoctorInput | PharmacyOrderCreateOrConnectWithoutDoctorInput[]
    createMany?: PharmacyOrderCreateManyDoctorInputEnvelope
    connect?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
  }

  export type PrescriptionCreateNestedManyWithoutDoctorInput = {
    create?: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput> | PrescriptionCreateWithoutDoctorInput[] | PrescriptionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDoctorInput | PrescriptionCreateOrConnectWithoutDoctorInput[]
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type TelemedicineConsultationCreateNestedManyWithoutDoctorInput = {
    create?: XOR<TelemedicineConsultationCreateWithoutDoctorInput, TelemedicineConsultationUncheckedCreateWithoutDoctorInput> | TelemedicineConsultationCreateWithoutDoctorInput[] | TelemedicineConsultationUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: TelemedicineConsultationCreateOrConnectWithoutDoctorInput | TelemedicineConsultationCreateOrConnectWithoutDoctorInput[]
    createMany?: TelemedicineConsultationCreateManyDoctorInputEnvelope
    connect?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
  }

  export type RadiologyOrderCreateNestedManyWithoutDoctorInput = {
    create?: XOR<RadiologyOrderCreateWithoutDoctorInput, RadiologyOrderUncheckedCreateWithoutDoctorInput> | RadiologyOrderCreateWithoutDoctorInput[] | RadiologyOrderUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutDoctorInput | RadiologyOrderCreateOrConnectWithoutDoctorInput[]
    createMany?: RadiologyOrderCreateManyDoctorInputEnvelope
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type StaffCreateNestedOneWithoutUserInput = {
    create?: XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffCreateOrConnectWithoutUserInput
    connect?: StaffWhereUniqueInput
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type MedicalRecordCreateNestedManyWithoutDoctorInput = {
    create?: XOR<MedicalRecordCreateWithoutDoctorInput, MedicalRecordUncheckedCreateWithoutDoctorInput> | MedicalRecordCreateWithoutDoctorInput[] | MedicalRecordUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutDoctorInput | MedicalRecordCreateOrConnectWithoutDoctorInput[]
    createMany?: MedicalRecordCreateManyDoctorInputEnvelope
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
  }

  export type MedicalRecordCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<MedicalRecordCreateWithoutUpdatedByInput, MedicalRecordUncheckedCreateWithoutUpdatedByInput> | MedicalRecordCreateWithoutUpdatedByInput[] | MedicalRecordUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutUpdatedByInput | MedicalRecordCreateOrConnectWithoutUpdatedByInput[]
    createMany?: MedicalRecordCreateManyUpdatedByInputEnvelope
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type AppointmentUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type LabOrderUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<LabOrderCreateWithoutDoctorInput, LabOrderUncheckedCreateWithoutDoctorInput> | LabOrderCreateWithoutDoctorInput[] | LabOrderUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutDoctorInput | LabOrderCreateOrConnectWithoutDoctorInput[]
    createMany?: LabOrderCreateManyDoctorInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type PharmacyOrderUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<PharmacyOrderCreateWithoutDoctorInput, PharmacyOrderUncheckedCreateWithoutDoctorInput> | PharmacyOrderCreateWithoutDoctorInput[] | PharmacyOrderUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PharmacyOrderCreateOrConnectWithoutDoctorInput | PharmacyOrderCreateOrConnectWithoutDoctorInput[]
    createMany?: PharmacyOrderCreateManyDoctorInputEnvelope
    connect?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput> | PrescriptionCreateWithoutDoctorInput[] | PrescriptionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDoctorInput | PrescriptionCreateOrConnectWithoutDoctorInput[]
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type TelemedicineConsultationUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<TelemedicineConsultationCreateWithoutDoctorInput, TelemedicineConsultationUncheckedCreateWithoutDoctorInput> | TelemedicineConsultationCreateWithoutDoctorInput[] | TelemedicineConsultationUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: TelemedicineConsultationCreateOrConnectWithoutDoctorInput | TelemedicineConsultationCreateOrConnectWithoutDoctorInput[]
    createMany?: TelemedicineConsultationCreateManyDoctorInputEnvelope
    connect?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
  }

  export type RadiologyOrderUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<RadiologyOrderCreateWithoutDoctorInput, RadiologyOrderUncheckedCreateWithoutDoctorInput> | RadiologyOrderCreateWithoutDoctorInput[] | RadiologyOrderUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutDoctorInput | RadiologyOrderCreateOrConnectWithoutDoctorInput[]
    createMany?: RadiologyOrderCreateManyDoctorInputEnvelope
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type StaffUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffCreateOrConnectWithoutUserInput
    connect?: StaffWhereUniqueInput
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type MedicalRecordUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<MedicalRecordCreateWithoutDoctorInput, MedicalRecordUncheckedCreateWithoutDoctorInput> | MedicalRecordCreateWithoutDoctorInput[] | MedicalRecordUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutDoctorInput | MedicalRecordCreateOrConnectWithoutDoctorInput[]
    createMany?: MedicalRecordCreateManyDoctorInputEnvelope
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
  }

  export type MedicalRecordUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<MedicalRecordCreateWithoutUpdatedByInput, MedicalRecordUncheckedCreateWithoutUpdatedByInput> | MedicalRecordCreateWithoutUpdatedByInput[] | MedicalRecordUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutUpdatedByInput | MedicalRecordCreateOrConnectWithoutUpdatedByInput[]
    createMany?: MedicalRecordCreateManyUpdatedByInputEnvelope
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AppointmentUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDoctorInput | AppointmentUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDoctorInput | AppointmentUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDoctorInput | AppointmentUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type LabOrderUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<LabOrderCreateWithoutDoctorInput, LabOrderUncheckedCreateWithoutDoctorInput> | LabOrderCreateWithoutDoctorInput[] | LabOrderUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutDoctorInput | LabOrderCreateOrConnectWithoutDoctorInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutDoctorInput | LabOrderUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: LabOrderCreateManyDoctorInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutDoctorInput | LabOrderUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutDoctorInput | LabOrderUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type PharmacyOrderUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<PharmacyOrderCreateWithoutDoctorInput, PharmacyOrderUncheckedCreateWithoutDoctorInput> | PharmacyOrderCreateWithoutDoctorInput[] | PharmacyOrderUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PharmacyOrderCreateOrConnectWithoutDoctorInput | PharmacyOrderCreateOrConnectWithoutDoctorInput[]
    upsert?: PharmacyOrderUpsertWithWhereUniqueWithoutDoctorInput | PharmacyOrderUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: PharmacyOrderCreateManyDoctorInputEnvelope
    set?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    disconnect?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    delete?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    connect?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    update?: PharmacyOrderUpdateWithWhereUniqueWithoutDoctorInput | PharmacyOrderUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: PharmacyOrderUpdateManyWithWhereWithoutDoctorInput | PharmacyOrderUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: PharmacyOrderScalarWhereInput | PharmacyOrderScalarWhereInput[]
  }

  export type PrescriptionUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput> | PrescriptionCreateWithoutDoctorInput[] | PrescriptionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDoctorInput | PrescriptionCreateOrConnectWithoutDoctorInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutDoctorInput | PrescriptionUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutDoctorInput | PrescriptionUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutDoctorInput | PrescriptionUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type TelemedicineConsultationUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<TelemedicineConsultationCreateWithoutDoctorInput, TelemedicineConsultationUncheckedCreateWithoutDoctorInput> | TelemedicineConsultationCreateWithoutDoctorInput[] | TelemedicineConsultationUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: TelemedicineConsultationCreateOrConnectWithoutDoctorInput | TelemedicineConsultationCreateOrConnectWithoutDoctorInput[]
    upsert?: TelemedicineConsultationUpsertWithWhereUniqueWithoutDoctorInput | TelemedicineConsultationUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: TelemedicineConsultationCreateManyDoctorInputEnvelope
    set?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    disconnect?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    delete?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    connect?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    update?: TelemedicineConsultationUpdateWithWhereUniqueWithoutDoctorInput | TelemedicineConsultationUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: TelemedicineConsultationUpdateManyWithWhereWithoutDoctorInput | TelemedicineConsultationUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: TelemedicineConsultationScalarWhereInput | TelemedicineConsultationScalarWhereInput[]
  }

  export type RadiologyOrderUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<RadiologyOrderCreateWithoutDoctorInput, RadiologyOrderUncheckedCreateWithoutDoctorInput> | RadiologyOrderCreateWithoutDoctorInput[] | RadiologyOrderUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutDoctorInput | RadiologyOrderCreateOrConnectWithoutDoctorInput[]
    upsert?: RadiologyOrderUpsertWithWhereUniqueWithoutDoctorInput | RadiologyOrderUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: RadiologyOrderCreateManyDoctorInputEnvelope
    set?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    disconnect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    delete?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    update?: RadiologyOrderUpdateWithWhereUniqueWithoutDoctorInput | RadiologyOrderUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: RadiologyOrderUpdateManyWithWhereWithoutDoctorInput | RadiologyOrderUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: RadiologyOrderScalarWhereInput | RadiologyOrderScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type StaffUpdateOneWithoutUserNestedInput = {
    create?: XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffCreateOrConnectWithoutUserInput
    upsert?: StaffUpsertWithoutUserInput
    disconnect?: StaffWhereInput | boolean
    delete?: StaffWhereInput | boolean
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutUserInput, StaffUpdateWithoutUserInput>, StaffUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type MedicalRecordUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<MedicalRecordCreateWithoutDoctorInput, MedicalRecordUncheckedCreateWithoutDoctorInput> | MedicalRecordCreateWithoutDoctorInput[] | MedicalRecordUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutDoctorInput | MedicalRecordCreateOrConnectWithoutDoctorInput[]
    upsert?: MedicalRecordUpsertWithWhereUniqueWithoutDoctorInput | MedicalRecordUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: MedicalRecordCreateManyDoctorInputEnvelope
    set?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    disconnect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    delete?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    update?: MedicalRecordUpdateWithWhereUniqueWithoutDoctorInput | MedicalRecordUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: MedicalRecordUpdateManyWithWhereWithoutDoctorInput | MedicalRecordUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
  }

  export type MedicalRecordUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<MedicalRecordCreateWithoutUpdatedByInput, MedicalRecordUncheckedCreateWithoutUpdatedByInput> | MedicalRecordCreateWithoutUpdatedByInput[] | MedicalRecordUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutUpdatedByInput | MedicalRecordCreateOrConnectWithoutUpdatedByInput[]
    upsert?: MedicalRecordUpsertWithWhereUniqueWithoutUpdatedByInput | MedicalRecordUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: MedicalRecordCreateManyUpdatedByInputEnvelope
    set?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    disconnect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    delete?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    update?: MedicalRecordUpdateWithWhereUniqueWithoutUpdatedByInput | MedicalRecordUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: MedicalRecordUpdateManyWithWhereWithoutUpdatedByInput | MedicalRecordUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type AppointmentUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDoctorInput | AppointmentUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDoctorInput | AppointmentUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDoctorInput | AppointmentUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type LabOrderUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<LabOrderCreateWithoutDoctorInput, LabOrderUncheckedCreateWithoutDoctorInput> | LabOrderCreateWithoutDoctorInput[] | LabOrderUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutDoctorInput | LabOrderCreateOrConnectWithoutDoctorInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutDoctorInput | LabOrderUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: LabOrderCreateManyDoctorInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutDoctorInput | LabOrderUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutDoctorInput | LabOrderUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type PharmacyOrderUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<PharmacyOrderCreateWithoutDoctorInput, PharmacyOrderUncheckedCreateWithoutDoctorInput> | PharmacyOrderCreateWithoutDoctorInput[] | PharmacyOrderUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PharmacyOrderCreateOrConnectWithoutDoctorInput | PharmacyOrderCreateOrConnectWithoutDoctorInput[]
    upsert?: PharmacyOrderUpsertWithWhereUniqueWithoutDoctorInput | PharmacyOrderUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: PharmacyOrderCreateManyDoctorInputEnvelope
    set?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    disconnect?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    delete?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    connect?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    update?: PharmacyOrderUpdateWithWhereUniqueWithoutDoctorInput | PharmacyOrderUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: PharmacyOrderUpdateManyWithWhereWithoutDoctorInput | PharmacyOrderUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: PharmacyOrderScalarWhereInput | PharmacyOrderScalarWhereInput[]
  }

  export type PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput> | PrescriptionCreateWithoutDoctorInput[] | PrescriptionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDoctorInput | PrescriptionCreateOrConnectWithoutDoctorInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutDoctorInput | PrescriptionUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutDoctorInput | PrescriptionUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutDoctorInput | PrescriptionUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type TelemedicineConsultationUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<TelemedicineConsultationCreateWithoutDoctorInput, TelemedicineConsultationUncheckedCreateWithoutDoctorInput> | TelemedicineConsultationCreateWithoutDoctorInput[] | TelemedicineConsultationUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: TelemedicineConsultationCreateOrConnectWithoutDoctorInput | TelemedicineConsultationCreateOrConnectWithoutDoctorInput[]
    upsert?: TelemedicineConsultationUpsertWithWhereUniqueWithoutDoctorInput | TelemedicineConsultationUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: TelemedicineConsultationCreateManyDoctorInputEnvelope
    set?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    disconnect?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    delete?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    connect?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    update?: TelemedicineConsultationUpdateWithWhereUniqueWithoutDoctorInput | TelemedicineConsultationUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: TelemedicineConsultationUpdateManyWithWhereWithoutDoctorInput | TelemedicineConsultationUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: TelemedicineConsultationScalarWhereInput | TelemedicineConsultationScalarWhereInput[]
  }

  export type RadiologyOrderUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<RadiologyOrderCreateWithoutDoctorInput, RadiologyOrderUncheckedCreateWithoutDoctorInput> | RadiologyOrderCreateWithoutDoctorInput[] | RadiologyOrderUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutDoctorInput | RadiologyOrderCreateOrConnectWithoutDoctorInput[]
    upsert?: RadiologyOrderUpsertWithWhereUniqueWithoutDoctorInput | RadiologyOrderUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: RadiologyOrderCreateManyDoctorInputEnvelope
    set?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    disconnect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    delete?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    update?: RadiologyOrderUpdateWithWhereUniqueWithoutDoctorInput | RadiologyOrderUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: RadiologyOrderUpdateManyWithWhereWithoutDoctorInput | RadiologyOrderUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: RadiologyOrderScalarWhereInput | RadiologyOrderScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type StaffUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffCreateOrConnectWithoutUserInput
    upsert?: StaffUpsertWithoutUserInput
    disconnect?: StaffWhereInput | boolean
    delete?: StaffWhereInput | boolean
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutUserInput, StaffUpdateWithoutUserInput>, StaffUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type MedicalRecordUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<MedicalRecordCreateWithoutDoctorInput, MedicalRecordUncheckedCreateWithoutDoctorInput> | MedicalRecordCreateWithoutDoctorInput[] | MedicalRecordUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutDoctorInput | MedicalRecordCreateOrConnectWithoutDoctorInput[]
    upsert?: MedicalRecordUpsertWithWhereUniqueWithoutDoctorInput | MedicalRecordUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: MedicalRecordCreateManyDoctorInputEnvelope
    set?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    disconnect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    delete?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    update?: MedicalRecordUpdateWithWhereUniqueWithoutDoctorInput | MedicalRecordUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: MedicalRecordUpdateManyWithWhereWithoutDoctorInput | MedicalRecordUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
  }

  export type MedicalRecordUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<MedicalRecordCreateWithoutUpdatedByInput, MedicalRecordUncheckedCreateWithoutUpdatedByInput> | MedicalRecordCreateWithoutUpdatedByInput[] | MedicalRecordUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutUpdatedByInput | MedicalRecordCreateOrConnectWithoutUpdatedByInput[]
    upsert?: MedicalRecordUpsertWithWhereUniqueWithoutUpdatedByInput | MedicalRecordUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: MedicalRecordCreateManyUpdatedByInputEnvelope
    set?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    disconnect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    delete?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    update?: MedicalRecordUpdateWithWhereUniqueWithoutUpdatedByInput | MedicalRecordUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: MedicalRecordUpdateManyWithWhereWithoutUpdatedByInput | MedicalRecordUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<TenantCreateWithoutRefreshTokensInput, TenantUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRefreshTokensInput
    connect?: TenantWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type TenantUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<TenantCreateWithoutRefreshTokensInput, TenantUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRefreshTokensInput
    upsert?: TenantUpsertWithoutRefreshTokensInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutRefreshTokensInput, TenantUpdateWithoutRefreshTokensInput>, TenantUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type AppointmentCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutPatientInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LabOrderCreateNestedManyWithoutPatientInput = {
    create?: XOR<LabOrderCreateWithoutPatientInput, LabOrderUncheckedCreateWithoutPatientInput> | LabOrderCreateWithoutPatientInput[] | LabOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutPatientInput | LabOrderCreateOrConnectWithoutPatientInput[]
    createMany?: LabOrderCreateManyPatientInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type MedicalRecordCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicalRecordCreateWithoutPatientInput, MedicalRecordUncheckedCreateWithoutPatientInput> | MedicalRecordCreateWithoutPatientInput[] | MedicalRecordUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutPatientInput | MedicalRecordCreateOrConnectWithoutPatientInput[]
    createMany?: MedicalRecordCreateManyPatientInputEnvelope
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
  }

  export type PharmacyOrderCreateNestedManyWithoutPatientInput = {
    create?: XOR<PharmacyOrderCreateWithoutPatientInput, PharmacyOrderUncheckedCreateWithoutPatientInput> | PharmacyOrderCreateWithoutPatientInput[] | PharmacyOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PharmacyOrderCreateOrConnectWithoutPatientInput | PharmacyOrderCreateOrConnectWithoutPatientInput[]
    createMany?: PharmacyOrderCreateManyPatientInputEnvelope
    connect?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
  }

  export type PrescriptionCreateNestedManyWithoutPatientInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type PrescriptionItemCreateNestedManyWithoutPatientInput = {
    create?: XOR<PrescriptionItemCreateWithoutPatientInput, PrescriptionItemUncheckedCreateWithoutPatientInput> | PrescriptionItemCreateWithoutPatientInput[] | PrescriptionItemUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPatientInput | PrescriptionItemCreateOrConnectWithoutPatientInput[]
    createMany?: PrescriptionItemCreateManyPatientInputEnvelope
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
  }

  export type StudyCreateNestedManyWithoutPatientInput = {
    create?: XOR<StudyCreateWithoutPatientInput, StudyUncheckedCreateWithoutPatientInput> | StudyCreateWithoutPatientInput[] | StudyUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: StudyCreateOrConnectWithoutPatientInput | StudyCreateOrConnectWithoutPatientInput[]
    createMany?: StudyCreateManyPatientInputEnvelope
    connect?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
  }

  export type TelemedicineConsultationCreateNestedManyWithoutPatientInput = {
    create?: XOR<TelemedicineConsultationCreateWithoutPatientInput, TelemedicineConsultationUncheckedCreateWithoutPatientInput> | TelemedicineConsultationCreateWithoutPatientInput[] | TelemedicineConsultationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TelemedicineConsultationCreateOrConnectWithoutPatientInput | TelemedicineConsultationCreateOrConnectWithoutPatientInput[]
    createMany?: TelemedicineConsultationCreateManyPatientInputEnvelope
    connect?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
  }

  export type RadiologyOrderCreateNestedManyWithoutPatientInput = {
    create?: XOR<RadiologyOrderCreateWithoutPatientInput, RadiologyOrderUncheckedCreateWithoutPatientInput> | RadiologyOrderCreateWithoutPatientInput[] | RadiologyOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutPatientInput | RadiologyOrderCreateOrConnectWithoutPatientInput[]
    createMany?: RadiologyOrderCreateManyPatientInputEnvelope
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutPatientsInput = {
    create?: XOR<TenantCreateWithoutPatientsInput, TenantUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPatientsInput
    connect?: TenantWhereUniqueInput
  }

  export type AppointmentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type LabOrderUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<LabOrderCreateWithoutPatientInput, LabOrderUncheckedCreateWithoutPatientInput> | LabOrderCreateWithoutPatientInput[] | LabOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutPatientInput | LabOrderCreateOrConnectWithoutPatientInput[]
    createMany?: LabOrderCreateManyPatientInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type MedicalRecordUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicalRecordCreateWithoutPatientInput, MedicalRecordUncheckedCreateWithoutPatientInput> | MedicalRecordCreateWithoutPatientInput[] | MedicalRecordUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutPatientInput | MedicalRecordCreateOrConnectWithoutPatientInput[]
    createMany?: MedicalRecordCreateManyPatientInputEnvelope
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
  }

  export type PharmacyOrderUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PharmacyOrderCreateWithoutPatientInput, PharmacyOrderUncheckedCreateWithoutPatientInput> | PharmacyOrderCreateWithoutPatientInput[] | PharmacyOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PharmacyOrderCreateOrConnectWithoutPatientInput | PharmacyOrderCreateOrConnectWithoutPatientInput[]
    createMany?: PharmacyOrderCreateManyPatientInputEnvelope
    connect?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type PrescriptionItemUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PrescriptionItemCreateWithoutPatientInput, PrescriptionItemUncheckedCreateWithoutPatientInput> | PrescriptionItemCreateWithoutPatientInput[] | PrescriptionItemUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPatientInput | PrescriptionItemCreateOrConnectWithoutPatientInput[]
    createMany?: PrescriptionItemCreateManyPatientInputEnvelope
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
  }

  export type StudyUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<StudyCreateWithoutPatientInput, StudyUncheckedCreateWithoutPatientInput> | StudyCreateWithoutPatientInput[] | StudyUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: StudyCreateOrConnectWithoutPatientInput | StudyCreateOrConnectWithoutPatientInput[]
    createMany?: StudyCreateManyPatientInputEnvelope
    connect?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
  }

  export type TelemedicineConsultationUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<TelemedicineConsultationCreateWithoutPatientInput, TelemedicineConsultationUncheckedCreateWithoutPatientInput> | TelemedicineConsultationCreateWithoutPatientInput[] | TelemedicineConsultationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TelemedicineConsultationCreateOrConnectWithoutPatientInput | TelemedicineConsultationCreateOrConnectWithoutPatientInput[]
    createMany?: TelemedicineConsultationCreateManyPatientInputEnvelope
    connect?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
  }

  export type RadiologyOrderUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<RadiologyOrderCreateWithoutPatientInput, RadiologyOrderUncheckedCreateWithoutPatientInput> | RadiologyOrderCreateWithoutPatientInput[] | RadiologyOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutPatientInput | RadiologyOrderCreateOrConnectWithoutPatientInput[]
    createMany?: RadiologyOrderCreateManyPatientInputEnvelope
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type NullableEnumBloodTypeFieldUpdateOperationsInput = {
    set?: $Enums.BloodType | null
  }

  export type NullableEnumMaritalStatusFieldUpdateOperationsInput = {
    set?: $Enums.MaritalStatus | null
  }

  export type NullableEnumInsuranceTypeFieldUpdateOperationsInput = {
    set?: $Enums.InsuranceType | null
  }

  export type AppointmentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPatientInput | InvoiceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPatientInput | InvoiceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPatientInput | InvoiceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LabOrderUpdateManyWithoutPatientNestedInput = {
    create?: XOR<LabOrderCreateWithoutPatientInput, LabOrderUncheckedCreateWithoutPatientInput> | LabOrderCreateWithoutPatientInput[] | LabOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutPatientInput | LabOrderCreateOrConnectWithoutPatientInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutPatientInput | LabOrderUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: LabOrderCreateManyPatientInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutPatientInput | LabOrderUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutPatientInput | LabOrderUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type MedicalRecordUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicalRecordCreateWithoutPatientInput, MedicalRecordUncheckedCreateWithoutPatientInput> | MedicalRecordCreateWithoutPatientInput[] | MedicalRecordUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutPatientInput | MedicalRecordCreateOrConnectWithoutPatientInput[]
    upsert?: MedicalRecordUpsertWithWhereUniqueWithoutPatientInput | MedicalRecordUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicalRecordCreateManyPatientInputEnvelope
    set?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    disconnect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    delete?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    update?: MedicalRecordUpdateWithWhereUniqueWithoutPatientInput | MedicalRecordUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicalRecordUpdateManyWithWhereWithoutPatientInput | MedicalRecordUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
  }

  export type PharmacyOrderUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PharmacyOrderCreateWithoutPatientInput, PharmacyOrderUncheckedCreateWithoutPatientInput> | PharmacyOrderCreateWithoutPatientInput[] | PharmacyOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PharmacyOrderCreateOrConnectWithoutPatientInput | PharmacyOrderCreateOrConnectWithoutPatientInput[]
    upsert?: PharmacyOrderUpsertWithWhereUniqueWithoutPatientInput | PharmacyOrderUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PharmacyOrderCreateManyPatientInputEnvelope
    set?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    disconnect?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    delete?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    connect?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    update?: PharmacyOrderUpdateWithWhereUniqueWithoutPatientInput | PharmacyOrderUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PharmacyOrderUpdateManyWithWhereWithoutPatientInput | PharmacyOrderUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PharmacyOrderScalarWhereInput | PharmacyOrderScalarWhereInput[]
  }

  export type PrescriptionUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutPatientInput | PrescriptionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutPatientInput | PrescriptionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutPatientInput | PrescriptionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type PrescriptionItemUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PrescriptionItemCreateWithoutPatientInput, PrescriptionItemUncheckedCreateWithoutPatientInput> | PrescriptionItemCreateWithoutPatientInput[] | PrescriptionItemUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPatientInput | PrescriptionItemCreateOrConnectWithoutPatientInput[]
    upsert?: PrescriptionItemUpsertWithWhereUniqueWithoutPatientInput | PrescriptionItemUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PrescriptionItemCreateManyPatientInputEnvelope
    set?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    disconnect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    delete?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    update?: PrescriptionItemUpdateWithWhereUniqueWithoutPatientInput | PrescriptionItemUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PrescriptionItemUpdateManyWithWhereWithoutPatientInput | PrescriptionItemUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
  }

  export type StudyUpdateManyWithoutPatientNestedInput = {
    create?: XOR<StudyCreateWithoutPatientInput, StudyUncheckedCreateWithoutPatientInput> | StudyCreateWithoutPatientInput[] | StudyUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: StudyCreateOrConnectWithoutPatientInput | StudyCreateOrConnectWithoutPatientInput[]
    upsert?: StudyUpsertWithWhereUniqueWithoutPatientInput | StudyUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: StudyCreateManyPatientInputEnvelope
    set?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    disconnect?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    delete?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    connect?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    update?: StudyUpdateWithWhereUniqueWithoutPatientInput | StudyUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: StudyUpdateManyWithWhereWithoutPatientInput | StudyUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: StudyScalarWhereInput | StudyScalarWhereInput[]
  }

  export type TelemedicineConsultationUpdateManyWithoutPatientNestedInput = {
    create?: XOR<TelemedicineConsultationCreateWithoutPatientInput, TelemedicineConsultationUncheckedCreateWithoutPatientInput> | TelemedicineConsultationCreateWithoutPatientInput[] | TelemedicineConsultationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TelemedicineConsultationCreateOrConnectWithoutPatientInput | TelemedicineConsultationCreateOrConnectWithoutPatientInput[]
    upsert?: TelemedicineConsultationUpsertWithWhereUniqueWithoutPatientInput | TelemedicineConsultationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: TelemedicineConsultationCreateManyPatientInputEnvelope
    set?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    disconnect?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    delete?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    connect?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    update?: TelemedicineConsultationUpdateWithWhereUniqueWithoutPatientInput | TelemedicineConsultationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: TelemedicineConsultationUpdateManyWithWhereWithoutPatientInput | TelemedicineConsultationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: TelemedicineConsultationScalarWhereInput | TelemedicineConsultationScalarWhereInput[]
  }

  export type RadiologyOrderUpdateManyWithoutPatientNestedInput = {
    create?: XOR<RadiologyOrderCreateWithoutPatientInput, RadiologyOrderUncheckedCreateWithoutPatientInput> | RadiologyOrderCreateWithoutPatientInput[] | RadiologyOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutPatientInput | RadiologyOrderCreateOrConnectWithoutPatientInput[]
    upsert?: RadiologyOrderUpsertWithWhereUniqueWithoutPatientInput | RadiologyOrderUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: RadiologyOrderCreateManyPatientInputEnvelope
    set?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    disconnect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    delete?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    update?: RadiologyOrderUpdateWithWhereUniqueWithoutPatientInput | RadiologyOrderUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: RadiologyOrderUpdateManyWithWhereWithoutPatientInput | RadiologyOrderUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: RadiologyOrderScalarWhereInput | RadiologyOrderScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutPatientsNestedInput = {
    create?: XOR<TenantCreateWithoutPatientsInput, TenantUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPatientsInput
    upsert?: TenantUpsertWithoutPatientsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPatientsInput, TenantUpdateWithoutPatientsInput>, TenantUncheckedUpdateWithoutPatientsInput>
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPatientInput | InvoiceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPatientInput | InvoiceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPatientInput | InvoiceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type LabOrderUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<LabOrderCreateWithoutPatientInput, LabOrderUncheckedCreateWithoutPatientInput> | LabOrderCreateWithoutPatientInput[] | LabOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutPatientInput | LabOrderCreateOrConnectWithoutPatientInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutPatientInput | LabOrderUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: LabOrderCreateManyPatientInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutPatientInput | LabOrderUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutPatientInput | LabOrderUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type MedicalRecordUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicalRecordCreateWithoutPatientInput, MedicalRecordUncheckedCreateWithoutPatientInput> | MedicalRecordCreateWithoutPatientInput[] | MedicalRecordUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalRecordCreateOrConnectWithoutPatientInput | MedicalRecordCreateOrConnectWithoutPatientInput[]
    upsert?: MedicalRecordUpsertWithWhereUniqueWithoutPatientInput | MedicalRecordUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicalRecordCreateManyPatientInputEnvelope
    set?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    disconnect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    delete?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    connect?: MedicalRecordWhereUniqueInput | MedicalRecordWhereUniqueInput[]
    update?: MedicalRecordUpdateWithWhereUniqueWithoutPatientInput | MedicalRecordUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicalRecordUpdateManyWithWhereWithoutPatientInput | MedicalRecordUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
  }

  export type PharmacyOrderUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PharmacyOrderCreateWithoutPatientInput, PharmacyOrderUncheckedCreateWithoutPatientInput> | PharmacyOrderCreateWithoutPatientInput[] | PharmacyOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PharmacyOrderCreateOrConnectWithoutPatientInput | PharmacyOrderCreateOrConnectWithoutPatientInput[]
    upsert?: PharmacyOrderUpsertWithWhereUniqueWithoutPatientInput | PharmacyOrderUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PharmacyOrderCreateManyPatientInputEnvelope
    set?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    disconnect?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    delete?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    connect?: PharmacyOrderWhereUniqueInput | PharmacyOrderWhereUniqueInput[]
    update?: PharmacyOrderUpdateWithWhereUniqueWithoutPatientInput | PharmacyOrderUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PharmacyOrderUpdateManyWithWhereWithoutPatientInput | PharmacyOrderUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PharmacyOrderScalarWhereInput | PharmacyOrderScalarWhereInput[]
  }

  export type PrescriptionUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutPatientInput | PrescriptionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutPatientInput | PrescriptionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutPatientInput | PrescriptionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type PrescriptionItemUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PrescriptionItemCreateWithoutPatientInput, PrescriptionItemUncheckedCreateWithoutPatientInput> | PrescriptionItemCreateWithoutPatientInput[] | PrescriptionItemUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPatientInput | PrescriptionItemCreateOrConnectWithoutPatientInput[]
    upsert?: PrescriptionItemUpsertWithWhereUniqueWithoutPatientInput | PrescriptionItemUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PrescriptionItemCreateManyPatientInputEnvelope
    set?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    disconnect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    delete?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    update?: PrescriptionItemUpdateWithWhereUniqueWithoutPatientInput | PrescriptionItemUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PrescriptionItemUpdateManyWithWhereWithoutPatientInput | PrescriptionItemUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
  }

  export type StudyUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<StudyCreateWithoutPatientInput, StudyUncheckedCreateWithoutPatientInput> | StudyCreateWithoutPatientInput[] | StudyUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: StudyCreateOrConnectWithoutPatientInput | StudyCreateOrConnectWithoutPatientInput[]
    upsert?: StudyUpsertWithWhereUniqueWithoutPatientInput | StudyUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: StudyCreateManyPatientInputEnvelope
    set?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    disconnect?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    delete?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    connect?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    update?: StudyUpdateWithWhereUniqueWithoutPatientInput | StudyUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: StudyUpdateManyWithWhereWithoutPatientInput | StudyUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: StudyScalarWhereInput | StudyScalarWhereInput[]
  }

  export type TelemedicineConsultationUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<TelemedicineConsultationCreateWithoutPatientInput, TelemedicineConsultationUncheckedCreateWithoutPatientInput> | TelemedicineConsultationCreateWithoutPatientInput[] | TelemedicineConsultationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TelemedicineConsultationCreateOrConnectWithoutPatientInput | TelemedicineConsultationCreateOrConnectWithoutPatientInput[]
    upsert?: TelemedicineConsultationUpsertWithWhereUniqueWithoutPatientInput | TelemedicineConsultationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: TelemedicineConsultationCreateManyPatientInputEnvelope
    set?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    disconnect?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    delete?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    connect?: TelemedicineConsultationWhereUniqueInput | TelemedicineConsultationWhereUniqueInput[]
    update?: TelemedicineConsultationUpdateWithWhereUniqueWithoutPatientInput | TelemedicineConsultationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: TelemedicineConsultationUpdateManyWithWhereWithoutPatientInput | TelemedicineConsultationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: TelemedicineConsultationScalarWhereInput | TelemedicineConsultationScalarWhereInput[]
  }

  export type RadiologyOrderUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<RadiologyOrderCreateWithoutPatientInput, RadiologyOrderUncheckedCreateWithoutPatientInput> | RadiologyOrderCreateWithoutPatientInput[] | RadiologyOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutPatientInput | RadiologyOrderCreateOrConnectWithoutPatientInput[]
    upsert?: RadiologyOrderUpsertWithWhereUniqueWithoutPatientInput | RadiologyOrderUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: RadiologyOrderCreateManyPatientInputEnvelope
    set?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    disconnect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    delete?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    update?: RadiologyOrderUpdateWithWhereUniqueWithoutPatientInput | RadiologyOrderUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: RadiologyOrderUpdateManyWithWhereWithoutPatientInput | RadiologyOrderUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: RadiologyOrderScalarWhereInput | RadiologyOrderScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<TenantCreateWithoutAppointmentsInput, TenantUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAppointmentsInput
    connect?: TenantWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<DepartmentCreateWithoutAppointmentsInput, DepartmentUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutAppointmentsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDoctorAppointmentsInput = {
    create?: XOR<UserCreateWithoutDoctorAppointmentsInput, UserUncheckedCreateWithoutDoctorAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorAppointmentsInput
    connect?: UserWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
  }

  export type EnumAppointmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentStatus
  }

  export type TenantUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<TenantCreateWithoutAppointmentsInput, TenantUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAppointmentsInput
    upsert?: TenantUpsertWithoutAppointmentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAppointmentsInput, TenantUpdateWithoutAppointmentsInput>, TenantUncheckedUpdateWithoutAppointmentsInput>
  }

  export type DepartmentUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<DepartmentCreateWithoutAppointmentsInput, DepartmentUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutAppointmentsInput
    upsert?: DepartmentUpsertWithoutAppointmentsInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutAppointmentsInput, DepartmentUpdateWithoutAppointmentsInput>, DepartmentUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserUpdateOneRequiredWithoutDoctorAppointmentsNestedInput = {
    create?: XOR<UserCreateWithoutDoctorAppointmentsInput, UserUncheckedCreateWithoutDoctorAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorAppointmentsInput
    upsert?: UserUpsertWithoutDoctorAppointmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDoctorAppointmentsInput, UserUpdateWithoutDoctorAppointmentsInput>, UserUncheckedUpdateWithoutDoctorAppointmentsInput>
  }

  export type PatientUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    upsert?: PatientUpsertWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAppointmentsInput, PatientUpdateWithoutAppointmentsInput>, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type TenantCreateNestedOneWithoutPrescriptionsInput = {
    create?: XOR<TenantCreateWithoutPrescriptionsInput, TenantUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPrescriptionsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPrescriptionsInput = {
    create?: XOR<UserCreateWithoutPrescriptionsInput, UserUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrescriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutPrescriptionsInput = {
    create?: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrescriptionsInput
    connect?: PatientWhereUniqueInput
  }

  export type PrescriptionItemCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput> | PrescriptionItemCreateWithoutPrescriptionInput[] | PrescriptionItemUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPrescriptionInput | PrescriptionItemCreateOrConnectWithoutPrescriptionInput[]
    createMany?: PrescriptionItemCreateManyPrescriptionInputEnvelope
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
  }

  export type PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput> | PrescriptionItemCreateWithoutPrescriptionInput[] | PrescriptionItemUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPrescriptionInput | PrescriptionItemCreateOrConnectWithoutPrescriptionInput[]
    createMany?: PrescriptionItemCreateManyPrescriptionInputEnvelope
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
  }

  export type EnumPrescriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.PrescriptionStatus
  }

  export type TenantUpdateOneRequiredWithoutPrescriptionsNestedInput = {
    create?: XOR<TenantCreateWithoutPrescriptionsInput, TenantUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPrescriptionsInput
    upsert?: TenantUpsertWithoutPrescriptionsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPrescriptionsInput, TenantUpdateWithoutPrescriptionsInput>, TenantUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type UserUpdateOneRequiredWithoutPrescriptionsNestedInput = {
    create?: XOR<UserCreateWithoutPrescriptionsInput, UserUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPrescriptionsInput
    upsert?: UserUpsertWithoutPrescriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPrescriptionsInput, UserUpdateWithoutPrescriptionsInput>, UserUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type PatientUpdateOneRequiredWithoutPrescriptionsNestedInput = {
    create?: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrescriptionsInput
    upsert?: PatientUpsertWithoutPrescriptionsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPrescriptionsInput, PatientUpdateWithoutPrescriptionsInput>, PatientUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type PrescriptionItemUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput> | PrescriptionItemCreateWithoutPrescriptionInput[] | PrescriptionItemUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPrescriptionInput | PrescriptionItemCreateOrConnectWithoutPrescriptionInput[]
    upsert?: PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput | PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: PrescriptionItemCreateManyPrescriptionInputEnvelope
    set?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    disconnect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    delete?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    update?: PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput | PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput | PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
  }

  export type PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput> | PrescriptionItemCreateWithoutPrescriptionInput[] | PrescriptionItemUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPrescriptionInput | PrescriptionItemCreateOrConnectWithoutPrescriptionInput[]
    upsert?: PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput | PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: PrescriptionItemCreateManyPrescriptionInputEnvelope
    set?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    disconnect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    delete?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    update?: PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput | PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput | PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutPrescriptionItemsInput = {
    create?: XOR<TenantCreateWithoutPrescriptionItemsInput, TenantUncheckedCreateWithoutPrescriptionItemsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPrescriptionItemsInput
    connect?: TenantWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutPrescriptionItemsInput = {
    create?: XOR<PatientCreateWithoutPrescriptionItemsInput, PatientUncheckedCreateWithoutPrescriptionItemsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrescriptionItemsInput
    connect?: PatientWhereUniqueInput
  }

  export type MedicationCreateNestedOneWithoutPrescriptionItemsInput = {
    create?: XOR<MedicationCreateWithoutPrescriptionItemsInput, MedicationUncheckedCreateWithoutPrescriptionItemsInput>
    connectOrCreate?: MedicationCreateOrConnectWithoutPrescriptionItemsInput
    connect?: MedicationWhereUniqueInput
  }

  export type PrescriptionCreateNestedOneWithoutPrescriptionItemsInput = {
    create?: XOR<PrescriptionCreateWithoutPrescriptionItemsInput, PrescriptionUncheckedCreateWithoutPrescriptionItemsInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPrescriptionItemsInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutPrescriptionItemsNestedInput = {
    create?: XOR<TenantCreateWithoutPrescriptionItemsInput, TenantUncheckedCreateWithoutPrescriptionItemsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPrescriptionItemsInput
    upsert?: TenantUpsertWithoutPrescriptionItemsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPrescriptionItemsInput, TenantUpdateWithoutPrescriptionItemsInput>, TenantUncheckedUpdateWithoutPrescriptionItemsInput>
  }

  export type PatientUpdateOneRequiredWithoutPrescriptionItemsNestedInput = {
    create?: XOR<PatientCreateWithoutPrescriptionItemsInput, PatientUncheckedCreateWithoutPrescriptionItemsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrescriptionItemsInput
    upsert?: PatientUpsertWithoutPrescriptionItemsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPrescriptionItemsInput, PatientUpdateWithoutPrescriptionItemsInput>, PatientUncheckedUpdateWithoutPrescriptionItemsInput>
  }

  export type MedicationUpdateOneRequiredWithoutPrescriptionItemsNestedInput = {
    create?: XOR<MedicationCreateWithoutPrescriptionItemsInput, MedicationUncheckedCreateWithoutPrescriptionItemsInput>
    connectOrCreate?: MedicationCreateOrConnectWithoutPrescriptionItemsInput
    upsert?: MedicationUpsertWithoutPrescriptionItemsInput
    connect?: MedicationWhereUniqueInput
    update?: XOR<XOR<MedicationUpdateToOneWithWhereWithoutPrescriptionItemsInput, MedicationUpdateWithoutPrescriptionItemsInput>, MedicationUncheckedUpdateWithoutPrescriptionItemsInput>
  }

  export type PrescriptionUpdateOneRequiredWithoutPrescriptionItemsNestedInput = {
    create?: XOR<PrescriptionCreateWithoutPrescriptionItemsInput, PrescriptionUncheckedCreateWithoutPrescriptionItemsInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPrescriptionItemsInput
    upsert?: PrescriptionUpsertWithoutPrescriptionItemsInput
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<XOR<PrescriptionUpdateToOneWithWhereWithoutPrescriptionItemsInput, PrescriptionUpdateWithoutPrescriptionItemsInput>, PrescriptionUncheckedUpdateWithoutPrescriptionItemsInput>
  }

  export type TenantCreateNestedOneWithoutMedicalRecordsInput = {
    create?: XOR<TenantCreateWithoutMedicalRecordsInput, TenantUncheckedCreateWithoutMedicalRecordsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMedicalRecordsInput
    connect?: TenantWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutMedicalRecordsInput = {
    create?: XOR<PatientCreateWithoutMedicalRecordsInput, PatientUncheckedCreateWithoutMedicalRecordsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicalRecordsInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedMedicalRecordsInput = {
    create?: XOR<UserCreateWithoutCreatedMedicalRecordsInput, UserUncheckedCreateWithoutCreatedMedicalRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedMedicalRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedMedicalRecordsInput = {
    create?: XOR<UserCreateWithoutUpdatedMedicalRecordsInput, UserUncheckedCreateWithoutUpdatedMedicalRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedMedicalRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutMedicalRecordsNestedInput = {
    create?: XOR<TenantCreateWithoutMedicalRecordsInput, TenantUncheckedCreateWithoutMedicalRecordsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMedicalRecordsInput
    upsert?: TenantUpsertWithoutMedicalRecordsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutMedicalRecordsInput, TenantUpdateWithoutMedicalRecordsInput>, TenantUncheckedUpdateWithoutMedicalRecordsInput>
  }

  export type PatientUpdateOneRequiredWithoutMedicalRecordsNestedInput = {
    create?: XOR<PatientCreateWithoutMedicalRecordsInput, PatientUncheckedCreateWithoutMedicalRecordsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicalRecordsInput
    upsert?: PatientUpsertWithoutMedicalRecordsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutMedicalRecordsInput, PatientUpdateWithoutMedicalRecordsInput>, PatientUncheckedUpdateWithoutMedicalRecordsInput>
  }

  export type UserUpdateOneWithoutCreatedMedicalRecordsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedMedicalRecordsInput, UserUncheckedCreateWithoutCreatedMedicalRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedMedicalRecordsInput
    upsert?: UserUpsertWithoutCreatedMedicalRecordsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedMedicalRecordsInput, UserUpdateWithoutCreatedMedicalRecordsInput>, UserUncheckedUpdateWithoutCreatedMedicalRecordsInput>
  }

  export type UserUpdateOneWithoutUpdatedMedicalRecordsNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedMedicalRecordsInput, UserUncheckedCreateWithoutUpdatedMedicalRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedMedicalRecordsInput
    upsert?: UserUpsertWithoutUpdatedMedicalRecordsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedMedicalRecordsInput, UserUpdateWithoutUpdatedMedicalRecordsInput>, UserUncheckedUpdateWithoutUpdatedMedicalRecordsInput>
  }

  export type TenantCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoicesInput
    connect?: TenantWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutInvoicesInput
    connect?: PatientWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PharmacyOrderCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<PharmacyOrderCreateWithoutInvoiceInput, PharmacyOrderUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: PharmacyOrderCreateOrConnectWithoutInvoiceInput
    connect?: PharmacyOrderWhereUniqueInput
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PharmacyOrderUncheckedCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<PharmacyOrderCreateWithoutInvoiceInput, PharmacyOrderUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: PharmacyOrderCreateOrConnectWithoutInvoiceInput
    connect?: PharmacyOrderWhereUniqueInput
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoicesInput
    upsert?: TenantUpsertWithoutInvoicesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInvoicesInput, TenantUpdateWithoutInvoicesInput>, TenantUncheckedUpdateWithoutInvoicesInput>
  }

  export type PatientUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutInvoicesInput
    upsert?: PatientUpsertWithoutInvoicesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutInvoicesInput, PatientUpdateWithoutInvoicesInput>, PatientUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PharmacyOrderUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<PharmacyOrderCreateWithoutInvoiceInput, PharmacyOrderUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: PharmacyOrderCreateOrConnectWithoutInvoiceInput
    upsert?: PharmacyOrderUpsertWithoutInvoiceInput
    disconnect?: PharmacyOrderWhereInput | boolean
    delete?: PharmacyOrderWhereInput | boolean
    connect?: PharmacyOrderWhereUniqueInput
    update?: XOR<XOR<PharmacyOrderUpdateToOneWithWhereWithoutInvoiceInput, PharmacyOrderUpdateWithoutInvoiceInput>, PharmacyOrderUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PharmacyOrderUncheckedUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<PharmacyOrderCreateWithoutInvoiceInput, PharmacyOrderUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: PharmacyOrderCreateOrConnectWithoutInvoiceInput
    upsert?: PharmacyOrderUpsertWithoutInvoiceInput
    disconnect?: PharmacyOrderWhereInput | boolean
    delete?: PharmacyOrderWhereInput | boolean
    connect?: PharmacyOrderWhereUniqueInput
    update?: XOR<XOR<PharmacyOrderUpdateToOneWithWhereWithoutInvoiceInput, PharmacyOrderUpdateWithoutInvoiceInput>, PharmacyOrderUncheckedUpdateWithoutInvoiceInput>
  }

  export type TenantCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<TenantCreateWithoutInvoiceItemsInput, TenantUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoiceItemsInput
    connect?: TenantWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<InvoiceCreateWithoutInvoiceItemsInput, InvoiceUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutInvoiceItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutInvoiceItemsNestedInput = {
    create?: XOR<TenantCreateWithoutInvoiceItemsInput, TenantUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoiceItemsInput
    upsert?: TenantUpsertWithoutInvoiceItemsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInvoiceItemsInput, TenantUpdateWithoutInvoiceItemsInput>, TenantUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type InvoiceUpdateOneRequiredWithoutInvoiceItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutInvoiceItemsInput, InvoiceUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutInvoiceItemsInput
    upsert?: InvoiceUpsertWithoutInvoiceItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutInvoiceItemsInput, InvoiceUpdateWithoutInvoiceItemsInput>, InvoiceUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type TenantCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentsInput
    connect?: TenantWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type TenantUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPaymentsInput
    upsert?: TenantUpsertWithoutPaymentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPaymentsInput, TenantUpdateWithoutPaymentsInput>, TenantUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type LabOrderTestCreateNestedManyWithoutTestInput = {
    create?: XOR<LabOrderTestCreateWithoutTestInput, LabOrderTestUncheckedCreateWithoutTestInput> | LabOrderTestCreateWithoutTestInput[] | LabOrderTestUncheckedCreateWithoutTestInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutTestInput | LabOrderTestCreateOrConnectWithoutTestInput[]
    createMany?: LabOrderTestCreateManyTestInputEnvelope
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
  }

  export type TenantCreateNestedOneWithoutLabTestsInput = {
    create?: XOR<TenantCreateWithoutLabTestsInput, TenantUncheckedCreateWithoutLabTestsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLabTestsInput
    connect?: TenantWhereUniqueInput
  }

  export type LabOrderTestUncheckedCreateNestedManyWithoutTestInput = {
    create?: XOR<LabOrderTestCreateWithoutTestInput, LabOrderTestUncheckedCreateWithoutTestInput> | LabOrderTestCreateWithoutTestInput[] | LabOrderTestUncheckedCreateWithoutTestInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutTestInput | LabOrderTestCreateOrConnectWithoutTestInput[]
    createMany?: LabOrderTestCreateManyTestInputEnvelope
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LabOrderTestUpdateManyWithoutTestNestedInput = {
    create?: XOR<LabOrderTestCreateWithoutTestInput, LabOrderTestUncheckedCreateWithoutTestInput> | LabOrderTestCreateWithoutTestInput[] | LabOrderTestUncheckedCreateWithoutTestInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutTestInput | LabOrderTestCreateOrConnectWithoutTestInput[]
    upsert?: LabOrderTestUpsertWithWhereUniqueWithoutTestInput | LabOrderTestUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: LabOrderTestCreateManyTestInputEnvelope
    set?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    disconnect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    delete?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    update?: LabOrderTestUpdateWithWhereUniqueWithoutTestInput | LabOrderTestUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: LabOrderTestUpdateManyWithWhereWithoutTestInput | LabOrderTestUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: LabOrderTestScalarWhereInput | LabOrderTestScalarWhereInput[]
  }

  export type TenantUpdateOneRequiredWithoutLabTestsNestedInput = {
    create?: XOR<TenantCreateWithoutLabTestsInput, TenantUncheckedCreateWithoutLabTestsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLabTestsInput
    upsert?: TenantUpsertWithoutLabTestsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutLabTestsInput, TenantUpdateWithoutLabTestsInput>, TenantUncheckedUpdateWithoutLabTestsInput>
  }

  export type LabOrderTestUncheckedUpdateManyWithoutTestNestedInput = {
    create?: XOR<LabOrderTestCreateWithoutTestInput, LabOrderTestUncheckedCreateWithoutTestInput> | LabOrderTestCreateWithoutTestInput[] | LabOrderTestUncheckedCreateWithoutTestInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutTestInput | LabOrderTestCreateOrConnectWithoutTestInput[]
    upsert?: LabOrderTestUpsertWithWhereUniqueWithoutTestInput | LabOrderTestUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: LabOrderTestCreateManyTestInputEnvelope
    set?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    disconnect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    delete?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    update?: LabOrderTestUpdateWithWhereUniqueWithoutTestInput | LabOrderTestUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: LabOrderTestUpdateManyWithWhereWithoutTestInput | LabOrderTestUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: LabOrderTestScalarWhereInput | LabOrderTestScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutLabOrdersInput = {
    create?: XOR<TenantCreateWithoutLabOrdersInput, TenantUncheckedCreateWithoutLabOrdersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLabOrdersInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDoctorLabOrdersInput = {
    create?: XOR<UserCreateWithoutDoctorLabOrdersInput, UserUncheckedCreateWithoutDoctorLabOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorLabOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutLabOrdersInput = {
    create?: XOR<PatientCreateWithoutLabOrdersInput, PatientUncheckedCreateWithoutLabOrdersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutLabOrdersInput
    connect?: PatientWhereUniqueInput
  }

  export type LabOrderTestCreateNestedManyWithoutOrderInput = {
    create?: XOR<LabOrderTestCreateWithoutOrderInput, LabOrderTestUncheckedCreateWithoutOrderInput> | LabOrderTestCreateWithoutOrderInput[] | LabOrderTestUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutOrderInput | LabOrderTestCreateOrConnectWithoutOrderInput[]
    createMany?: LabOrderTestCreateManyOrderInputEnvelope
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
  }

  export type TelemedicineConsultationCreateNestedOneWithoutLabOrdersInput = {
    create?: XOR<TelemedicineConsultationCreateWithoutLabOrdersInput, TelemedicineConsultationUncheckedCreateWithoutLabOrdersInput>
    connectOrCreate?: TelemedicineConsultationCreateOrConnectWithoutLabOrdersInput
    connect?: TelemedicineConsultationWhereUniqueInput
  }

  export type LabOrderTestUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<LabOrderTestCreateWithoutOrderInput, LabOrderTestUncheckedCreateWithoutOrderInput> | LabOrderTestCreateWithoutOrderInput[] | LabOrderTestUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutOrderInput | LabOrderTestCreateOrConnectWithoutOrderInput[]
    createMany?: LabOrderTestCreateManyOrderInputEnvelope
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
  }

  export type EnumLabOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.LabOrderStatus
  }

  export type TenantUpdateOneRequiredWithoutLabOrdersNestedInput = {
    create?: XOR<TenantCreateWithoutLabOrdersInput, TenantUncheckedCreateWithoutLabOrdersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLabOrdersInput
    upsert?: TenantUpsertWithoutLabOrdersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutLabOrdersInput, TenantUpdateWithoutLabOrdersInput>, TenantUncheckedUpdateWithoutLabOrdersInput>
  }

  export type UserUpdateOneWithoutDoctorLabOrdersNestedInput = {
    create?: XOR<UserCreateWithoutDoctorLabOrdersInput, UserUncheckedCreateWithoutDoctorLabOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorLabOrdersInput
    upsert?: UserUpsertWithoutDoctorLabOrdersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDoctorLabOrdersInput, UserUpdateWithoutDoctorLabOrdersInput>, UserUncheckedUpdateWithoutDoctorLabOrdersInput>
  }

  export type PatientUpdateOneRequiredWithoutLabOrdersNestedInput = {
    create?: XOR<PatientCreateWithoutLabOrdersInput, PatientUncheckedCreateWithoutLabOrdersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutLabOrdersInput
    upsert?: PatientUpsertWithoutLabOrdersInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutLabOrdersInput, PatientUpdateWithoutLabOrdersInput>, PatientUncheckedUpdateWithoutLabOrdersInput>
  }

  export type LabOrderTestUpdateManyWithoutOrderNestedInput = {
    create?: XOR<LabOrderTestCreateWithoutOrderInput, LabOrderTestUncheckedCreateWithoutOrderInput> | LabOrderTestCreateWithoutOrderInput[] | LabOrderTestUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutOrderInput | LabOrderTestCreateOrConnectWithoutOrderInput[]
    upsert?: LabOrderTestUpsertWithWhereUniqueWithoutOrderInput | LabOrderTestUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: LabOrderTestCreateManyOrderInputEnvelope
    set?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    disconnect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    delete?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    update?: LabOrderTestUpdateWithWhereUniqueWithoutOrderInput | LabOrderTestUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: LabOrderTestUpdateManyWithWhereWithoutOrderInput | LabOrderTestUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: LabOrderTestScalarWhereInput | LabOrderTestScalarWhereInput[]
  }

  export type TelemedicineConsultationUpdateOneWithoutLabOrdersNestedInput = {
    create?: XOR<TelemedicineConsultationCreateWithoutLabOrdersInput, TelemedicineConsultationUncheckedCreateWithoutLabOrdersInput>
    connectOrCreate?: TelemedicineConsultationCreateOrConnectWithoutLabOrdersInput
    upsert?: TelemedicineConsultationUpsertWithoutLabOrdersInput
    disconnect?: TelemedicineConsultationWhereInput | boolean
    delete?: TelemedicineConsultationWhereInput | boolean
    connect?: TelemedicineConsultationWhereUniqueInput
    update?: XOR<XOR<TelemedicineConsultationUpdateToOneWithWhereWithoutLabOrdersInput, TelemedicineConsultationUpdateWithoutLabOrdersInput>, TelemedicineConsultationUncheckedUpdateWithoutLabOrdersInput>
  }

  export type LabOrderTestUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<LabOrderTestCreateWithoutOrderInput, LabOrderTestUncheckedCreateWithoutOrderInput> | LabOrderTestCreateWithoutOrderInput[] | LabOrderTestUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: LabOrderTestCreateOrConnectWithoutOrderInput | LabOrderTestCreateOrConnectWithoutOrderInput[]
    upsert?: LabOrderTestUpsertWithWhereUniqueWithoutOrderInput | LabOrderTestUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: LabOrderTestCreateManyOrderInputEnvelope
    set?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    disconnect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    delete?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    connect?: LabOrderTestWhereUniqueInput | LabOrderTestWhereUniqueInput[]
    update?: LabOrderTestUpdateWithWhereUniqueWithoutOrderInput | LabOrderTestUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: LabOrderTestUpdateManyWithWhereWithoutOrderInput | LabOrderTestUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: LabOrderTestScalarWhereInput | LabOrderTestScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutLabOrderTestsInput = {
    create?: XOR<TenantCreateWithoutLabOrderTestsInput, TenantUncheckedCreateWithoutLabOrderTestsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLabOrderTestsInput
    connect?: TenantWhereUniqueInput
  }

  export type LabTestCreateNestedOneWithoutLabOrdersInput = {
    create?: XOR<LabTestCreateWithoutLabOrdersInput, LabTestUncheckedCreateWithoutLabOrdersInput>
    connectOrCreate?: LabTestCreateOrConnectWithoutLabOrdersInput
    connect?: LabTestWhereUniqueInput
  }

  export type LabOrderCreateNestedOneWithoutTestsInput = {
    create?: XOR<LabOrderCreateWithoutTestsInput, LabOrderUncheckedCreateWithoutTestsInput>
    connectOrCreate?: LabOrderCreateOrConnectWithoutTestsInput
    connect?: LabOrderWhereUniqueInput
  }

  export type EnumLabTestStatusFieldUpdateOperationsInput = {
    set?: $Enums.LabTestStatus
  }

  export type TenantUpdateOneRequiredWithoutLabOrderTestsNestedInput = {
    create?: XOR<TenantCreateWithoutLabOrderTestsInput, TenantUncheckedCreateWithoutLabOrderTestsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLabOrderTestsInput
    upsert?: TenantUpsertWithoutLabOrderTestsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutLabOrderTestsInput, TenantUpdateWithoutLabOrderTestsInput>, TenantUncheckedUpdateWithoutLabOrderTestsInput>
  }

  export type LabTestUpdateOneRequiredWithoutLabOrdersNestedInput = {
    create?: XOR<LabTestCreateWithoutLabOrdersInput, LabTestUncheckedCreateWithoutLabOrdersInput>
    connectOrCreate?: LabTestCreateOrConnectWithoutLabOrdersInput
    upsert?: LabTestUpsertWithoutLabOrdersInput
    connect?: LabTestWhereUniqueInput
    update?: XOR<XOR<LabTestUpdateToOneWithWhereWithoutLabOrdersInput, LabTestUpdateWithoutLabOrdersInput>, LabTestUncheckedUpdateWithoutLabOrdersInput>
  }

  export type LabOrderUpdateOneRequiredWithoutTestsNestedInput = {
    create?: XOR<LabOrderCreateWithoutTestsInput, LabOrderUncheckedCreateWithoutTestsInput>
    connectOrCreate?: LabOrderCreateOrConnectWithoutTestsInput
    upsert?: LabOrderUpsertWithoutTestsInput
    connect?: LabOrderWhereUniqueInput
    update?: XOR<XOR<LabOrderUpdateToOneWithWhereWithoutTestsInput, LabOrderUpdateWithoutTestsInput>, LabOrderUncheckedUpdateWithoutTestsInput>
  }

  export type TenantCreateNestedOneWithoutMedicationsInput = {
    create?: XOR<TenantCreateWithoutMedicationsInput, TenantUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMedicationsInput
    connect?: TenantWhereUniqueInput
  }

  export type PharmacyOrderItemCreateNestedManyWithoutMedicationInput = {
    create?: XOR<PharmacyOrderItemCreateWithoutMedicationInput, PharmacyOrderItemUncheckedCreateWithoutMedicationInput> | PharmacyOrderItemCreateWithoutMedicationInput[] | PharmacyOrderItemUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: PharmacyOrderItemCreateOrConnectWithoutMedicationInput | PharmacyOrderItemCreateOrConnectWithoutMedicationInput[]
    createMany?: PharmacyOrderItemCreateManyMedicationInputEnvelope
    connect?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
  }

  export type PrescriptionItemCreateNestedManyWithoutMedicationInput = {
    create?: XOR<PrescriptionItemCreateWithoutMedicationInput, PrescriptionItemUncheckedCreateWithoutMedicationInput> | PrescriptionItemCreateWithoutMedicationInput[] | PrescriptionItemUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutMedicationInput | PrescriptionItemCreateOrConnectWithoutMedicationInput[]
    createMany?: PrescriptionItemCreateManyMedicationInputEnvelope
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
  }

  export type PharmacyOrderItemUncheckedCreateNestedManyWithoutMedicationInput = {
    create?: XOR<PharmacyOrderItemCreateWithoutMedicationInput, PharmacyOrderItemUncheckedCreateWithoutMedicationInput> | PharmacyOrderItemCreateWithoutMedicationInput[] | PharmacyOrderItemUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: PharmacyOrderItemCreateOrConnectWithoutMedicationInput | PharmacyOrderItemCreateOrConnectWithoutMedicationInput[]
    createMany?: PharmacyOrderItemCreateManyMedicationInputEnvelope
    connect?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
  }

  export type PrescriptionItemUncheckedCreateNestedManyWithoutMedicationInput = {
    create?: XOR<PrescriptionItemCreateWithoutMedicationInput, PrescriptionItemUncheckedCreateWithoutMedicationInput> | PrescriptionItemCreateWithoutMedicationInput[] | PrescriptionItemUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutMedicationInput | PrescriptionItemCreateOrConnectWithoutMedicationInput[]
    createMany?: PrescriptionItemCreateManyMedicationInputEnvelope
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutMedicationsNestedInput = {
    create?: XOR<TenantCreateWithoutMedicationsInput, TenantUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMedicationsInput
    upsert?: TenantUpsertWithoutMedicationsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutMedicationsInput, TenantUpdateWithoutMedicationsInput>, TenantUncheckedUpdateWithoutMedicationsInput>
  }

  export type PharmacyOrderItemUpdateManyWithoutMedicationNestedInput = {
    create?: XOR<PharmacyOrderItemCreateWithoutMedicationInput, PharmacyOrderItemUncheckedCreateWithoutMedicationInput> | PharmacyOrderItemCreateWithoutMedicationInput[] | PharmacyOrderItemUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: PharmacyOrderItemCreateOrConnectWithoutMedicationInput | PharmacyOrderItemCreateOrConnectWithoutMedicationInput[]
    upsert?: PharmacyOrderItemUpsertWithWhereUniqueWithoutMedicationInput | PharmacyOrderItemUpsertWithWhereUniqueWithoutMedicationInput[]
    createMany?: PharmacyOrderItemCreateManyMedicationInputEnvelope
    set?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    disconnect?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    delete?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    connect?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    update?: PharmacyOrderItemUpdateWithWhereUniqueWithoutMedicationInput | PharmacyOrderItemUpdateWithWhereUniqueWithoutMedicationInput[]
    updateMany?: PharmacyOrderItemUpdateManyWithWhereWithoutMedicationInput | PharmacyOrderItemUpdateManyWithWhereWithoutMedicationInput[]
    deleteMany?: PharmacyOrderItemScalarWhereInput | PharmacyOrderItemScalarWhereInput[]
  }

  export type PrescriptionItemUpdateManyWithoutMedicationNestedInput = {
    create?: XOR<PrescriptionItemCreateWithoutMedicationInput, PrescriptionItemUncheckedCreateWithoutMedicationInput> | PrescriptionItemCreateWithoutMedicationInput[] | PrescriptionItemUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutMedicationInput | PrescriptionItemCreateOrConnectWithoutMedicationInput[]
    upsert?: PrescriptionItemUpsertWithWhereUniqueWithoutMedicationInput | PrescriptionItemUpsertWithWhereUniqueWithoutMedicationInput[]
    createMany?: PrescriptionItemCreateManyMedicationInputEnvelope
    set?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    disconnect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    delete?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    update?: PrescriptionItemUpdateWithWhereUniqueWithoutMedicationInput | PrescriptionItemUpdateWithWhereUniqueWithoutMedicationInput[]
    updateMany?: PrescriptionItemUpdateManyWithWhereWithoutMedicationInput | PrescriptionItemUpdateManyWithWhereWithoutMedicationInput[]
    deleteMany?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
  }

  export type PharmacyOrderItemUncheckedUpdateManyWithoutMedicationNestedInput = {
    create?: XOR<PharmacyOrderItemCreateWithoutMedicationInput, PharmacyOrderItemUncheckedCreateWithoutMedicationInput> | PharmacyOrderItemCreateWithoutMedicationInput[] | PharmacyOrderItemUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: PharmacyOrderItemCreateOrConnectWithoutMedicationInput | PharmacyOrderItemCreateOrConnectWithoutMedicationInput[]
    upsert?: PharmacyOrderItemUpsertWithWhereUniqueWithoutMedicationInput | PharmacyOrderItemUpsertWithWhereUniqueWithoutMedicationInput[]
    createMany?: PharmacyOrderItemCreateManyMedicationInputEnvelope
    set?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    disconnect?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    delete?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    connect?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    update?: PharmacyOrderItemUpdateWithWhereUniqueWithoutMedicationInput | PharmacyOrderItemUpdateWithWhereUniqueWithoutMedicationInput[]
    updateMany?: PharmacyOrderItemUpdateManyWithWhereWithoutMedicationInput | PharmacyOrderItemUpdateManyWithWhereWithoutMedicationInput[]
    deleteMany?: PharmacyOrderItemScalarWhereInput | PharmacyOrderItemScalarWhereInput[]
  }

  export type PrescriptionItemUncheckedUpdateManyWithoutMedicationNestedInput = {
    create?: XOR<PrescriptionItemCreateWithoutMedicationInput, PrescriptionItemUncheckedCreateWithoutMedicationInput> | PrescriptionItemCreateWithoutMedicationInput[] | PrescriptionItemUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutMedicationInput | PrescriptionItemCreateOrConnectWithoutMedicationInput[]
    upsert?: PrescriptionItemUpsertWithWhereUniqueWithoutMedicationInput | PrescriptionItemUpsertWithWhereUniqueWithoutMedicationInput[]
    createMany?: PrescriptionItemCreateManyMedicationInputEnvelope
    set?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    disconnect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    delete?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    update?: PrescriptionItemUpdateWithWhereUniqueWithoutMedicationInput | PrescriptionItemUpdateWithWhereUniqueWithoutMedicationInput[]
    updateMany?: PrescriptionItemUpdateManyWithWhereWithoutMedicationInput | PrescriptionItemUpdateManyWithWhereWithoutMedicationInput[]
    deleteMany?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutPharmacyOrdersInput = {
    create?: XOR<TenantCreateWithoutPharmacyOrdersInput, TenantUncheckedCreateWithoutPharmacyOrdersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPharmacyOrdersInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDoctorPrescriptionsInput = {
    create?: XOR<UserCreateWithoutDoctorPrescriptionsInput, UserUncheckedCreateWithoutDoctorPrescriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorPrescriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutPharmacyOrdersInput = {
    create?: XOR<PatientCreateWithoutPharmacyOrdersInput, PatientUncheckedCreateWithoutPharmacyOrdersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPharmacyOrdersInput
    connect?: PatientWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutPharmacyOrderInput = {
    create?: XOR<InvoiceCreateWithoutPharmacyOrderInput, InvoiceUncheckedCreateWithoutPharmacyOrderInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPharmacyOrderInput
    connect?: InvoiceWhereUniqueInput
  }

  export type PharmacyOrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<PharmacyOrderItemCreateWithoutOrderInput, PharmacyOrderItemUncheckedCreateWithoutOrderInput> | PharmacyOrderItemCreateWithoutOrderInput[] | PharmacyOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PharmacyOrderItemCreateOrConnectWithoutOrderInput | PharmacyOrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: PharmacyOrderItemCreateManyOrderInputEnvelope
    connect?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
  }

  export type PharmacyOrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PharmacyOrderItemCreateWithoutOrderInput, PharmacyOrderItemUncheckedCreateWithoutOrderInput> | PharmacyOrderItemCreateWithoutOrderInput[] | PharmacyOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PharmacyOrderItemCreateOrConnectWithoutOrderInput | PharmacyOrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: PharmacyOrderItemCreateManyOrderInputEnvelope
    connect?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
  }

  export type EnumPharmacyOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.PharmacyOrderStatus
  }

  export type TenantUpdateOneRequiredWithoutPharmacyOrdersNestedInput = {
    create?: XOR<TenantCreateWithoutPharmacyOrdersInput, TenantUncheckedCreateWithoutPharmacyOrdersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPharmacyOrdersInput
    upsert?: TenantUpsertWithoutPharmacyOrdersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPharmacyOrdersInput, TenantUpdateWithoutPharmacyOrdersInput>, TenantUncheckedUpdateWithoutPharmacyOrdersInput>
  }

  export type UserUpdateOneWithoutDoctorPrescriptionsNestedInput = {
    create?: XOR<UserCreateWithoutDoctorPrescriptionsInput, UserUncheckedCreateWithoutDoctorPrescriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorPrescriptionsInput
    upsert?: UserUpsertWithoutDoctorPrescriptionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDoctorPrescriptionsInput, UserUpdateWithoutDoctorPrescriptionsInput>, UserUncheckedUpdateWithoutDoctorPrescriptionsInput>
  }

  export type PatientUpdateOneRequiredWithoutPharmacyOrdersNestedInput = {
    create?: XOR<PatientCreateWithoutPharmacyOrdersInput, PatientUncheckedCreateWithoutPharmacyOrdersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPharmacyOrdersInput
    upsert?: PatientUpsertWithoutPharmacyOrdersInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPharmacyOrdersInput, PatientUpdateWithoutPharmacyOrdersInput>, PatientUncheckedUpdateWithoutPharmacyOrdersInput>
  }

  export type InvoiceUpdateOneWithoutPharmacyOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutPharmacyOrderInput, InvoiceUncheckedCreateWithoutPharmacyOrderInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPharmacyOrderInput
    upsert?: InvoiceUpsertWithoutPharmacyOrderInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPharmacyOrderInput, InvoiceUpdateWithoutPharmacyOrderInput>, InvoiceUncheckedUpdateWithoutPharmacyOrderInput>
  }

  export type PharmacyOrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PharmacyOrderItemCreateWithoutOrderInput, PharmacyOrderItemUncheckedCreateWithoutOrderInput> | PharmacyOrderItemCreateWithoutOrderInput[] | PharmacyOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PharmacyOrderItemCreateOrConnectWithoutOrderInput | PharmacyOrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: PharmacyOrderItemUpsertWithWhereUniqueWithoutOrderInput | PharmacyOrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PharmacyOrderItemCreateManyOrderInputEnvelope
    set?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    disconnect?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    delete?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    connect?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    update?: PharmacyOrderItemUpdateWithWhereUniqueWithoutOrderInput | PharmacyOrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PharmacyOrderItemUpdateManyWithWhereWithoutOrderInput | PharmacyOrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PharmacyOrderItemScalarWhereInput | PharmacyOrderItemScalarWhereInput[]
  }

  export type PharmacyOrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PharmacyOrderItemCreateWithoutOrderInput, PharmacyOrderItemUncheckedCreateWithoutOrderInput> | PharmacyOrderItemCreateWithoutOrderInput[] | PharmacyOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PharmacyOrderItemCreateOrConnectWithoutOrderInput | PharmacyOrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: PharmacyOrderItemUpsertWithWhereUniqueWithoutOrderInput | PharmacyOrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PharmacyOrderItemCreateManyOrderInputEnvelope
    set?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    disconnect?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    delete?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    connect?: PharmacyOrderItemWhereUniqueInput | PharmacyOrderItemWhereUniqueInput[]
    update?: PharmacyOrderItemUpdateWithWhereUniqueWithoutOrderInput | PharmacyOrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PharmacyOrderItemUpdateManyWithWhereWithoutOrderInput | PharmacyOrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PharmacyOrderItemScalarWhereInput | PharmacyOrderItemScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutPharmacyOrderItemsInput = {
    create?: XOR<TenantCreateWithoutPharmacyOrderItemsInput, TenantUncheckedCreateWithoutPharmacyOrderItemsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPharmacyOrderItemsInput
    connect?: TenantWhereUniqueInput
  }

  export type MedicationCreateNestedOneWithoutPharmacyOrderItemsInput = {
    create?: XOR<MedicationCreateWithoutPharmacyOrderItemsInput, MedicationUncheckedCreateWithoutPharmacyOrderItemsInput>
    connectOrCreate?: MedicationCreateOrConnectWithoutPharmacyOrderItemsInput
    connect?: MedicationWhereUniqueInput
  }

  export type PharmacyOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<PharmacyOrderCreateWithoutItemsInput, PharmacyOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PharmacyOrderCreateOrConnectWithoutItemsInput
    connect?: PharmacyOrderWhereUniqueInput
  }

  export type EnumPharmacyItemStatusFieldUpdateOperationsInput = {
    set?: $Enums.PharmacyItemStatus
  }

  export type TenantUpdateOneRequiredWithoutPharmacyOrderItemsNestedInput = {
    create?: XOR<TenantCreateWithoutPharmacyOrderItemsInput, TenantUncheckedCreateWithoutPharmacyOrderItemsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPharmacyOrderItemsInput
    upsert?: TenantUpsertWithoutPharmacyOrderItemsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPharmacyOrderItemsInput, TenantUpdateWithoutPharmacyOrderItemsInput>, TenantUncheckedUpdateWithoutPharmacyOrderItemsInput>
  }

  export type MedicationUpdateOneRequiredWithoutPharmacyOrderItemsNestedInput = {
    create?: XOR<MedicationCreateWithoutPharmacyOrderItemsInput, MedicationUncheckedCreateWithoutPharmacyOrderItemsInput>
    connectOrCreate?: MedicationCreateOrConnectWithoutPharmacyOrderItemsInput
    upsert?: MedicationUpsertWithoutPharmacyOrderItemsInput
    connect?: MedicationWhereUniqueInput
    update?: XOR<XOR<MedicationUpdateToOneWithWhereWithoutPharmacyOrderItemsInput, MedicationUpdateWithoutPharmacyOrderItemsInput>, MedicationUncheckedUpdateWithoutPharmacyOrderItemsInput>
  }

  export type PharmacyOrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PharmacyOrderCreateWithoutItemsInput, PharmacyOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PharmacyOrderCreateOrConnectWithoutItemsInput
    upsert?: PharmacyOrderUpsertWithoutItemsInput
    connect?: PharmacyOrderWhereUniqueInput
    update?: XOR<XOR<PharmacyOrderUpdateToOneWithWhereWithoutItemsInput, PharmacyOrderUpdateWithoutItemsInput>, PharmacyOrderUncheckedUpdateWithoutItemsInput>
  }

  export type TenantCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    upsert?: TenantUpsertWithoutAuditLogsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAuditLogsInput, TenantUpdateWithoutAuditLogsInput>, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type StudyCreateNestedManyWithoutModalityInput = {
    create?: XOR<StudyCreateWithoutModalityInput, StudyUncheckedCreateWithoutModalityInput> | StudyCreateWithoutModalityInput[] | StudyUncheckedCreateWithoutModalityInput[]
    connectOrCreate?: StudyCreateOrConnectWithoutModalityInput | StudyCreateOrConnectWithoutModalityInput[]
    createMany?: StudyCreateManyModalityInputEnvelope
    connect?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
  }

  export type RadiologyOrderCreateNestedManyWithoutModalityInput = {
    create?: XOR<RadiologyOrderCreateWithoutModalityInput, RadiologyOrderUncheckedCreateWithoutModalityInput> | RadiologyOrderCreateWithoutModalityInput[] | RadiologyOrderUncheckedCreateWithoutModalityInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutModalityInput | RadiologyOrderCreateOrConnectWithoutModalityInput[]
    createMany?: RadiologyOrderCreateManyModalityInputEnvelope
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
  }

  export type StudyUncheckedCreateNestedManyWithoutModalityInput = {
    create?: XOR<StudyCreateWithoutModalityInput, StudyUncheckedCreateWithoutModalityInput> | StudyCreateWithoutModalityInput[] | StudyUncheckedCreateWithoutModalityInput[]
    connectOrCreate?: StudyCreateOrConnectWithoutModalityInput | StudyCreateOrConnectWithoutModalityInput[]
    createMany?: StudyCreateManyModalityInputEnvelope
    connect?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
  }

  export type RadiologyOrderUncheckedCreateNestedManyWithoutModalityInput = {
    create?: XOR<RadiologyOrderCreateWithoutModalityInput, RadiologyOrderUncheckedCreateWithoutModalityInput> | RadiologyOrderCreateWithoutModalityInput[] | RadiologyOrderUncheckedCreateWithoutModalityInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutModalityInput | RadiologyOrderCreateOrConnectWithoutModalityInput[]
    createMany?: RadiologyOrderCreateManyModalityInputEnvelope
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
  }

  export type StudyUpdateManyWithoutModalityNestedInput = {
    create?: XOR<StudyCreateWithoutModalityInput, StudyUncheckedCreateWithoutModalityInput> | StudyCreateWithoutModalityInput[] | StudyUncheckedCreateWithoutModalityInput[]
    connectOrCreate?: StudyCreateOrConnectWithoutModalityInput | StudyCreateOrConnectWithoutModalityInput[]
    upsert?: StudyUpsertWithWhereUniqueWithoutModalityInput | StudyUpsertWithWhereUniqueWithoutModalityInput[]
    createMany?: StudyCreateManyModalityInputEnvelope
    set?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    disconnect?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    delete?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    connect?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    update?: StudyUpdateWithWhereUniqueWithoutModalityInput | StudyUpdateWithWhereUniqueWithoutModalityInput[]
    updateMany?: StudyUpdateManyWithWhereWithoutModalityInput | StudyUpdateManyWithWhereWithoutModalityInput[]
    deleteMany?: StudyScalarWhereInput | StudyScalarWhereInput[]
  }

  export type RadiologyOrderUpdateManyWithoutModalityNestedInput = {
    create?: XOR<RadiologyOrderCreateWithoutModalityInput, RadiologyOrderUncheckedCreateWithoutModalityInput> | RadiologyOrderCreateWithoutModalityInput[] | RadiologyOrderUncheckedCreateWithoutModalityInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutModalityInput | RadiologyOrderCreateOrConnectWithoutModalityInput[]
    upsert?: RadiologyOrderUpsertWithWhereUniqueWithoutModalityInput | RadiologyOrderUpsertWithWhereUniqueWithoutModalityInput[]
    createMany?: RadiologyOrderCreateManyModalityInputEnvelope
    set?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    disconnect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    delete?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    update?: RadiologyOrderUpdateWithWhereUniqueWithoutModalityInput | RadiologyOrderUpdateWithWhereUniqueWithoutModalityInput[]
    updateMany?: RadiologyOrderUpdateManyWithWhereWithoutModalityInput | RadiologyOrderUpdateManyWithWhereWithoutModalityInput[]
    deleteMany?: RadiologyOrderScalarWhereInput | RadiologyOrderScalarWhereInput[]
  }

  export type StudyUncheckedUpdateManyWithoutModalityNestedInput = {
    create?: XOR<StudyCreateWithoutModalityInput, StudyUncheckedCreateWithoutModalityInput> | StudyCreateWithoutModalityInput[] | StudyUncheckedCreateWithoutModalityInput[]
    connectOrCreate?: StudyCreateOrConnectWithoutModalityInput | StudyCreateOrConnectWithoutModalityInput[]
    upsert?: StudyUpsertWithWhereUniqueWithoutModalityInput | StudyUpsertWithWhereUniqueWithoutModalityInput[]
    createMany?: StudyCreateManyModalityInputEnvelope
    set?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    disconnect?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    delete?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    connect?: StudyWhereUniqueInput | StudyWhereUniqueInput[]
    update?: StudyUpdateWithWhereUniqueWithoutModalityInput | StudyUpdateWithWhereUniqueWithoutModalityInput[]
    updateMany?: StudyUpdateManyWithWhereWithoutModalityInput | StudyUpdateManyWithWhereWithoutModalityInput[]
    deleteMany?: StudyScalarWhereInput | StudyScalarWhereInput[]
  }

  export type RadiologyOrderUncheckedUpdateManyWithoutModalityNestedInput = {
    create?: XOR<RadiologyOrderCreateWithoutModalityInput, RadiologyOrderUncheckedCreateWithoutModalityInput> | RadiologyOrderCreateWithoutModalityInput[] | RadiologyOrderUncheckedCreateWithoutModalityInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutModalityInput | RadiologyOrderCreateOrConnectWithoutModalityInput[]
    upsert?: RadiologyOrderUpsertWithWhereUniqueWithoutModalityInput | RadiologyOrderUpsertWithWhereUniqueWithoutModalityInput[]
    createMany?: RadiologyOrderCreateManyModalityInputEnvelope
    set?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    disconnect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    delete?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    update?: RadiologyOrderUpdateWithWhereUniqueWithoutModalityInput | RadiologyOrderUpdateWithWhereUniqueWithoutModalityInput[]
    updateMany?: RadiologyOrderUpdateManyWithWhereWithoutModalityInput | RadiologyOrderUpdateManyWithWhereWithoutModalityInput[]
    deleteMany?: RadiologyOrderScalarWhereInput | RadiologyOrderScalarWhereInput[]
  }

  export type ModalityCreateNestedOneWithoutStudiesInput = {
    create?: XOR<ModalityCreateWithoutStudiesInput, ModalityUncheckedCreateWithoutStudiesInput>
    connectOrCreate?: ModalityCreateOrConnectWithoutStudiesInput
    connect?: ModalityWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutStudiesInput = {
    create?: XOR<PatientCreateWithoutStudiesInput, PatientUncheckedCreateWithoutStudiesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutStudiesInput
    connect?: PatientWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutStudiesInput = {
    create?: XOR<TenantCreateWithoutStudiesInput, TenantUncheckedCreateWithoutStudiesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutStudiesInput
    connect?: TenantWhereUniqueInput
  }

  export type SeriesCreateNestedManyWithoutStudyInput = {
    create?: XOR<SeriesCreateWithoutStudyInput, SeriesUncheckedCreateWithoutStudyInput> | SeriesCreateWithoutStudyInput[] | SeriesUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutStudyInput | SeriesCreateOrConnectWithoutStudyInput[]
    createMany?: SeriesCreateManyStudyInputEnvelope
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
  }

  export type RadReportCreateNestedManyWithoutStudyInput = {
    create?: XOR<RadReportCreateWithoutStudyInput, RadReportUncheckedCreateWithoutStudyInput> | RadReportCreateWithoutStudyInput[] | RadReportUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: RadReportCreateOrConnectWithoutStudyInput | RadReportCreateOrConnectWithoutStudyInput[]
    createMany?: RadReportCreateManyStudyInputEnvelope
    connect?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
  }

  export type RadiationDoseCreateNestedManyWithoutStudyInput = {
    create?: XOR<RadiationDoseCreateWithoutStudyInput, RadiationDoseUncheckedCreateWithoutStudyInput> | RadiationDoseCreateWithoutStudyInput[] | RadiationDoseUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: RadiationDoseCreateOrConnectWithoutStudyInput | RadiationDoseCreateOrConnectWithoutStudyInput[]
    createMany?: RadiationDoseCreateManyStudyInputEnvelope
    connect?: RadiationDoseWhereUniqueInput | RadiationDoseWhereUniqueInput[]
  }

  export type RadiologyOrderCreateNestedManyWithoutStudyInput = {
    create?: XOR<RadiologyOrderCreateWithoutStudyInput, RadiologyOrderUncheckedCreateWithoutStudyInput> | RadiologyOrderCreateWithoutStudyInput[] | RadiologyOrderUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutStudyInput | RadiologyOrderCreateOrConnectWithoutStudyInput[]
    createMany?: RadiologyOrderCreateManyStudyInputEnvelope
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
  }

  export type SeriesUncheckedCreateNestedManyWithoutStudyInput = {
    create?: XOR<SeriesCreateWithoutStudyInput, SeriesUncheckedCreateWithoutStudyInput> | SeriesCreateWithoutStudyInput[] | SeriesUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutStudyInput | SeriesCreateOrConnectWithoutStudyInput[]
    createMany?: SeriesCreateManyStudyInputEnvelope
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
  }

  export type RadReportUncheckedCreateNestedManyWithoutStudyInput = {
    create?: XOR<RadReportCreateWithoutStudyInput, RadReportUncheckedCreateWithoutStudyInput> | RadReportCreateWithoutStudyInput[] | RadReportUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: RadReportCreateOrConnectWithoutStudyInput | RadReportCreateOrConnectWithoutStudyInput[]
    createMany?: RadReportCreateManyStudyInputEnvelope
    connect?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
  }

  export type RadiationDoseUncheckedCreateNestedManyWithoutStudyInput = {
    create?: XOR<RadiationDoseCreateWithoutStudyInput, RadiationDoseUncheckedCreateWithoutStudyInput> | RadiationDoseCreateWithoutStudyInput[] | RadiationDoseUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: RadiationDoseCreateOrConnectWithoutStudyInput | RadiationDoseCreateOrConnectWithoutStudyInput[]
    createMany?: RadiationDoseCreateManyStudyInputEnvelope
    connect?: RadiationDoseWhereUniqueInput | RadiationDoseWhereUniqueInput[]
  }

  export type RadiologyOrderUncheckedCreateNestedManyWithoutStudyInput = {
    create?: XOR<RadiologyOrderCreateWithoutStudyInput, RadiologyOrderUncheckedCreateWithoutStudyInput> | RadiologyOrderCreateWithoutStudyInput[] | RadiologyOrderUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutStudyInput | RadiologyOrderCreateOrConnectWithoutStudyInput[]
    createMany?: RadiologyOrderCreateManyStudyInputEnvelope
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
  }

  export type EnumStudyStatusFieldUpdateOperationsInput = {
    set?: $Enums.StudyStatus
  }

  export type NullableEnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority | null
  }

  export type ModalityUpdateOneRequiredWithoutStudiesNestedInput = {
    create?: XOR<ModalityCreateWithoutStudiesInput, ModalityUncheckedCreateWithoutStudiesInput>
    connectOrCreate?: ModalityCreateOrConnectWithoutStudiesInput
    upsert?: ModalityUpsertWithoutStudiesInput
    connect?: ModalityWhereUniqueInput
    update?: XOR<XOR<ModalityUpdateToOneWithWhereWithoutStudiesInput, ModalityUpdateWithoutStudiesInput>, ModalityUncheckedUpdateWithoutStudiesInput>
  }

  export type PatientUpdateOneRequiredWithoutStudiesNestedInput = {
    create?: XOR<PatientCreateWithoutStudiesInput, PatientUncheckedCreateWithoutStudiesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutStudiesInput
    upsert?: PatientUpsertWithoutStudiesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutStudiesInput, PatientUpdateWithoutStudiesInput>, PatientUncheckedUpdateWithoutStudiesInput>
  }

  export type TenantUpdateOneRequiredWithoutStudiesNestedInput = {
    create?: XOR<TenantCreateWithoutStudiesInput, TenantUncheckedCreateWithoutStudiesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutStudiesInput
    upsert?: TenantUpsertWithoutStudiesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutStudiesInput, TenantUpdateWithoutStudiesInput>, TenantUncheckedUpdateWithoutStudiesInput>
  }

  export type SeriesUpdateManyWithoutStudyNestedInput = {
    create?: XOR<SeriesCreateWithoutStudyInput, SeriesUncheckedCreateWithoutStudyInput> | SeriesCreateWithoutStudyInput[] | SeriesUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutStudyInput | SeriesCreateOrConnectWithoutStudyInput[]
    upsert?: SeriesUpsertWithWhereUniqueWithoutStudyInput | SeriesUpsertWithWhereUniqueWithoutStudyInput[]
    createMany?: SeriesCreateManyStudyInputEnvelope
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    update?: SeriesUpdateWithWhereUniqueWithoutStudyInput | SeriesUpdateWithWhereUniqueWithoutStudyInput[]
    updateMany?: SeriesUpdateManyWithWhereWithoutStudyInput | SeriesUpdateManyWithWhereWithoutStudyInput[]
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
  }

  export type RadReportUpdateManyWithoutStudyNestedInput = {
    create?: XOR<RadReportCreateWithoutStudyInput, RadReportUncheckedCreateWithoutStudyInput> | RadReportCreateWithoutStudyInput[] | RadReportUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: RadReportCreateOrConnectWithoutStudyInput | RadReportCreateOrConnectWithoutStudyInput[]
    upsert?: RadReportUpsertWithWhereUniqueWithoutStudyInput | RadReportUpsertWithWhereUniqueWithoutStudyInput[]
    createMany?: RadReportCreateManyStudyInputEnvelope
    set?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    disconnect?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    delete?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    connect?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    update?: RadReportUpdateWithWhereUniqueWithoutStudyInput | RadReportUpdateWithWhereUniqueWithoutStudyInput[]
    updateMany?: RadReportUpdateManyWithWhereWithoutStudyInput | RadReportUpdateManyWithWhereWithoutStudyInput[]
    deleteMany?: RadReportScalarWhereInput | RadReportScalarWhereInput[]
  }

  export type RadiationDoseUpdateManyWithoutStudyNestedInput = {
    create?: XOR<RadiationDoseCreateWithoutStudyInput, RadiationDoseUncheckedCreateWithoutStudyInput> | RadiationDoseCreateWithoutStudyInput[] | RadiationDoseUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: RadiationDoseCreateOrConnectWithoutStudyInput | RadiationDoseCreateOrConnectWithoutStudyInput[]
    upsert?: RadiationDoseUpsertWithWhereUniqueWithoutStudyInput | RadiationDoseUpsertWithWhereUniqueWithoutStudyInput[]
    createMany?: RadiationDoseCreateManyStudyInputEnvelope
    set?: RadiationDoseWhereUniqueInput | RadiationDoseWhereUniqueInput[]
    disconnect?: RadiationDoseWhereUniqueInput | RadiationDoseWhereUniqueInput[]
    delete?: RadiationDoseWhereUniqueInput | RadiationDoseWhereUniqueInput[]
    connect?: RadiationDoseWhereUniqueInput | RadiationDoseWhereUniqueInput[]
    update?: RadiationDoseUpdateWithWhereUniqueWithoutStudyInput | RadiationDoseUpdateWithWhereUniqueWithoutStudyInput[]
    updateMany?: RadiationDoseUpdateManyWithWhereWithoutStudyInput | RadiationDoseUpdateManyWithWhereWithoutStudyInput[]
    deleteMany?: RadiationDoseScalarWhereInput | RadiationDoseScalarWhereInput[]
  }

  export type RadiologyOrderUpdateManyWithoutStudyNestedInput = {
    create?: XOR<RadiologyOrderCreateWithoutStudyInput, RadiologyOrderUncheckedCreateWithoutStudyInput> | RadiologyOrderCreateWithoutStudyInput[] | RadiologyOrderUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutStudyInput | RadiologyOrderCreateOrConnectWithoutStudyInput[]
    upsert?: RadiologyOrderUpsertWithWhereUniqueWithoutStudyInput | RadiologyOrderUpsertWithWhereUniqueWithoutStudyInput[]
    createMany?: RadiologyOrderCreateManyStudyInputEnvelope
    set?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    disconnect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    delete?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    update?: RadiologyOrderUpdateWithWhereUniqueWithoutStudyInput | RadiologyOrderUpdateWithWhereUniqueWithoutStudyInput[]
    updateMany?: RadiologyOrderUpdateManyWithWhereWithoutStudyInput | RadiologyOrderUpdateManyWithWhereWithoutStudyInput[]
    deleteMany?: RadiologyOrderScalarWhereInput | RadiologyOrderScalarWhereInput[]
  }

  export type SeriesUncheckedUpdateManyWithoutStudyNestedInput = {
    create?: XOR<SeriesCreateWithoutStudyInput, SeriesUncheckedCreateWithoutStudyInput> | SeriesCreateWithoutStudyInput[] | SeriesUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutStudyInput | SeriesCreateOrConnectWithoutStudyInput[]
    upsert?: SeriesUpsertWithWhereUniqueWithoutStudyInput | SeriesUpsertWithWhereUniqueWithoutStudyInput[]
    createMany?: SeriesCreateManyStudyInputEnvelope
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    update?: SeriesUpdateWithWhereUniqueWithoutStudyInput | SeriesUpdateWithWhereUniqueWithoutStudyInput[]
    updateMany?: SeriesUpdateManyWithWhereWithoutStudyInput | SeriesUpdateManyWithWhereWithoutStudyInput[]
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
  }

  export type RadReportUncheckedUpdateManyWithoutStudyNestedInput = {
    create?: XOR<RadReportCreateWithoutStudyInput, RadReportUncheckedCreateWithoutStudyInput> | RadReportCreateWithoutStudyInput[] | RadReportUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: RadReportCreateOrConnectWithoutStudyInput | RadReportCreateOrConnectWithoutStudyInput[]
    upsert?: RadReportUpsertWithWhereUniqueWithoutStudyInput | RadReportUpsertWithWhereUniqueWithoutStudyInput[]
    createMany?: RadReportCreateManyStudyInputEnvelope
    set?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    disconnect?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    delete?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    connect?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    update?: RadReportUpdateWithWhereUniqueWithoutStudyInput | RadReportUpdateWithWhereUniqueWithoutStudyInput[]
    updateMany?: RadReportUpdateManyWithWhereWithoutStudyInput | RadReportUpdateManyWithWhereWithoutStudyInput[]
    deleteMany?: RadReportScalarWhereInput | RadReportScalarWhereInput[]
  }

  export type RadiationDoseUncheckedUpdateManyWithoutStudyNestedInput = {
    create?: XOR<RadiationDoseCreateWithoutStudyInput, RadiationDoseUncheckedCreateWithoutStudyInput> | RadiationDoseCreateWithoutStudyInput[] | RadiationDoseUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: RadiationDoseCreateOrConnectWithoutStudyInput | RadiationDoseCreateOrConnectWithoutStudyInput[]
    upsert?: RadiationDoseUpsertWithWhereUniqueWithoutStudyInput | RadiationDoseUpsertWithWhereUniqueWithoutStudyInput[]
    createMany?: RadiationDoseCreateManyStudyInputEnvelope
    set?: RadiationDoseWhereUniqueInput | RadiationDoseWhereUniqueInput[]
    disconnect?: RadiationDoseWhereUniqueInput | RadiationDoseWhereUniqueInput[]
    delete?: RadiationDoseWhereUniqueInput | RadiationDoseWhereUniqueInput[]
    connect?: RadiationDoseWhereUniqueInput | RadiationDoseWhereUniqueInput[]
    update?: RadiationDoseUpdateWithWhereUniqueWithoutStudyInput | RadiationDoseUpdateWithWhereUniqueWithoutStudyInput[]
    updateMany?: RadiationDoseUpdateManyWithWhereWithoutStudyInput | RadiationDoseUpdateManyWithWhereWithoutStudyInput[]
    deleteMany?: RadiationDoseScalarWhereInput | RadiationDoseScalarWhereInput[]
  }

  export type RadiologyOrderUncheckedUpdateManyWithoutStudyNestedInput = {
    create?: XOR<RadiologyOrderCreateWithoutStudyInput, RadiologyOrderUncheckedCreateWithoutStudyInput> | RadiologyOrderCreateWithoutStudyInput[] | RadiologyOrderUncheckedCreateWithoutStudyInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutStudyInput | RadiologyOrderCreateOrConnectWithoutStudyInput[]
    upsert?: RadiologyOrderUpsertWithWhereUniqueWithoutStudyInput | RadiologyOrderUpsertWithWhereUniqueWithoutStudyInput[]
    createMany?: RadiologyOrderCreateManyStudyInputEnvelope
    set?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    disconnect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    delete?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    update?: RadiologyOrderUpdateWithWhereUniqueWithoutStudyInput | RadiologyOrderUpdateWithWhereUniqueWithoutStudyInput[]
    updateMany?: RadiologyOrderUpdateManyWithWhereWithoutStudyInput | RadiologyOrderUpdateManyWithWhereWithoutStudyInput[]
    deleteMany?: RadiologyOrderScalarWhereInput | RadiologyOrderScalarWhereInput[]
  }

  export type StudyCreateNestedOneWithoutSeriesInput = {
    create?: XOR<StudyCreateWithoutSeriesInput, StudyUncheckedCreateWithoutSeriesInput>
    connectOrCreate?: StudyCreateOrConnectWithoutSeriesInput
    connect?: StudyWhereUniqueInput
  }

  export type ImageCreateNestedManyWithoutSeriesInput = {
    create?: XOR<ImageCreateWithoutSeriesInput, ImageUncheckedCreateWithoutSeriesInput> | ImageCreateWithoutSeriesInput[] | ImageUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutSeriesInput | ImageCreateOrConnectWithoutSeriesInput[]
    createMany?: ImageCreateManySeriesInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type ImageUncheckedCreateNestedManyWithoutSeriesInput = {
    create?: XOR<ImageCreateWithoutSeriesInput, ImageUncheckedCreateWithoutSeriesInput> | ImageCreateWithoutSeriesInput[] | ImageUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutSeriesInput | ImageCreateOrConnectWithoutSeriesInput[]
    createMany?: ImageCreateManySeriesInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type StudyUpdateOneRequiredWithoutSeriesNestedInput = {
    create?: XOR<StudyCreateWithoutSeriesInput, StudyUncheckedCreateWithoutSeriesInput>
    connectOrCreate?: StudyCreateOrConnectWithoutSeriesInput
    upsert?: StudyUpsertWithoutSeriesInput
    connect?: StudyWhereUniqueInput
    update?: XOR<XOR<StudyUpdateToOneWithWhereWithoutSeriesInput, StudyUpdateWithoutSeriesInput>, StudyUncheckedUpdateWithoutSeriesInput>
  }

  export type ImageUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<ImageCreateWithoutSeriesInput, ImageUncheckedCreateWithoutSeriesInput> | ImageCreateWithoutSeriesInput[] | ImageUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutSeriesInput | ImageCreateOrConnectWithoutSeriesInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutSeriesInput | ImageUpsertWithWhereUniqueWithoutSeriesInput[]
    createMany?: ImageCreateManySeriesInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutSeriesInput | ImageUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutSeriesInput | ImageUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type ImageUncheckedUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<ImageCreateWithoutSeriesInput, ImageUncheckedCreateWithoutSeriesInput> | ImageCreateWithoutSeriesInput[] | ImageUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutSeriesInput | ImageCreateOrConnectWithoutSeriesInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutSeriesInput | ImageUpsertWithWhereUniqueWithoutSeriesInput[]
    createMany?: ImageCreateManySeriesInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutSeriesInput | ImageUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutSeriesInput | ImageUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type SeriesCreateNestedOneWithoutImagesInput = {
    create?: XOR<SeriesCreateWithoutImagesInput, SeriesUncheckedCreateWithoutImagesInput>
    connectOrCreate?: SeriesCreateOrConnectWithoutImagesInput
    connect?: SeriesWhereUniqueInput
  }

  export type SeriesUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<SeriesCreateWithoutImagesInput, SeriesUncheckedCreateWithoutImagesInput>
    connectOrCreate?: SeriesCreateOrConnectWithoutImagesInput
    upsert?: SeriesUpsertWithoutImagesInput
    connect?: SeriesWhereUniqueInput
    update?: XOR<XOR<SeriesUpdateToOneWithWhereWithoutImagesInput, SeriesUpdateWithoutImagesInput>, SeriesUncheckedUpdateWithoutImagesInput>
  }

  export type StudyCreateNestedOneWithoutRadReportsInput = {
    create?: XOR<StudyCreateWithoutRadReportsInput, StudyUncheckedCreateWithoutRadReportsInput>
    connectOrCreate?: StudyCreateOrConnectWithoutRadReportsInput
    connect?: StudyWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutRadReportsInput = {
    create?: XOR<TenantCreateWithoutRadReportsInput, TenantUncheckedCreateWithoutRadReportsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRadReportsInput
    connect?: TenantWhereUniqueInput
  }

  export type ReportTemplateCreateNestedOneWithoutRadReportsInput = {
    create?: XOR<ReportTemplateCreateWithoutRadReportsInput, ReportTemplateUncheckedCreateWithoutRadReportsInput>
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutRadReportsInput
    connect?: ReportTemplateWhereUniqueInput
  }

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus
  }

  export type StudyUpdateOneRequiredWithoutRadReportsNestedInput = {
    create?: XOR<StudyCreateWithoutRadReportsInput, StudyUncheckedCreateWithoutRadReportsInput>
    connectOrCreate?: StudyCreateOrConnectWithoutRadReportsInput
    upsert?: StudyUpsertWithoutRadReportsInput
    connect?: StudyWhereUniqueInput
    update?: XOR<XOR<StudyUpdateToOneWithWhereWithoutRadReportsInput, StudyUpdateWithoutRadReportsInput>, StudyUncheckedUpdateWithoutRadReportsInput>
  }

  export type TenantUpdateOneRequiredWithoutRadReportsNestedInput = {
    create?: XOR<TenantCreateWithoutRadReportsInput, TenantUncheckedCreateWithoutRadReportsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRadReportsInput
    upsert?: TenantUpsertWithoutRadReportsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutRadReportsInput, TenantUpdateWithoutRadReportsInput>, TenantUncheckedUpdateWithoutRadReportsInput>
  }

  export type ReportTemplateUpdateOneWithoutRadReportsNestedInput = {
    create?: XOR<ReportTemplateCreateWithoutRadReportsInput, ReportTemplateUncheckedCreateWithoutRadReportsInput>
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutRadReportsInput
    upsert?: ReportTemplateUpsertWithoutRadReportsInput
    disconnect?: ReportTemplateWhereInput | boolean
    delete?: ReportTemplateWhereInput | boolean
    connect?: ReportTemplateWhereUniqueInput
    update?: XOR<XOR<ReportTemplateUpdateToOneWithWhereWithoutRadReportsInput, ReportTemplateUpdateWithoutRadReportsInput>, ReportTemplateUncheckedUpdateWithoutRadReportsInput>
  }

  export type StudyCreateNestedOneWithoutRadiationDosesInput = {
    create?: XOR<StudyCreateWithoutRadiationDosesInput, StudyUncheckedCreateWithoutRadiationDosesInput>
    connectOrCreate?: StudyCreateOrConnectWithoutRadiationDosesInput
    connect?: StudyWhereUniqueInput
  }

  export type StudyUpdateOneRequiredWithoutRadiationDosesNestedInput = {
    create?: XOR<StudyCreateWithoutRadiationDosesInput, StudyUncheckedCreateWithoutRadiationDosesInput>
    connectOrCreate?: StudyCreateOrConnectWithoutRadiationDosesInput
    upsert?: StudyUpsertWithoutRadiationDosesInput
    connect?: StudyWhereUniqueInput
    update?: XOR<XOR<StudyUpdateToOneWithWhereWithoutRadiationDosesInput, StudyUpdateWithoutRadiationDosesInput>, StudyUncheckedUpdateWithoutRadiationDosesInput>
  }

  export type TenantCreateNestedOneWithoutReportTemplatesInput = {
    create?: XOR<TenantCreateWithoutReportTemplatesInput, TenantUncheckedCreateWithoutReportTemplatesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutReportTemplatesInput
    connect?: TenantWhereUniqueInput
  }

  export type RadReportCreateNestedManyWithoutReportTemplateInput = {
    create?: XOR<RadReportCreateWithoutReportTemplateInput, RadReportUncheckedCreateWithoutReportTemplateInput> | RadReportCreateWithoutReportTemplateInput[] | RadReportUncheckedCreateWithoutReportTemplateInput[]
    connectOrCreate?: RadReportCreateOrConnectWithoutReportTemplateInput | RadReportCreateOrConnectWithoutReportTemplateInput[]
    createMany?: RadReportCreateManyReportTemplateInputEnvelope
    connect?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
  }

  export type RadReportUncheckedCreateNestedManyWithoutReportTemplateInput = {
    create?: XOR<RadReportCreateWithoutReportTemplateInput, RadReportUncheckedCreateWithoutReportTemplateInput> | RadReportCreateWithoutReportTemplateInput[] | RadReportUncheckedCreateWithoutReportTemplateInput[]
    connectOrCreate?: RadReportCreateOrConnectWithoutReportTemplateInput | RadReportCreateOrConnectWithoutReportTemplateInput[]
    createMany?: RadReportCreateManyReportTemplateInputEnvelope
    connect?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutReportTemplatesNestedInput = {
    create?: XOR<TenantCreateWithoutReportTemplatesInput, TenantUncheckedCreateWithoutReportTemplatesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutReportTemplatesInput
    upsert?: TenantUpsertWithoutReportTemplatesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutReportTemplatesInput, TenantUpdateWithoutReportTemplatesInput>, TenantUncheckedUpdateWithoutReportTemplatesInput>
  }

  export type RadReportUpdateManyWithoutReportTemplateNestedInput = {
    create?: XOR<RadReportCreateWithoutReportTemplateInput, RadReportUncheckedCreateWithoutReportTemplateInput> | RadReportCreateWithoutReportTemplateInput[] | RadReportUncheckedCreateWithoutReportTemplateInput[]
    connectOrCreate?: RadReportCreateOrConnectWithoutReportTemplateInput | RadReportCreateOrConnectWithoutReportTemplateInput[]
    upsert?: RadReportUpsertWithWhereUniqueWithoutReportTemplateInput | RadReportUpsertWithWhereUniqueWithoutReportTemplateInput[]
    createMany?: RadReportCreateManyReportTemplateInputEnvelope
    set?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    disconnect?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    delete?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    connect?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    update?: RadReportUpdateWithWhereUniqueWithoutReportTemplateInput | RadReportUpdateWithWhereUniqueWithoutReportTemplateInput[]
    updateMany?: RadReportUpdateManyWithWhereWithoutReportTemplateInput | RadReportUpdateManyWithWhereWithoutReportTemplateInput[]
    deleteMany?: RadReportScalarWhereInput | RadReportScalarWhereInput[]
  }

  export type RadReportUncheckedUpdateManyWithoutReportTemplateNestedInput = {
    create?: XOR<RadReportCreateWithoutReportTemplateInput, RadReportUncheckedCreateWithoutReportTemplateInput> | RadReportCreateWithoutReportTemplateInput[] | RadReportUncheckedCreateWithoutReportTemplateInput[]
    connectOrCreate?: RadReportCreateOrConnectWithoutReportTemplateInput | RadReportCreateOrConnectWithoutReportTemplateInput[]
    upsert?: RadReportUpsertWithWhereUniqueWithoutReportTemplateInput | RadReportUpsertWithWhereUniqueWithoutReportTemplateInput[]
    createMany?: RadReportCreateManyReportTemplateInputEnvelope
    set?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    disconnect?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    delete?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    connect?: RadReportWhereUniqueInput | RadReportWhereUniqueInput[]
    update?: RadReportUpdateWithWhereUniqueWithoutReportTemplateInput | RadReportUpdateWithWhereUniqueWithoutReportTemplateInput[]
    updateMany?: RadReportUpdateManyWithWhereWithoutReportTemplateInput | RadReportUpdateManyWithWhereWithoutReportTemplateInput[]
    deleteMany?: RadReportScalarWhereInput | RadReportScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutTelemedicineConsultationsInput = {
    create?: XOR<PatientCreateWithoutTelemedicineConsultationsInput, PatientUncheckedCreateWithoutTelemedicineConsultationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutTelemedicineConsultationsInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDoctorTelemedicineInput = {
    create?: XOR<UserCreateWithoutDoctorTelemedicineInput, UserUncheckedCreateWithoutDoctorTelemedicineInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorTelemedicineInput
    connect?: UserWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutTelemedicineConsultationsInput = {
    create?: XOR<TenantCreateWithoutTelemedicineConsultationsInput, TenantUncheckedCreateWithoutTelemedicineConsultationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTelemedicineConsultationsInput
    connect?: TenantWhereUniqueInput
  }

  export type VideoRoomCreateNestedOneWithoutConsultationInput = {
    create?: XOR<VideoRoomCreateWithoutConsultationInput, VideoRoomUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: VideoRoomCreateOrConnectWithoutConsultationInput
    connect?: VideoRoomWhereUniqueInput
  }

  export type LabOrderCreateNestedManyWithoutConsultationInput = {
    create?: XOR<LabOrderCreateWithoutConsultationInput, LabOrderUncheckedCreateWithoutConsultationInput> | LabOrderCreateWithoutConsultationInput[] | LabOrderUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutConsultationInput | LabOrderCreateOrConnectWithoutConsultationInput[]
    createMany?: LabOrderCreateManyConsultationInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type RadiologyOrderCreateNestedManyWithoutConsultationInput = {
    create?: XOR<RadiologyOrderCreateWithoutConsultationInput, RadiologyOrderUncheckedCreateWithoutConsultationInput> | RadiologyOrderCreateWithoutConsultationInput[] | RadiologyOrderUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutConsultationInput | RadiologyOrderCreateOrConnectWithoutConsultationInput[]
    createMany?: RadiologyOrderCreateManyConsultationInputEnvelope
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
  }

  export type VideoRoomUncheckedCreateNestedOneWithoutConsultationInput = {
    create?: XOR<VideoRoomCreateWithoutConsultationInput, VideoRoomUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: VideoRoomCreateOrConnectWithoutConsultationInput
    connect?: VideoRoomWhereUniqueInput
  }

  export type LabOrderUncheckedCreateNestedManyWithoutConsultationInput = {
    create?: XOR<LabOrderCreateWithoutConsultationInput, LabOrderUncheckedCreateWithoutConsultationInput> | LabOrderCreateWithoutConsultationInput[] | LabOrderUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutConsultationInput | LabOrderCreateOrConnectWithoutConsultationInput[]
    createMany?: LabOrderCreateManyConsultationInputEnvelope
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
  }

  export type RadiologyOrderUncheckedCreateNestedManyWithoutConsultationInput = {
    create?: XOR<RadiologyOrderCreateWithoutConsultationInput, RadiologyOrderUncheckedCreateWithoutConsultationInput> | RadiologyOrderCreateWithoutConsultationInput[] | RadiologyOrderUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutConsultationInput | RadiologyOrderCreateOrConnectWithoutConsultationInput[]
    createMany?: RadiologyOrderCreateManyConsultationInputEnvelope
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
  }

  export type EnumTelemedicineStatusFieldUpdateOperationsInput = {
    set?: $Enums.TelemedicineStatus
  }

  export type EnumConsultationTypeFieldUpdateOperationsInput = {
    set?: $Enums.ConsultationType
  }

  export type PatientUpdateOneRequiredWithoutTelemedicineConsultationsNestedInput = {
    create?: XOR<PatientCreateWithoutTelemedicineConsultationsInput, PatientUncheckedCreateWithoutTelemedicineConsultationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutTelemedicineConsultationsInput
    upsert?: PatientUpsertWithoutTelemedicineConsultationsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutTelemedicineConsultationsInput, PatientUpdateWithoutTelemedicineConsultationsInput>, PatientUncheckedUpdateWithoutTelemedicineConsultationsInput>
  }

  export type UserUpdateOneWithoutDoctorTelemedicineNestedInput = {
    create?: XOR<UserCreateWithoutDoctorTelemedicineInput, UserUncheckedCreateWithoutDoctorTelemedicineInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorTelemedicineInput
    upsert?: UserUpsertWithoutDoctorTelemedicineInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDoctorTelemedicineInput, UserUpdateWithoutDoctorTelemedicineInput>, UserUncheckedUpdateWithoutDoctorTelemedicineInput>
  }

  export type TenantUpdateOneRequiredWithoutTelemedicineConsultationsNestedInput = {
    create?: XOR<TenantCreateWithoutTelemedicineConsultationsInput, TenantUncheckedCreateWithoutTelemedicineConsultationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTelemedicineConsultationsInput
    upsert?: TenantUpsertWithoutTelemedicineConsultationsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTelemedicineConsultationsInput, TenantUpdateWithoutTelemedicineConsultationsInput>, TenantUncheckedUpdateWithoutTelemedicineConsultationsInput>
  }

  export type VideoRoomUpdateOneWithoutConsultationNestedInput = {
    create?: XOR<VideoRoomCreateWithoutConsultationInput, VideoRoomUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: VideoRoomCreateOrConnectWithoutConsultationInput
    upsert?: VideoRoomUpsertWithoutConsultationInput
    disconnect?: VideoRoomWhereInput | boolean
    delete?: VideoRoomWhereInput | boolean
    connect?: VideoRoomWhereUniqueInput
    update?: XOR<XOR<VideoRoomUpdateToOneWithWhereWithoutConsultationInput, VideoRoomUpdateWithoutConsultationInput>, VideoRoomUncheckedUpdateWithoutConsultationInput>
  }

  export type LabOrderUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<LabOrderCreateWithoutConsultationInput, LabOrderUncheckedCreateWithoutConsultationInput> | LabOrderCreateWithoutConsultationInput[] | LabOrderUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutConsultationInput | LabOrderCreateOrConnectWithoutConsultationInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutConsultationInput | LabOrderUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: LabOrderCreateManyConsultationInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutConsultationInput | LabOrderUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutConsultationInput | LabOrderUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type RadiologyOrderUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<RadiologyOrderCreateWithoutConsultationInput, RadiologyOrderUncheckedCreateWithoutConsultationInput> | RadiologyOrderCreateWithoutConsultationInput[] | RadiologyOrderUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutConsultationInput | RadiologyOrderCreateOrConnectWithoutConsultationInput[]
    upsert?: RadiologyOrderUpsertWithWhereUniqueWithoutConsultationInput | RadiologyOrderUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: RadiologyOrderCreateManyConsultationInputEnvelope
    set?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    disconnect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    delete?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    update?: RadiologyOrderUpdateWithWhereUniqueWithoutConsultationInput | RadiologyOrderUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: RadiologyOrderUpdateManyWithWhereWithoutConsultationInput | RadiologyOrderUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: RadiologyOrderScalarWhereInput | RadiologyOrderScalarWhereInput[]
  }

  export type VideoRoomUncheckedUpdateOneWithoutConsultationNestedInput = {
    create?: XOR<VideoRoomCreateWithoutConsultationInput, VideoRoomUncheckedCreateWithoutConsultationInput>
    connectOrCreate?: VideoRoomCreateOrConnectWithoutConsultationInput
    upsert?: VideoRoomUpsertWithoutConsultationInput
    disconnect?: VideoRoomWhereInput | boolean
    delete?: VideoRoomWhereInput | boolean
    connect?: VideoRoomWhereUniqueInput
    update?: XOR<XOR<VideoRoomUpdateToOneWithWhereWithoutConsultationInput, VideoRoomUpdateWithoutConsultationInput>, VideoRoomUncheckedUpdateWithoutConsultationInput>
  }

  export type LabOrderUncheckedUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<LabOrderCreateWithoutConsultationInput, LabOrderUncheckedCreateWithoutConsultationInput> | LabOrderCreateWithoutConsultationInput[] | LabOrderUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: LabOrderCreateOrConnectWithoutConsultationInput | LabOrderCreateOrConnectWithoutConsultationInput[]
    upsert?: LabOrderUpsertWithWhereUniqueWithoutConsultationInput | LabOrderUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: LabOrderCreateManyConsultationInputEnvelope
    set?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    disconnect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    delete?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    connect?: LabOrderWhereUniqueInput | LabOrderWhereUniqueInput[]
    update?: LabOrderUpdateWithWhereUniqueWithoutConsultationInput | LabOrderUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: LabOrderUpdateManyWithWhereWithoutConsultationInput | LabOrderUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
  }

  export type RadiologyOrderUncheckedUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<RadiologyOrderCreateWithoutConsultationInput, RadiologyOrderUncheckedCreateWithoutConsultationInput> | RadiologyOrderCreateWithoutConsultationInput[] | RadiologyOrderUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: RadiologyOrderCreateOrConnectWithoutConsultationInput | RadiologyOrderCreateOrConnectWithoutConsultationInput[]
    upsert?: RadiologyOrderUpsertWithWhereUniqueWithoutConsultationInput | RadiologyOrderUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: RadiologyOrderCreateManyConsultationInputEnvelope
    set?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    disconnect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    delete?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    connect?: RadiologyOrderWhereUniqueInput | RadiologyOrderWhereUniqueInput[]
    update?: RadiologyOrderUpdateWithWhereUniqueWithoutConsultationInput | RadiologyOrderUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: RadiologyOrderUpdateManyWithWhereWithoutConsultationInput | RadiologyOrderUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: RadiologyOrderScalarWhereInput | RadiologyOrderScalarWhereInput[]
  }

  export type TelemedicineConsultationCreateNestedOneWithoutVideoRoomInput = {
    create?: XOR<TelemedicineConsultationCreateWithoutVideoRoomInput, TelemedicineConsultationUncheckedCreateWithoutVideoRoomInput>
    connectOrCreate?: TelemedicineConsultationCreateOrConnectWithoutVideoRoomInput
    connect?: TelemedicineConsultationWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutVideoRoomsInput = {
    create?: XOR<TenantCreateWithoutVideoRoomsInput, TenantUncheckedCreateWithoutVideoRoomsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVideoRoomsInput
    connect?: TenantWhereUniqueInput
  }

  export type VideoParticipantCreateNestedManyWithoutRoomInput = {
    create?: XOR<VideoParticipantCreateWithoutRoomInput, VideoParticipantUncheckedCreateWithoutRoomInput> | VideoParticipantCreateWithoutRoomInput[] | VideoParticipantUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: VideoParticipantCreateOrConnectWithoutRoomInput | VideoParticipantCreateOrConnectWithoutRoomInput[]
    createMany?: VideoParticipantCreateManyRoomInputEnvelope
    connect?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
  }

  export type VideoRecordingCreateNestedManyWithoutRoomInput = {
    create?: XOR<VideoRecordingCreateWithoutRoomInput, VideoRecordingUncheckedCreateWithoutRoomInput> | VideoRecordingCreateWithoutRoomInput[] | VideoRecordingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: VideoRecordingCreateOrConnectWithoutRoomInput | VideoRecordingCreateOrConnectWithoutRoomInput[]
    createMany?: VideoRecordingCreateManyRoomInputEnvelope
    connect?: VideoRecordingWhereUniqueInput | VideoRecordingWhereUniqueInput[]
  }

  export type VideoParticipantUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<VideoParticipantCreateWithoutRoomInput, VideoParticipantUncheckedCreateWithoutRoomInput> | VideoParticipantCreateWithoutRoomInput[] | VideoParticipantUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: VideoParticipantCreateOrConnectWithoutRoomInput | VideoParticipantCreateOrConnectWithoutRoomInput[]
    createMany?: VideoParticipantCreateManyRoomInputEnvelope
    connect?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
  }

  export type VideoRecordingUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<VideoRecordingCreateWithoutRoomInput, VideoRecordingUncheckedCreateWithoutRoomInput> | VideoRecordingCreateWithoutRoomInput[] | VideoRecordingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: VideoRecordingCreateOrConnectWithoutRoomInput | VideoRecordingCreateOrConnectWithoutRoomInput[]
    createMany?: VideoRecordingCreateManyRoomInputEnvelope
    connect?: VideoRecordingWhereUniqueInput | VideoRecordingWhereUniqueInput[]
  }

  export type EnumVideoRoomStatusFieldUpdateOperationsInput = {
    set?: $Enums.VideoRoomStatus
  }

  export type TelemedicineConsultationUpdateOneRequiredWithoutVideoRoomNestedInput = {
    create?: XOR<TelemedicineConsultationCreateWithoutVideoRoomInput, TelemedicineConsultationUncheckedCreateWithoutVideoRoomInput>
    connectOrCreate?: TelemedicineConsultationCreateOrConnectWithoutVideoRoomInput
    upsert?: TelemedicineConsultationUpsertWithoutVideoRoomInput
    connect?: TelemedicineConsultationWhereUniqueInput
    update?: XOR<XOR<TelemedicineConsultationUpdateToOneWithWhereWithoutVideoRoomInput, TelemedicineConsultationUpdateWithoutVideoRoomInput>, TelemedicineConsultationUncheckedUpdateWithoutVideoRoomInput>
  }

  export type TenantUpdateOneRequiredWithoutVideoRoomsNestedInput = {
    create?: XOR<TenantCreateWithoutVideoRoomsInput, TenantUncheckedCreateWithoutVideoRoomsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVideoRoomsInput
    upsert?: TenantUpsertWithoutVideoRoomsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutVideoRoomsInput, TenantUpdateWithoutVideoRoomsInput>, TenantUncheckedUpdateWithoutVideoRoomsInput>
  }

  export type VideoParticipantUpdateManyWithoutRoomNestedInput = {
    create?: XOR<VideoParticipantCreateWithoutRoomInput, VideoParticipantUncheckedCreateWithoutRoomInput> | VideoParticipantCreateWithoutRoomInput[] | VideoParticipantUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: VideoParticipantCreateOrConnectWithoutRoomInput | VideoParticipantCreateOrConnectWithoutRoomInput[]
    upsert?: VideoParticipantUpsertWithWhereUniqueWithoutRoomInput | VideoParticipantUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: VideoParticipantCreateManyRoomInputEnvelope
    set?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    disconnect?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    delete?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    connect?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    update?: VideoParticipantUpdateWithWhereUniqueWithoutRoomInput | VideoParticipantUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: VideoParticipantUpdateManyWithWhereWithoutRoomInput | VideoParticipantUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: VideoParticipantScalarWhereInput | VideoParticipantScalarWhereInput[]
  }

  export type VideoRecordingUpdateManyWithoutRoomNestedInput = {
    create?: XOR<VideoRecordingCreateWithoutRoomInput, VideoRecordingUncheckedCreateWithoutRoomInput> | VideoRecordingCreateWithoutRoomInput[] | VideoRecordingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: VideoRecordingCreateOrConnectWithoutRoomInput | VideoRecordingCreateOrConnectWithoutRoomInput[]
    upsert?: VideoRecordingUpsertWithWhereUniqueWithoutRoomInput | VideoRecordingUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: VideoRecordingCreateManyRoomInputEnvelope
    set?: VideoRecordingWhereUniqueInput | VideoRecordingWhereUniqueInput[]
    disconnect?: VideoRecordingWhereUniqueInput | VideoRecordingWhereUniqueInput[]
    delete?: VideoRecordingWhereUniqueInput | VideoRecordingWhereUniqueInput[]
    connect?: VideoRecordingWhereUniqueInput | VideoRecordingWhereUniqueInput[]
    update?: VideoRecordingUpdateWithWhereUniqueWithoutRoomInput | VideoRecordingUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: VideoRecordingUpdateManyWithWhereWithoutRoomInput | VideoRecordingUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: VideoRecordingScalarWhereInput | VideoRecordingScalarWhereInput[]
  }

  export type VideoParticipantUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<VideoParticipantCreateWithoutRoomInput, VideoParticipantUncheckedCreateWithoutRoomInput> | VideoParticipantCreateWithoutRoomInput[] | VideoParticipantUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: VideoParticipantCreateOrConnectWithoutRoomInput | VideoParticipantCreateOrConnectWithoutRoomInput[]
    upsert?: VideoParticipantUpsertWithWhereUniqueWithoutRoomInput | VideoParticipantUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: VideoParticipantCreateManyRoomInputEnvelope
    set?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    disconnect?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    delete?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    connect?: VideoParticipantWhereUniqueInput | VideoParticipantWhereUniqueInput[]
    update?: VideoParticipantUpdateWithWhereUniqueWithoutRoomInput | VideoParticipantUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: VideoParticipantUpdateManyWithWhereWithoutRoomInput | VideoParticipantUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: VideoParticipantScalarWhereInput | VideoParticipantScalarWhereInput[]
  }

  export type VideoRecordingUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<VideoRecordingCreateWithoutRoomInput, VideoRecordingUncheckedCreateWithoutRoomInput> | VideoRecordingCreateWithoutRoomInput[] | VideoRecordingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: VideoRecordingCreateOrConnectWithoutRoomInput | VideoRecordingCreateOrConnectWithoutRoomInput[]
    upsert?: VideoRecordingUpsertWithWhereUniqueWithoutRoomInput | VideoRecordingUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: VideoRecordingCreateManyRoomInputEnvelope
    set?: VideoRecordingWhereUniqueInput | VideoRecordingWhereUniqueInput[]
    disconnect?: VideoRecordingWhereUniqueInput | VideoRecordingWhereUniqueInput[]
    delete?: VideoRecordingWhereUniqueInput | VideoRecordingWhereUniqueInput[]
    connect?: VideoRecordingWhereUniqueInput | VideoRecordingWhereUniqueInput[]
    update?: VideoRecordingUpdateWithWhereUniqueWithoutRoomInput | VideoRecordingUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: VideoRecordingUpdateManyWithWhereWithoutRoomInput | VideoRecordingUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: VideoRecordingScalarWhereInput | VideoRecordingScalarWhereInput[]
  }

  export type VideoRoomCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<VideoRoomCreateWithoutParticipantsInput, VideoRoomUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: VideoRoomCreateOrConnectWithoutParticipantsInput
    connect?: VideoRoomWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutVideoParticipantsInput = {
    create?: XOR<TenantCreateWithoutVideoParticipantsInput, TenantUncheckedCreateWithoutVideoParticipantsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVideoParticipantsInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumParticipantTypeFieldUpdateOperationsInput = {
    set?: $Enums.ParticipantType
  }

  export type VideoRoomUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<VideoRoomCreateWithoutParticipantsInput, VideoRoomUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: VideoRoomCreateOrConnectWithoutParticipantsInput
    upsert?: VideoRoomUpsertWithoutParticipantsInput
    connect?: VideoRoomWhereUniqueInput
    update?: XOR<XOR<VideoRoomUpdateToOneWithWhereWithoutParticipantsInput, VideoRoomUpdateWithoutParticipantsInput>, VideoRoomUncheckedUpdateWithoutParticipantsInput>
  }

  export type TenantUpdateOneRequiredWithoutVideoParticipantsNestedInput = {
    create?: XOR<TenantCreateWithoutVideoParticipantsInput, TenantUncheckedCreateWithoutVideoParticipantsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVideoParticipantsInput
    upsert?: TenantUpsertWithoutVideoParticipantsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutVideoParticipantsInput, TenantUpdateWithoutVideoParticipantsInput>, TenantUncheckedUpdateWithoutVideoParticipantsInput>
  }

  export type VideoRoomCreateNestedOneWithoutRecordingsInput = {
    create?: XOR<VideoRoomCreateWithoutRecordingsInput, VideoRoomUncheckedCreateWithoutRecordingsInput>
    connectOrCreate?: VideoRoomCreateOrConnectWithoutRecordingsInput
    connect?: VideoRoomWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutVideoRecordingsInput = {
    create?: XOR<TenantCreateWithoutVideoRecordingsInput, TenantUncheckedCreateWithoutVideoRecordingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVideoRecordingsInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumRecordingStatusFieldUpdateOperationsInput = {
    set?: $Enums.RecordingStatus
  }

  export type VideoRoomUpdateOneRequiredWithoutRecordingsNestedInput = {
    create?: XOR<VideoRoomCreateWithoutRecordingsInput, VideoRoomUncheckedCreateWithoutRecordingsInput>
    connectOrCreate?: VideoRoomCreateOrConnectWithoutRecordingsInput
    upsert?: VideoRoomUpsertWithoutRecordingsInput
    connect?: VideoRoomWhereUniqueInput
    update?: XOR<XOR<VideoRoomUpdateToOneWithWhereWithoutRecordingsInput, VideoRoomUpdateWithoutRecordingsInput>, VideoRoomUncheckedUpdateWithoutRecordingsInput>
  }

  export type TenantUpdateOneRequiredWithoutVideoRecordingsNestedInput = {
    create?: XOR<TenantCreateWithoutVideoRecordingsInput, TenantUncheckedCreateWithoutVideoRecordingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVideoRecordingsInput
    upsert?: TenantUpsertWithoutVideoRecordingsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutVideoRecordingsInput, TenantUpdateWithoutVideoRecordingsInput>, TenantUncheckedUpdateWithoutVideoRecordingsInput>
  }

  export type TenantCreateNestedOneWithoutVideoMessagesInput = {
    create?: XOR<TenantCreateWithoutVideoMessagesInput, TenantUncheckedCreateWithoutVideoMessagesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVideoMessagesInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type TenantUpdateOneRequiredWithoutVideoMessagesNestedInput = {
    create?: XOR<TenantCreateWithoutVideoMessagesInput, TenantUncheckedCreateWithoutVideoMessagesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutVideoMessagesInput
    upsert?: TenantUpsertWithoutVideoMessagesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutVideoMessagesInput, TenantUpdateWithoutVideoMessagesInput>, TenantUncheckedUpdateWithoutVideoMessagesInput>
  }

  export type TelemedicineConsultationCreateNestedOneWithoutRadiologyOrdersInput = {
    create?: XOR<TelemedicineConsultationCreateWithoutRadiologyOrdersInput, TelemedicineConsultationUncheckedCreateWithoutRadiologyOrdersInput>
    connectOrCreate?: TelemedicineConsultationCreateOrConnectWithoutRadiologyOrdersInput
    connect?: TelemedicineConsultationWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutRadiologyOrdersInput = {
    create?: XOR<PatientCreateWithoutRadiologyOrdersInput, PatientUncheckedCreateWithoutRadiologyOrdersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutRadiologyOrdersInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDoctorRadiologyOrdersInput = {
    create?: XOR<UserCreateWithoutDoctorRadiologyOrdersInput, UserUncheckedCreateWithoutDoctorRadiologyOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorRadiologyOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type ModalityCreateNestedOneWithoutRadiologyOrdersInput = {
    create?: XOR<ModalityCreateWithoutRadiologyOrdersInput, ModalityUncheckedCreateWithoutRadiologyOrdersInput>
    connectOrCreate?: ModalityCreateOrConnectWithoutRadiologyOrdersInput
    connect?: ModalityWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutRadiologyOrdersInput = {
    create?: XOR<TenantCreateWithoutRadiologyOrdersInput, TenantUncheckedCreateWithoutRadiologyOrdersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRadiologyOrdersInput
    connect?: TenantWhereUniqueInput
  }

  export type StudyCreateNestedOneWithoutRadiologyOrdersInput = {
    create?: XOR<StudyCreateWithoutRadiologyOrdersInput, StudyUncheckedCreateWithoutRadiologyOrdersInput>
    connectOrCreate?: StudyCreateOrConnectWithoutRadiologyOrdersInput
    connect?: StudyWhereUniqueInput
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type EnumRadiologyOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.RadiologyOrderStatus
  }

  export type TelemedicineConsultationUpdateOneRequiredWithoutRadiologyOrdersNestedInput = {
    create?: XOR<TelemedicineConsultationCreateWithoutRadiologyOrdersInput, TelemedicineConsultationUncheckedCreateWithoutRadiologyOrdersInput>
    connectOrCreate?: TelemedicineConsultationCreateOrConnectWithoutRadiologyOrdersInput
    upsert?: TelemedicineConsultationUpsertWithoutRadiologyOrdersInput
    connect?: TelemedicineConsultationWhereUniqueInput
    update?: XOR<XOR<TelemedicineConsultationUpdateToOneWithWhereWithoutRadiologyOrdersInput, TelemedicineConsultationUpdateWithoutRadiologyOrdersInput>, TelemedicineConsultationUncheckedUpdateWithoutRadiologyOrdersInput>
  }

  export type PatientUpdateOneRequiredWithoutRadiologyOrdersNestedInput = {
    create?: XOR<PatientCreateWithoutRadiologyOrdersInput, PatientUncheckedCreateWithoutRadiologyOrdersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutRadiologyOrdersInput
    upsert?: PatientUpsertWithoutRadiologyOrdersInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutRadiologyOrdersInput, PatientUpdateWithoutRadiologyOrdersInput>, PatientUncheckedUpdateWithoutRadiologyOrdersInput>
  }

  export type UserUpdateOneRequiredWithoutDoctorRadiologyOrdersNestedInput = {
    create?: XOR<UserCreateWithoutDoctorRadiologyOrdersInput, UserUncheckedCreateWithoutDoctorRadiologyOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorRadiologyOrdersInput
    upsert?: UserUpsertWithoutDoctorRadiologyOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDoctorRadiologyOrdersInput, UserUpdateWithoutDoctorRadiologyOrdersInput>, UserUncheckedUpdateWithoutDoctorRadiologyOrdersInput>
  }

  export type ModalityUpdateOneRequiredWithoutRadiologyOrdersNestedInput = {
    create?: XOR<ModalityCreateWithoutRadiologyOrdersInput, ModalityUncheckedCreateWithoutRadiologyOrdersInput>
    connectOrCreate?: ModalityCreateOrConnectWithoutRadiologyOrdersInput
    upsert?: ModalityUpsertWithoutRadiologyOrdersInput
    connect?: ModalityWhereUniqueInput
    update?: XOR<XOR<ModalityUpdateToOneWithWhereWithoutRadiologyOrdersInput, ModalityUpdateWithoutRadiologyOrdersInput>, ModalityUncheckedUpdateWithoutRadiologyOrdersInput>
  }

  export type TenantUpdateOneRequiredWithoutRadiologyOrdersNestedInput = {
    create?: XOR<TenantCreateWithoutRadiologyOrdersInput, TenantUncheckedCreateWithoutRadiologyOrdersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRadiologyOrdersInput
    upsert?: TenantUpsertWithoutRadiologyOrdersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutRadiologyOrdersInput, TenantUpdateWithoutRadiologyOrdersInput>, TenantUncheckedUpdateWithoutRadiologyOrdersInput>
  }

  export type StudyUpdateOneWithoutRadiologyOrdersNestedInput = {
    create?: XOR<StudyCreateWithoutRadiologyOrdersInput, StudyUncheckedCreateWithoutRadiologyOrdersInput>
    connectOrCreate?: StudyCreateOrConnectWithoutRadiologyOrdersInput
    upsert?: StudyUpsertWithoutRadiologyOrdersInput
    disconnect?: StudyWhereInput | boolean
    delete?: StudyWhereInput | boolean
    connect?: StudyWhereUniqueInput
    update?: XOR<XOR<StudyUpdateToOneWithWhereWithoutRadiologyOrdersInput, StudyUpdateWithoutRadiologyOrdersInput>, StudyUncheckedUpdateWithoutRadiologyOrdersInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTenantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantType | EnumTenantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantTypeFilter<$PrismaModel> | $Enums.TenantType
  }

  export type NestedEnumTenantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantType | EnumTenantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantTypeWithAggregatesFilter<$PrismaModel> | $Enums.TenantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantTypeFilter<$PrismaModel>
    _max?: NestedEnumTenantTypeFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedEnumBloodTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BloodType | EnumBloodTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.BloodType[] | ListEnumBloodTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BloodType[] | ListEnumBloodTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBloodTypeNullableFilter<$PrismaModel> | $Enums.BloodType | null
  }

  export type NestedEnumMaritalStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableFilter<$PrismaModel> | $Enums.MaritalStatus | null
  }

  export type NestedEnumInsuranceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.InsuranceType | EnumInsuranceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.InsuranceType[] | ListEnumInsuranceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InsuranceType[] | ListEnumInsuranceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInsuranceTypeNullableFilter<$PrismaModel> | $Enums.InsuranceType | null
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedEnumBloodTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BloodType | EnumBloodTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.BloodType[] | ListEnumBloodTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BloodType[] | ListEnumBloodTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBloodTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.BloodType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBloodTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumBloodTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaritalStatus | EnumMaritalStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MaritalStatus[] | ListEnumMaritalStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMaritalStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.MaritalStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumMaritalStatusNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumInsuranceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsuranceType | EnumInsuranceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.InsuranceType[] | ListEnumInsuranceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InsuranceType[] | ListEnumInsuranceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInsuranceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.InsuranceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumInsuranceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumInsuranceTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumPrescriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PrescriptionStatus | EnumPrescriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPrescriptionStatusFilter<$PrismaModel> | $Enums.PrescriptionStatus
  }

  export type NestedEnumPrescriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrescriptionStatus | EnumPrescriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrescriptionStatus[] | ListEnumPrescriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPrescriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.PrescriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrescriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumPrescriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumLabOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LabOrderStatus | EnumLabOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabOrderStatus[] | ListEnumLabOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabOrderStatus[] | ListEnumLabOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabOrderStatusFilter<$PrismaModel> | $Enums.LabOrderStatus
  }

  export type NestedEnumLabOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LabOrderStatus | EnumLabOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabOrderStatus[] | ListEnumLabOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabOrderStatus[] | ListEnumLabOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.LabOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumLabOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumLabTestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LabTestStatus | EnumLabTestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabTestStatus[] | ListEnumLabTestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabTestStatus[] | ListEnumLabTestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabTestStatusFilter<$PrismaModel> | $Enums.LabTestStatus
  }

  export type NestedEnumLabTestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LabTestStatus | EnumLabTestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LabTestStatus[] | ListEnumLabTestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LabTestStatus[] | ListEnumLabTestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLabTestStatusWithAggregatesFilter<$PrismaModel> | $Enums.LabTestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLabTestStatusFilter<$PrismaModel>
    _max?: NestedEnumLabTestStatusFilter<$PrismaModel>
  }

  export type NestedEnumPharmacyOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PharmacyOrderStatus | EnumPharmacyOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PharmacyOrderStatus[] | ListEnumPharmacyOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PharmacyOrderStatus[] | ListEnumPharmacyOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPharmacyOrderStatusFilter<$PrismaModel> | $Enums.PharmacyOrderStatus
  }

  export type NestedEnumPharmacyOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PharmacyOrderStatus | EnumPharmacyOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PharmacyOrderStatus[] | ListEnumPharmacyOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PharmacyOrderStatus[] | ListEnumPharmacyOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPharmacyOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.PharmacyOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPharmacyOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumPharmacyOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumPharmacyItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PharmacyItemStatus | EnumPharmacyItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PharmacyItemStatus[] | ListEnumPharmacyItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PharmacyItemStatus[] | ListEnumPharmacyItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPharmacyItemStatusFilter<$PrismaModel> | $Enums.PharmacyItemStatus
  }

  export type NestedEnumPharmacyItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PharmacyItemStatus | EnumPharmacyItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PharmacyItemStatus[] | ListEnumPharmacyItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PharmacyItemStatus[] | ListEnumPharmacyItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPharmacyItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.PharmacyItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPharmacyItemStatusFilter<$PrismaModel>
    _max?: NestedEnumPharmacyItemStatusFilter<$PrismaModel>
  }

  export type NestedEnumStudyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudyStatus | EnumStudyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudyStatus[] | ListEnumStudyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudyStatus[] | ListEnumStudyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudyStatusFilter<$PrismaModel> | $Enums.StudyStatus
  }

  export type NestedEnumPriorityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriorityNullableFilter<$PrismaModel> | $Enums.Priority | null
  }

  export type NestedEnumStudyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudyStatus | EnumStudyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudyStatus[] | ListEnumStudyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudyStatus[] | ListEnumStudyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudyStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudyStatusFilter<$PrismaModel>
    _max?: NestedEnumStudyStatusFilter<$PrismaModel>
  }

  export type NestedEnumPriorityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriorityNullableWithAggregatesFilter<$PrismaModel> | $Enums.Priority | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPriorityNullableFilter<$PrismaModel>
    _max?: NestedEnumPriorityNullableFilter<$PrismaModel>
  }

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type NestedEnumTelemedicineStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TelemedicineStatus | EnumTelemedicineStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TelemedicineStatus[] | ListEnumTelemedicineStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TelemedicineStatus[] | ListEnumTelemedicineStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTelemedicineStatusFilter<$PrismaModel> | $Enums.TelemedicineStatus
  }

  export type NestedEnumConsultationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsultationType | EnumConsultationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsultationType[] | ListEnumConsultationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsultationType[] | ListEnumConsultationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsultationTypeFilter<$PrismaModel> | $Enums.ConsultationType
  }

  export type NestedEnumTelemedicineStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TelemedicineStatus | EnumTelemedicineStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TelemedicineStatus[] | ListEnumTelemedicineStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TelemedicineStatus[] | ListEnumTelemedicineStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTelemedicineStatusWithAggregatesFilter<$PrismaModel> | $Enums.TelemedicineStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTelemedicineStatusFilter<$PrismaModel>
    _max?: NestedEnumTelemedicineStatusFilter<$PrismaModel>
  }

  export type NestedEnumConsultationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConsultationType | EnumConsultationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConsultationType[] | ListEnumConsultationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConsultationType[] | ListEnumConsultationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConsultationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConsultationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConsultationTypeFilter<$PrismaModel>
    _max?: NestedEnumConsultationTypeFilter<$PrismaModel>
  }

  export type NestedEnumVideoRoomStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoRoomStatus | EnumVideoRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VideoRoomStatus[] | ListEnumVideoRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoRoomStatus[] | ListEnumVideoRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoRoomStatusFilter<$PrismaModel> | $Enums.VideoRoomStatus
  }

  export type NestedEnumVideoRoomStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoRoomStatus | EnumVideoRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VideoRoomStatus[] | ListEnumVideoRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VideoRoomStatus[] | ListEnumVideoRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVideoRoomStatusWithAggregatesFilter<$PrismaModel> | $Enums.VideoRoomStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVideoRoomStatusFilter<$PrismaModel>
    _max?: NestedEnumVideoRoomStatusFilter<$PrismaModel>
  }

  export type NestedEnumParticipantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantType | EnumParticipantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParticipantType[] | ListEnumParticipantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParticipantType[] | ListEnumParticipantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumParticipantTypeFilter<$PrismaModel> | $Enums.ParticipantType
  }

  export type NestedEnumParticipantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ParticipantType | EnumParticipantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ParticipantType[] | ListEnumParticipantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ParticipantType[] | ListEnumParticipantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumParticipantTypeWithAggregatesFilter<$PrismaModel> | $Enums.ParticipantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumParticipantTypeFilter<$PrismaModel>
    _max?: NestedEnumParticipantTypeFilter<$PrismaModel>
  }

  export type NestedEnumRecordingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RecordingStatus | EnumRecordingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecordingStatusFilter<$PrismaModel> | $Enums.RecordingStatus
  }

  export type NestedEnumRecordingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecordingStatus | EnumRecordingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecordingStatusWithAggregatesFilter<$PrismaModel> | $Enums.RecordingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecordingStatusFilter<$PrismaModel>
    _max?: NestedEnumRecordingStatusFilter<$PrismaModel>
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumRadiologyOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RadiologyOrderStatus | EnumRadiologyOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RadiologyOrderStatus[] | ListEnumRadiologyOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RadiologyOrderStatus[] | ListEnumRadiologyOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRadiologyOrderStatusFilter<$PrismaModel> | $Enums.RadiologyOrderStatus
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumRadiologyOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RadiologyOrderStatus | EnumRadiologyOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RadiologyOrderStatus[] | ListEnumRadiologyOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RadiologyOrderStatus[] | ListEnumRadiologyOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRadiologyOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.RadiologyOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRadiologyOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumRadiologyOrderStatusFilter<$PrismaModel>
  }

  export type AppointmentCreateWithoutDepartmentInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    status: $Enums.AppointmentStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAppointmentsInput
    doctor: UserCreateNestedOneWithoutDoctorAppointmentsInput
    patient: PatientCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutDepartmentInput = {
    id?: string
    patientId: string
    doctorId: string
    startTime: Date | string
    endTime: Date | string
    status: $Enums.AppointmentStatus
    reason?: string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateOrConnectWithoutDepartmentInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutDepartmentInput, AppointmentUncheckedCreateWithoutDepartmentInput>
  }

  export type AppointmentCreateManyDepartmentInputEnvelope = {
    data: AppointmentCreateManyDepartmentInput | AppointmentCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDepartmentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDepartmentsInput, TenantUncheckedCreateWithoutDepartmentsInput>
  }

  export type StaffCreateWithoutDepartmentInput = {
    id?: string
    employeeId?: string | null
    designation?: string | null
    joiningDate?: Date | string | null
    qualification?: string | null
    experience?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStaffInput
    user: UserCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutDepartmentInput = {
    id?: string
    userId: string
    employeeId?: string | null
    designation?: string | null
    joiningDate?: Date | string | null
    qualification?: string | null
    experience?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffCreateOrConnectWithoutDepartmentInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput>
  }

  export type StaffCreateManyDepartmentInputEnvelope = {
    data: StaffCreateManyDepartmentInput | StaffCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutDepartmentInput, AppointmentUncheckedUpdateWithoutDepartmentInput>
    create: XOR<AppointmentCreateWithoutDepartmentInput, AppointmentUncheckedCreateWithoutDepartmentInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutDepartmentInput, AppointmentUncheckedUpdateWithoutDepartmentInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutDepartmentInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: StringFilter<"Appointment"> | string
    patientId?: StringFilter<"Appointment"> | string
    doctorId?: StringFilter<"Appointment"> | string
    departmentId?: StringNullableFilter<"Appointment"> | string | null
    startTime?: DateTimeFilter<"Appointment"> | Date | string
    endTime?: DateTimeFilter<"Appointment"> | Date | string
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    reason?: StringNullableFilter<"Appointment"> | string | null
    notes?: StringNullableFilter<"Appointment"> | string | null
    tenantId?: StringFilter<"Appointment"> | string
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
  }

  export type TenantUpsertWithoutDepartmentsInput = {
    update: XOR<TenantUpdateWithoutDepartmentsInput, TenantUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<TenantCreateWithoutDepartmentsInput, TenantUncheckedCreateWithoutDepartmentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDepartmentsInput, TenantUncheckedUpdateWithoutDepartmentsInput>
  }

  export type TenantUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type StaffUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: StaffWhereUniqueInput
    update: XOR<StaffUpdateWithoutDepartmentInput, StaffUncheckedUpdateWithoutDepartmentInput>
    create: XOR<StaffCreateWithoutDepartmentInput, StaffUncheckedCreateWithoutDepartmentInput>
  }

  export type StaffUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: StaffWhereUniqueInput
    data: XOR<StaffUpdateWithoutDepartmentInput, StaffUncheckedUpdateWithoutDepartmentInput>
  }

  export type StaffUpdateManyWithWhereWithoutDepartmentInput = {
    where: StaffScalarWhereInput
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type StaffScalarWhereInput = {
    AND?: StaffScalarWhereInput | StaffScalarWhereInput[]
    OR?: StaffScalarWhereInput[]
    NOT?: StaffScalarWhereInput | StaffScalarWhereInput[]
    id?: StringFilter<"Staff"> | string
    userId?: StringFilter<"Staff"> | string
    employeeId?: StringNullableFilter<"Staff"> | string | null
    designation?: StringNullableFilter<"Staff"> | string | null
    departmentId?: StringNullableFilter<"Staff"> | string | null
    joiningDate?: DateTimeNullableFilter<"Staff"> | Date | string | null
    qualification?: StringNullableFilter<"Staff"> | string | null
    experience?: StringNullableFilter<"Staff"> | string | null
    isActive?: BoolFilter<"Staff"> | boolean
    tenantId?: StringFilter<"Staff"> | string
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Staff"> | Date | string
  }

  export type TenantCreateWithoutSpecialtiesInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSpecialtiesInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSpecialtiesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSpecialtiesInput, TenantUncheckedCreateWithoutSpecialtiesInput>
  }

  export type TenantUpsertWithoutSpecialtiesInput = {
    update: XOR<TenantUpdateWithoutSpecialtiesInput, TenantUncheckedUpdateWithoutSpecialtiesInput>
    create: XOR<TenantCreateWithoutSpecialtiesInput, TenantUncheckedCreateWithoutSpecialtiesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSpecialtiesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSpecialtiesInput, TenantUncheckedUpdateWithoutSpecialtiesInput>
  }

  export type TenantUpdateWithoutSpecialtiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSpecialtiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutStaffInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutStaffInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutStaffInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutStaffInput, TenantUncheckedCreateWithoutStaffInput>
  }

  export type DepartmentCreateWithoutStaffInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutDepartmentInput
    tenant: TenantCreateNestedOneWithoutDepartmentsInput
  }

  export type DepartmentUncheckedCreateWithoutStaffInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutStaffInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutStaffInput, DepartmentUncheckedCreateWithoutStaffInput>
  }

  export type UserCreateWithoutStaffInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordCreateNestedManyWithoutUpdatedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutStaffInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderUncheckedCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutStaffInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStaffInput, UserUncheckedCreateWithoutStaffInput>
  }

  export type TenantUpsertWithoutStaffInput = {
    update: XOR<TenantUpdateWithoutStaffInput, TenantUncheckedUpdateWithoutStaffInput>
    create: XOR<TenantCreateWithoutStaffInput, TenantUncheckedCreateWithoutStaffInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutStaffInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutStaffInput, TenantUncheckedUpdateWithoutStaffInput>
  }

  export type TenantUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type DepartmentUpsertWithoutStaffInput = {
    update: XOR<DepartmentUpdateWithoutStaffInput, DepartmentUncheckedUpdateWithoutStaffInput>
    create: XOR<DepartmentCreateWithoutStaffInput, DepartmentUncheckedCreateWithoutStaffInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutStaffInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutStaffInput, DepartmentUncheckedUpdateWithoutStaffInput>
  }

  export type DepartmentUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutDepartmentNestedInput
    tenant?: TenantUpdateOneRequiredWithoutDepartmentsNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type UserUpsertWithoutStaffInput = {
    update: XOR<UserUpdateWithoutStaffInput, UserUncheckedUpdateWithoutStaffInput>
    create: XOR<UserCreateWithoutStaffInput, UserUncheckedCreateWithoutStaffInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStaffInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStaffInput, UserUncheckedUpdateWithoutStaffInput>
  }

  export type UserUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUpdateManyWithoutUpdatedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUncheckedUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type AppointmentCreateWithoutTenantInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    status: $Enums.AppointmentStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutAppointmentsInput
    doctor: UserCreateNestedOneWithoutDoctorAppointmentsInput
    patient: PatientCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutTenantInput = {
    id?: string
    patientId: string
    doctorId: string
    departmentId?: string | null
    startTime: Date | string
    endTime: Date | string
    status: $Enums.AppointmentStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateOrConnectWithoutTenantInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutTenantInput, AppointmentUncheckedCreateWithoutTenantInput>
  }

  export type AppointmentCreateManyTenantInputEnvelope = {
    data: AppointmentCreateManyTenantInput | AppointmentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutTenantInput = {
    id?: string
    action: string
    entityType?: string | null
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    action: string
    entityType?: string | null
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogCreateManyTenantInputEnvelope = {
    data: AuditLogCreateManyTenantInput | AuditLogCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutTenantInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutDepartmentInput
    staff?: StaffCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDepartmentInput
    staff?: StaffUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutTenantInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutTenantInput, DepartmentUncheckedCreateWithoutTenantInput>
  }

  export type DepartmentCreateManyTenantInputEnvelope = {
    data: DepartmentCreateManyTenantInput | DepartmentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutTenantInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    subTotal?: number
    taxAmount?: number
    discountAmount?: number
    totalAmount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    patient: PatientCreateNestedOneWithoutInvoicesInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    pharmacyOrder?: PharmacyOrderCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutTenantInput = {
    id?: string
    invoiceNumber: string
    patientId: string
    date?: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    subTotal?: number
    taxAmount?: number
    discountAmount?: number
    totalAmount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    pharmacyOrder?: PharmacyOrderUncheckedCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput>
  }

  export type InvoiceCreateManyTenantInputEnvelope = {
    data: InvoiceCreateManyTenantInput | InvoiceCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceItemCreateWithoutTenantInput = {
    id?: string
    itemType: string
    itemId: string
    description: string
    quantity?: number
    unitPrice: number
    discount?: number
    taxRate?: number
    totalAmount: number
    invoice: InvoiceCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutTenantInput = {
    id?: string
    invoiceId: string
    itemType: string
    itemId: string
    description: string
    quantity?: number
    unitPrice: number
    discount?: number
    taxRate?: number
    totalAmount: number
  }

  export type InvoiceItemCreateOrConnectWithoutTenantInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutTenantInput, InvoiceItemUncheckedCreateWithoutTenantInput>
  }

  export type InvoiceItemCreateManyTenantInputEnvelope = {
    data: InvoiceItemCreateManyTenantInput | InvoiceItemCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type LabOrderCreateWithoutTenantInput = {
    id?: string
    orderNumber: string
    status?: $Enums.LabOrderStatus
    orderDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor?: UserCreateNestedOneWithoutDoctorLabOrdersInput
    patient: PatientCreateNestedOneWithoutLabOrdersInput
    tests?: LabOrderTestCreateNestedManyWithoutOrderInput
    consultation?: TelemedicineConsultationCreateNestedOneWithoutLabOrdersInput
  }

  export type LabOrderUncheckedCreateWithoutTenantInput = {
    id?: string
    orderNumber: string
    patientId: string
    doctorId?: string | null
    status?: $Enums.LabOrderStatus
    orderDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationId?: string | null
    tests?: LabOrderTestUncheckedCreateNestedManyWithoutOrderInput
  }

  export type LabOrderCreateOrConnectWithoutTenantInput = {
    where: LabOrderWhereUniqueInput
    create: XOR<LabOrderCreateWithoutTenantInput, LabOrderUncheckedCreateWithoutTenantInput>
  }

  export type LabOrderCreateManyTenantInputEnvelope = {
    data: LabOrderCreateManyTenantInput | LabOrderCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type LabOrderTestCreateWithoutTenantInput = {
    id?: string
    status?: $Enums.LabTestStatus
    result?: string | null
    resultDate?: Date | string | null
    referenceRange?: string | null
    notes?: string | null
    test: LabTestCreateNestedOneWithoutLabOrdersInput
    order: LabOrderCreateNestedOneWithoutTestsInput
  }

  export type LabOrderTestUncheckedCreateWithoutTenantInput = {
    id?: string
    orderId: string
    testId: string
    status?: $Enums.LabTestStatus
    result?: string | null
    resultDate?: Date | string | null
    referenceRange?: string | null
    notes?: string | null
  }

  export type LabOrderTestCreateOrConnectWithoutTenantInput = {
    where: LabOrderTestWhereUniqueInput
    create: XOR<LabOrderTestCreateWithoutTenantInput, LabOrderTestUncheckedCreateWithoutTenantInput>
  }

  export type LabOrderTestCreateManyTenantInputEnvelope = {
    data: LabOrderTestCreateManyTenantInput | LabOrderTestCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type LabTestCreateWithoutTenantInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    category: string
    price?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    labOrders?: LabOrderTestCreateNestedManyWithoutTestInput
  }

  export type LabTestUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    category: string
    price?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    labOrders?: LabOrderTestUncheckedCreateNestedManyWithoutTestInput
  }

  export type LabTestCreateOrConnectWithoutTenantInput = {
    where: LabTestWhereUniqueInput
    create: XOR<LabTestCreateWithoutTenantInput, LabTestUncheckedCreateWithoutTenantInput>
  }

  export type LabTestCreateManyTenantInputEnvelope = {
    data: LabTestCreateManyTenantInput | LabTestCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type MedicalRecordCreateWithoutTenantInput = {
    id?: string
    recordType: string
    title: string
    description?: string | null
    date?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutMedicalRecordsInput
    doctor?: UserCreateNestedOneWithoutCreatedMedicalRecordsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedMedicalRecordsInput
  }

  export type MedicalRecordUncheckedCreateWithoutTenantInput = {
    id?: string
    patientId: string
    recordType: string
    title: string
    description?: string | null
    date?: Date | string
    doctorId?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalRecordCreateOrConnectWithoutTenantInput = {
    where: MedicalRecordWhereUniqueInput
    create: XOR<MedicalRecordCreateWithoutTenantInput, MedicalRecordUncheckedCreateWithoutTenantInput>
  }

  export type MedicalRecordCreateManyTenantInputEnvelope = {
    data: MedicalRecordCreateManyTenantInput | MedicalRecordCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type MedicationCreateWithoutTenantInput = {
    id?: string
    name: string
    genericName?: string | null
    description?: string | null
    strength?: string | null
    unit?: string | null
    dosageForm?: string | null
    route?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutMedicationInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutMedicationInput
  }

  export type MedicationUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    genericName?: string | null
    description?: string | null
    strength?: string | null
    unit?: string | null
    dosageForm?: string | null
    route?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutMedicationInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutMedicationInput
  }

  export type MedicationCreateOrConnectWithoutTenantInput = {
    where: MedicationWhereUniqueInput
    create: XOR<MedicationCreateWithoutTenantInput, MedicationUncheckedCreateWithoutTenantInput>
  }

  export type MedicationCreateManyTenantInputEnvelope = {
    data: MedicationCreateManyTenantInput | MedicationCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutTenantInput = {
    id?: string
    paymentNumber: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    referenceNumber?: string | null
    notes?: string | null
    status?: $Enums.PaymentStatus
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutTenantInput = {
    id?: string
    paymentNumber: string
    invoiceId: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    referenceNumber?: string | null
    notes?: string | null
    status?: $Enums.PaymentStatus
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutTenantInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput>
  }

  export type PaymentCreateManyTenantInputEnvelope = {
    data: PaymentCreateManyTenantInput | PaymentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PharmacyOrderCreateWithoutTenantInput = {
    id?: string
    orderNumber: string
    status?: $Enums.PharmacyOrderStatus
    orderDate?: Date | string
    dispensedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    doctor?: UserCreateNestedOneWithoutDoctorPrescriptionsInput
    patient: PatientCreateNestedOneWithoutPharmacyOrdersInput
    invoice?: InvoiceCreateNestedOneWithoutPharmacyOrderInput
    items?: PharmacyOrderItemCreateNestedManyWithoutOrderInput
  }

  export type PharmacyOrderUncheckedCreateWithoutTenantInput = {
    id?: string
    orderNumber: string
    patientId: string
    doctorId?: string | null
    status?: $Enums.PharmacyOrderStatus
    orderDate?: Date | string
    dispensedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    items?: PharmacyOrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type PharmacyOrderCreateOrConnectWithoutTenantInput = {
    where: PharmacyOrderWhereUniqueInput
    create: XOR<PharmacyOrderCreateWithoutTenantInput, PharmacyOrderUncheckedCreateWithoutTenantInput>
  }

  export type PharmacyOrderCreateManyTenantInputEnvelope = {
    data: PharmacyOrderCreateManyTenantInput | PharmacyOrderCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PharmacyOrderItemCreateWithoutTenantInput = {
    id?: string
    quantity?: number
    dosage?: string | null
    frequency?: string | null
    duration?: string | null
    instructions?: string | null
    status?: $Enums.PharmacyItemStatus
    medication: MedicationCreateNestedOneWithoutPharmacyOrderItemsInput
    order: PharmacyOrderCreateNestedOneWithoutItemsInput
  }

  export type PharmacyOrderItemUncheckedCreateWithoutTenantInput = {
    id?: string
    orderId: string
    medicationId: string
    quantity?: number
    dosage?: string | null
    frequency?: string | null
    duration?: string | null
    instructions?: string | null
    status?: $Enums.PharmacyItemStatus
  }

  export type PharmacyOrderItemCreateOrConnectWithoutTenantInput = {
    where: PharmacyOrderItemWhereUniqueInput
    create: XOR<PharmacyOrderItemCreateWithoutTenantInput, PharmacyOrderItemUncheckedCreateWithoutTenantInput>
  }

  export type PharmacyOrderItemCreateManyTenantInputEnvelope = {
    data: PharmacyOrderItemCreateManyTenantInput | PharmacyOrderItemCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionCreateWithoutTenantInput = {
    id?: string
    diagnosis?: string | null
    notes?: string | null
    status?: $Enums.PrescriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor: UserCreateNestedOneWithoutPrescriptionsInput
    patient: PatientCreateNestedOneWithoutPrescriptionsInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutTenantInput = {
    id?: string
    patientId: string
    doctorId: string
    diagnosis?: string | null
    notes?: string | null
    status?: $Enums.PrescriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutTenantInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutTenantInput, PrescriptionUncheckedCreateWithoutTenantInput>
  }

  export type PrescriptionCreateManyTenantInputEnvelope = {
    data: PrescriptionCreateManyTenantInput | PrescriptionCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionItemCreateWithoutTenantInput = {
    id?: string
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    isDispensed?: boolean
    patient: PatientCreateNestedOneWithoutPrescriptionItemsInput
    medication: MedicationCreateNestedOneWithoutPrescriptionItemsInput
    prescription: PrescriptionCreateNestedOneWithoutPrescriptionItemsInput
  }

  export type PrescriptionItemUncheckedCreateWithoutTenantInput = {
    id?: string
    prescriptionId: string
    medicationId: string
    patientId: string
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    isDispensed?: boolean
  }

  export type PrescriptionItemCreateOrConnectWithoutTenantInput = {
    where: PrescriptionItemWhereUniqueInput
    create: XOR<PrescriptionItemCreateWithoutTenantInput, PrescriptionItemUncheckedCreateWithoutTenantInput>
  }

  export type PrescriptionItemCreateManyTenantInputEnvelope = {
    data: PrescriptionItemCreateManyTenantInput | PrescriptionItemCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutTenantInput = {
    id?: string
    jti: string
    token: string
    revoked?: boolean
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateWithoutTenantInput = {
    id?: string
    jti: string
    token: string
    userId: string
    revoked?: boolean
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutTenantInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutTenantInput, RefreshTokenUncheckedCreateWithoutTenantInput>
  }

  export type RefreshTokenCreateManyTenantInputEnvelope = {
    data: RefreshTokenCreateManyTenantInput | RefreshTokenCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type SpecialtyCreateWithoutTenantInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialtyUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialtyCreateOrConnectWithoutTenantInput = {
    where: SpecialtyWhereUniqueInput
    create: XOR<SpecialtyCreateWithoutTenantInput, SpecialtyUncheckedCreateWithoutTenantInput>
  }

  export type SpecialtyCreateManyTenantInputEnvelope = {
    data: SpecialtyCreateManyTenantInput | SpecialtyCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type StaffCreateWithoutTenantInput = {
    id?: string
    employeeId?: string | null
    designation?: string | null
    joiningDate?: Date | string | null
    qualification?: string | null
    experience?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutStaffInput
    user: UserCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    employeeId?: string | null
    designation?: string | null
    departmentId?: string | null
    joiningDate?: Date | string | null
    qualification?: string | null
    experience?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffCreateOrConnectWithoutTenantInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutTenantInput, StaffUncheckedCreateWithoutTenantInput>
  }

  export type StaffCreateManyTenantInputEnvelope = {
    data: StaffCreateManyTenantInput | StaffCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    staff?: StaffCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderUncheckedCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    staff?: StaffUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PatientCreateWithoutTenantInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutPatientInput
    studies?: StudyCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutTenantInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutPatientInput
    studies?: StudyUncheckedCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutTenantInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutTenantInput, PatientUncheckedCreateWithoutTenantInput>
  }

  export type PatientCreateManyTenantInputEnvelope = {
    data: PatientCreateManyTenantInput | PatientCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type StudyCreateWithoutTenantInput = {
    id?: string
    studyId: string
    patientName: string
    status?: $Enums.StudyStatus
    studyDate?: Date | string
    priority?: $Enums.Priority | null
    description?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modality: ModalityCreateNestedOneWithoutStudiesInput
    patient: PatientCreateNestedOneWithoutStudiesInput
    series?: SeriesCreateNestedManyWithoutStudyInput
    radReports?: RadReportCreateNestedManyWithoutStudyInput
    radiationDoses?: RadiationDoseCreateNestedManyWithoutStudyInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutStudyInput
  }

  export type StudyUncheckedCreateWithoutTenantInput = {
    id?: string
    studyId: string
    patientId: string
    patientName: string
    modalityId: string
    status?: $Enums.StudyStatus
    studyDate?: Date | string
    priority?: $Enums.Priority | null
    description?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    series?: SeriesUncheckedCreateNestedManyWithoutStudyInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutStudyInput
    radiationDoses?: RadiationDoseUncheckedCreateNestedManyWithoutStudyInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutStudyInput
  }

  export type StudyCreateOrConnectWithoutTenantInput = {
    where: StudyWhereUniqueInput
    create: XOR<StudyCreateWithoutTenantInput, StudyUncheckedCreateWithoutTenantInput>
  }

  export type StudyCreateManyTenantInputEnvelope = {
    data: StudyCreateManyTenantInput | StudyCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type RadReportCreateWithoutTenantInput = {
    id?: string
    reportId: string
    status?: $Enums.ReportStatus
    findings?: string | null
    impression?: string | null
    conclusion?: string | null
    reportDateTime?: Date | string
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    study: StudyCreateNestedOneWithoutRadReportsInput
    reportTemplate?: ReportTemplateCreateNestedOneWithoutRadReportsInput
  }

  export type RadReportUncheckedCreateWithoutTenantInput = {
    id?: string
    reportId: string
    studyId: string
    reportTemplateId?: string | null
    status?: $Enums.ReportStatus
    findings?: string | null
    impression?: string | null
    conclusion?: string | null
    reportDateTime?: Date | string
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadReportCreateOrConnectWithoutTenantInput = {
    where: RadReportWhereUniqueInput
    create: XOR<RadReportCreateWithoutTenantInput, RadReportUncheckedCreateWithoutTenantInput>
  }

  export type RadReportCreateManyTenantInputEnvelope = {
    data: RadReportCreateManyTenantInput | RadReportCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ReportTemplateCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    template: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    radReports?: RadReportCreateNestedManyWithoutReportTemplateInput
  }

  export type ReportTemplateUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    template: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    radReports?: RadReportUncheckedCreateNestedManyWithoutReportTemplateInput
  }

  export type ReportTemplateCreateOrConnectWithoutTenantInput = {
    where: ReportTemplateWhereUniqueInput
    create: XOR<ReportTemplateCreateWithoutTenantInput, ReportTemplateUncheckedCreateWithoutTenantInput>
  }

  export type ReportTemplateCreateManyTenantInputEnvelope = {
    data: ReportTemplateCreateManyTenantInput | ReportTemplateCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TelemedicineConsultationCreateWithoutTenantInput = {
    id?: string
    status?: $Enums.TelemedicineStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    consultationType?: $Enums.ConsultationType
    reason?: string | null
    notes?: string | null
    prescription?: string | null
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    isEmergency?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutTelemedicineConsultationsInput
    doctor?: UserCreateNestedOneWithoutDoctorTelemedicineInput
    videoRoom?: VideoRoomCreateNestedOneWithoutConsultationInput
    labOrders?: LabOrderCreateNestedManyWithoutConsultationInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutConsultationInput
  }

  export type TelemedicineConsultationUncheckedCreateWithoutTenantInput = {
    id?: string
    patientId: string
    doctorId?: string | null
    status?: $Enums.TelemedicineStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    consultationType?: $Enums.ConsultationType
    reason?: string | null
    notes?: string | null
    prescription?: string | null
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    isEmergency?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    videoRoom?: VideoRoomUncheckedCreateNestedOneWithoutConsultationInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutConsultationInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type TelemedicineConsultationCreateOrConnectWithoutTenantInput = {
    where: TelemedicineConsultationWhereUniqueInput
    create: XOR<TelemedicineConsultationCreateWithoutTenantInput, TelemedicineConsultationUncheckedCreateWithoutTenantInput>
  }

  export type TelemedicineConsultationCreateManyTenantInputEnvelope = {
    data: TelemedicineConsultationCreateManyTenantInput | TelemedicineConsultationCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type VideoRoomCreateWithoutTenantInput = {
    id?: string
    roomId: string
    status?: $Enums.VideoRoomStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    maxParticipants?: number
    recordingEnabled?: boolean
    recordingUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    consultation: TelemedicineConsultationCreateNestedOneWithoutVideoRoomInput
    participants?: VideoParticipantCreateNestedManyWithoutRoomInput
    recordings?: VideoRecordingCreateNestedManyWithoutRoomInput
  }

  export type VideoRoomUncheckedCreateWithoutTenantInput = {
    id?: string
    consultationId: string
    roomId: string
    status?: $Enums.VideoRoomStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    maxParticipants?: number
    recordingEnabled?: boolean
    recordingUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: VideoParticipantUncheckedCreateNestedManyWithoutRoomInput
    recordings?: VideoRecordingUncheckedCreateNestedManyWithoutRoomInput
  }

  export type VideoRoomCreateOrConnectWithoutTenantInput = {
    where: VideoRoomWhereUniqueInput
    create: XOR<VideoRoomCreateWithoutTenantInput, VideoRoomUncheckedCreateWithoutTenantInput>
  }

  export type VideoRoomCreateManyTenantInputEnvelope = {
    data: VideoRoomCreateManyTenantInput | VideoRoomCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type VideoParticipantCreateWithoutTenantInput = {
    id?: string
    userId: string
    participantType: $Enums.ParticipantType
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    room: VideoRoomCreateNestedOneWithoutParticipantsInput
  }

  export type VideoParticipantUncheckedCreateWithoutTenantInput = {
    id?: string
    roomId: string
    userId: string
    participantType: $Enums.ParticipantType
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoParticipantCreateOrConnectWithoutTenantInput = {
    where: VideoParticipantWhereUniqueInput
    create: XOR<VideoParticipantCreateWithoutTenantInput, VideoParticipantUncheckedCreateWithoutTenantInput>
  }

  export type VideoParticipantCreateManyTenantInputEnvelope = {
    data: VideoParticipantCreateManyTenantInput | VideoParticipantCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type VideoRecordingCreateWithoutTenantInput = {
    id?: string
    fileName: string
    filePath: string
    fileSize: number
    duration?: number | null
    status?: $Enums.RecordingStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    room: VideoRoomCreateNestedOneWithoutRecordingsInput
  }

  export type VideoRecordingUncheckedCreateWithoutTenantInput = {
    id?: string
    roomId: string
    fileName: string
    filePath: string
    fileSize: number
    duration?: number | null
    status?: $Enums.RecordingStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoRecordingCreateOrConnectWithoutTenantInput = {
    where: VideoRecordingWhereUniqueInput
    create: XOR<VideoRecordingCreateWithoutTenantInput, VideoRecordingUncheckedCreateWithoutTenantInput>
  }

  export type VideoRecordingCreateManyTenantInputEnvelope = {
    data: VideoRecordingCreateManyTenantInput | VideoRecordingCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type VideoMessageCreateWithoutTenantInput = {
    id?: string
    roomId: string
    senderId: string
    message: string
    messageType?: $Enums.MessageType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoMessageUncheckedCreateWithoutTenantInput = {
    id?: string
    roomId: string
    senderId: string
    message: string
    messageType?: $Enums.MessageType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoMessageCreateOrConnectWithoutTenantInput = {
    where: VideoMessageWhereUniqueInput
    create: XOR<VideoMessageCreateWithoutTenantInput, VideoMessageUncheckedCreateWithoutTenantInput>
  }

  export type VideoMessageCreateManyTenantInputEnvelope = {
    data: VideoMessageCreateManyTenantInput | VideoMessageCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type RadiologyOrderCreateWithoutTenantInput = {
    id?: string
    studyType: string
    priority?: $Enums.Priority
    reason?: string | null
    clinicalHistory?: string | null
    status?: $Enums.RadiologyOrderStatus
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    consultation: TelemedicineConsultationCreateNestedOneWithoutRadiologyOrdersInput
    patient: PatientCreateNestedOneWithoutRadiologyOrdersInput
    doctor: UserCreateNestedOneWithoutDoctorRadiologyOrdersInput
    modality: ModalityCreateNestedOneWithoutRadiologyOrdersInput
    study?: StudyCreateNestedOneWithoutRadiologyOrdersInput
  }

  export type RadiologyOrderUncheckedCreateWithoutTenantInput = {
    id?: string
    consultationId: string
    patientId: string
    doctorId: string
    modalityId: string
    studyType: string
    priority?: $Enums.Priority
    reason?: string | null
    clinicalHistory?: string | null
    status?: $Enums.RadiologyOrderStatus
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studyId?: string | null
  }

  export type RadiologyOrderCreateOrConnectWithoutTenantInput = {
    where: RadiologyOrderWhereUniqueInput
    create: XOR<RadiologyOrderCreateWithoutTenantInput, RadiologyOrderUncheckedCreateWithoutTenantInput>
  }

  export type RadiologyOrderCreateManyTenantInputEnvelope = {
    data: RadiologyOrderCreateManyTenantInput | RadiologyOrderCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentUpsertWithWhereUniqueWithoutTenantInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutTenantInput, AppointmentUncheckedUpdateWithoutTenantInput>
    create: XOR<AppointmentCreateWithoutTenantInput, AppointmentUncheckedCreateWithoutTenantInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutTenantInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutTenantInput, AppointmentUncheckedUpdateWithoutTenantInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutTenantInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutTenantInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutTenantInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutTenantInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringNullableFilter<"AuditLog"> | string | null
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    tenantId?: StringFilter<"AuditLog"> | string
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type DepartmentUpsertWithWhereUniqueWithoutTenantInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutTenantInput, DepartmentUncheckedUpdateWithoutTenantInput>
    create: XOR<DepartmentCreateWithoutTenantInput, DepartmentUncheckedCreateWithoutTenantInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutTenantInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutTenantInput, DepartmentUncheckedUpdateWithoutTenantInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutTenantInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutTenantInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    code?: StringNullableFilter<"Department"> | string | null
    description?: StringNullableFilter<"Department"> | string | null
    isActive?: BoolFilter<"Department"> | boolean
    tenantId?: StringFilter<"Department"> | string
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutTenantInput, InvoiceUncheckedUpdateWithoutTenantInput>
    create: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutTenantInput, InvoiceUncheckedUpdateWithoutTenantInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutTenantInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutTenantInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    patientId?: StringFilter<"Invoice"> | string
    date?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    subTotal?: FloatFilter<"Invoice"> | number
    taxAmount?: FloatFilter<"Invoice"> | number
    discountAmount?: FloatFilter<"Invoice"> | number
    totalAmount?: FloatFilter<"Invoice"> | number
    notes?: StringNullableFilter<"Invoice"> | string | null
    tenantId?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    createdBy?: StringNullableFilter<"Invoice"> | string | null
    updatedBy?: StringNullableFilter<"Invoice"> | string | null
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutTenantInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutTenantInput, InvoiceItemUncheckedUpdateWithoutTenantInput>
    create: XOR<InvoiceItemCreateWithoutTenantInput, InvoiceItemUncheckedCreateWithoutTenantInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutTenantInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutTenantInput, InvoiceItemUncheckedUpdateWithoutTenantInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutTenantInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutTenantInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    OR?: InvoiceItemScalarWhereInput[]
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoiceId?: StringFilter<"InvoiceItem"> | string
    itemType?: StringFilter<"InvoiceItem"> | string
    itemId?: StringFilter<"InvoiceItem"> | string
    description?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    unitPrice?: FloatFilter<"InvoiceItem"> | number
    discount?: FloatFilter<"InvoiceItem"> | number
    taxRate?: FloatFilter<"InvoiceItem"> | number
    totalAmount?: FloatFilter<"InvoiceItem"> | number
    tenantId?: StringFilter<"InvoiceItem"> | string
  }

  export type LabOrderUpsertWithWhereUniqueWithoutTenantInput = {
    where: LabOrderWhereUniqueInput
    update: XOR<LabOrderUpdateWithoutTenantInput, LabOrderUncheckedUpdateWithoutTenantInput>
    create: XOR<LabOrderCreateWithoutTenantInput, LabOrderUncheckedCreateWithoutTenantInput>
  }

  export type LabOrderUpdateWithWhereUniqueWithoutTenantInput = {
    where: LabOrderWhereUniqueInput
    data: XOR<LabOrderUpdateWithoutTenantInput, LabOrderUncheckedUpdateWithoutTenantInput>
  }

  export type LabOrderUpdateManyWithWhereWithoutTenantInput = {
    where: LabOrderScalarWhereInput
    data: XOR<LabOrderUpdateManyMutationInput, LabOrderUncheckedUpdateManyWithoutTenantInput>
  }

  export type LabOrderScalarWhereInput = {
    AND?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
    OR?: LabOrderScalarWhereInput[]
    NOT?: LabOrderScalarWhereInput | LabOrderScalarWhereInput[]
    id?: StringFilter<"LabOrder"> | string
    orderNumber?: StringFilter<"LabOrder"> | string
    patientId?: StringFilter<"LabOrder"> | string
    doctorId?: StringNullableFilter<"LabOrder"> | string | null
    status?: EnumLabOrderStatusFilter<"LabOrder"> | $Enums.LabOrderStatus
    orderDate?: DateTimeFilter<"LabOrder"> | Date | string
    completedDate?: DateTimeNullableFilter<"LabOrder"> | Date | string | null
    notes?: StringNullableFilter<"LabOrder"> | string | null
    tenantId?: StringFilter<"LabOrder"> | string
    createdAt?: DateTimeFilter<"LabOrder"> | Date | string
    updatedAt?: DateTimeFilter<"LabOrder"> | Date | string
    consultationId?: StringNullableFilter<"LabOrder"> | string | null
  }

  export type LabOrderTestUpsertWithWhereUniqueWithoutTenantInput = {
    where: LabOrderTestWhereUniqueInput
    update: XOR<LabOrderTestUpdateWithoutTenantInput, LabOrderTestUncheckedUpdateWithoutTenantInput>
    create: XOR<LabOrderTestCreateWithoutTenantInput, LabOrderTestUncheckedCreateWithoutTenantInput>
  }

  export type LabOrderTestUpdateWithWhereUniqueWithoutTenantInput = {
    where: LabOrderTestWhereUniqueInput
    data: XOR<LabOrderTestUpdateWithoutTenantInput, LabOrderTestUncheckedUpdateWithoutTenantInput>
  }

  export type LabOrderTestUpdateManyWithWhereWithoutTenantInput = {
    where: LabOrderTestScalarWhereInput
    data: XOR<LabOrderTestUpdateManyMutationInput, LabOrderTestUncheckedUpdateManyWithoutTenantInput>
  }

  export type LabOrderTestScalarWhereInput = {
    AND?: LabOrderTestScalarWhereInput | LabOrderTestScalarWhereInput[]
    OR?: LabOrderTestScalarWhereInput[]
    NOT?: LabOrderTestScalarWhereInput | LabOrderTestScalarWhereInput[]
    id?: StringFilter<"LabOrderTest"> | string
    orderId?: StringFilter<"LabOrderTest"> | string
    testId?: StringFilter<"LabOrderTest"> | string
    status?: EnumLabTestStatusFilter<"LabOrderTest"> | $Enums.LabTestStatus
    result?: StringNullableFilter<"LabOrderTest"> | string | null
    resultDate?: DateTimeNullableFilter<"LabOrderTest"> | Date | string | null
    referenceRange?: StringNullableFilter<"LabOrderTest"> | string | null
    notes?: StringNullableFilter<"LabOrderTest"> | string | null
    tenantId?: StringFilter<"LabOrderTest"> | string
  }

  export type LabTestUpsertWithWhereUniqueWithoutTenantInput = {
    where: LabTestWhereUniqueInput
    update: XOR<LabTestUpdateWithoutTenantInput, LabTestUncheckedUpdateWithoutTenantInput>
    create: XOR<LabTestCreateWithoutTenantInput, LabTestUncheckedCreateWithoutTenantInput>
  }

  export type LabTestUpdateWithWhereUniqueWithoutTenantInput = {
    where: LabTestWhereUniqueInput
    data: XOR<LabTestUpdateWithoutTenantInput, LabTestUncheckedUpdateWithoutTenantInput>
  }

  export type LabTestUpdateManyWithWhereWithoutTenantInput = {
    where: LabTestScalarWhereInput
    data: XOR<LabTestUpdateManyMutationInput, LabTestUncheckedUpdateManyWithoutTenantInput>
  }

  export type LabTestScalarWhereInput = {
    AND?: LabTestScalarWhereInput | LabTestScalarWhereInput[]
    OR?: LabTestScalarWhereInput[]
    NOT?: LabTestScalarWhereInput | LabTestScalarWhereInput[]
    id?: StringFilter<"LabTest"> | string
    name?: StringFilter<"LabTest"> | string
    code?: StringFilter<"LabTest"> | string
    description?: StringNullableFilter<"LabTest"> | string | null
    category?: StringFilter<"LabTest"> | string
    price?: FloatNullableFilter<"LabTest"> | number | null
    isActive?: BoolFilter<"LabTest"> | boolean
    tenantId?: StringFilter<"LabTest"> | string
    createdAt?: DateTimeFilter<"LabTest"> | Date | string
    updatedAt?: DateTimeFilter<"LabTest"> | Date | string
  }

  export type MedicalRecordUpsertWithWhereUniqueWithoutTenantInput = {
    where: MedicalRecordWhereUniqueInput
    update: XOR<MedicalRecordUpdateWithoutTenantInput, MedicalRecordUncheckedUpdateWithoutTenantInput>
    create: XOR<MedicalRecordCreateWithoutTenantInput, MedicalRecordUncheckedCreateWithoutTenantInput>
  }

  export type MedicalRecordUpdateWithWhereUniqueWithoutTenantInput = {
    where: MedicalRecordWhereUniqueInput
    data: XOR<MedicalRecordUpdateWithoutTenantInput, MedicalRecordUncheckedUpdateWithoutTenantInput>
  }

  export type MedicalRecordUpdateManyWithWhereWithoutTenantInput = {
    where: MedicalRecordScalarWhereInput
    data: XOR<MedicalRecordUpdateManyMutationInput, MedicalRecordUncheckedUpdateManyWithoutTenantInput>
  }

  export type MedicalRecordScalarWhereInput = {
    AND?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
    OR?: MedicalRecordScalarWhereInput[]
    NOT?: MedicalRecordScalarWhereInput | MedicalRecordScalarWhereInput[]
    id?: StringFilter<"MedicalRecord"> | string
    patientId?: StringFilter<"MedicalRecord"> | string
    recordType?: StringFilter<"MedicalRecord"> | string
    title?: StringFilter<"MedicalRecord"> | string
    description?: StringNullableFilter<"MedicalRecord"> | string | null
    date?: DateTimeFilter<"MedicalRecord"> | Date | string
    doctorId?: StringNullableFilter<"MedicalRecord"> | string | null
    updatedById?: StringNullableFilter<"MedicalRecord"> | string | null
    isActive?: BoolFilter<"MedicalRecord"> | boolean
    tenantId?: StringFilter<"MedicalRecord"> | string
    createdAt?: DateTimeFilter<"MedicalRecord"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalRecord"> | Date | string
  }

  export type MedicationUpsertWithWhereUniqueWithoutTenantInput = {
    where: MedicationWhereUniqueInput
    update: XOR<MedicationUpdateWithoutTenantInput, MedicationUncheckedUpdateWithoutTenantInput>
    create: XOR<MedicationCreateWithoutTenantInput, MedicationUncheckedCreateWithoutTenantInput>
  }

  export type MedicationUpdateWithWhereUniqueWithoutTenantInput = {
    where: MedicationWhereUniqueInput
    data: XOR<MedicationUpdateWithoutTenantInput, MedicationUncheckedUpdateWithoutTenantInput>
  }

  export type MedicationUpdateManyWithWhereWithoutTenantInput = {
    where: MedicationScalarWhereInput
    data: XOR<MedicationUpdateManyMutationInput, MedicationUncheckedUpdateManyWithoutTenantInput>
  }

  export type MedicationScalarWhereInput = {
    AND?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
    OR?: MedicationScalarWhereInput[]
    NOT?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
    id?: StringFilter<"Medication"> | string
    name?: StringFilter<"Medication"> | string
    genericName?: StringNullableFilter<"Medication"> | string | null
    description?: StringNullableFilter<"Medication"> | string | null
    strength?: StringNullableFilter<"Medication"> | string | null
    unit?: StringNullableFilter<"Medication"> | string | null
    dosageForm?: StringNullableFilter<"Medication"> | string | null
    route?: StringNullableFilter<"Medication"> | string | null
    schedule?: JsonNullableFilter<"Medication">
    isActive?: BoolFilter<"Medication"> | boolean
    tenantId?: StringFilter<"Medication"> | string
    createdAt?: DateTimeFilter<"Medication"> | Date | string
    updatedAt?: DateTimeFilter<"Medication"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutTenantInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutTenantInput, PaymentUncheckedUpdateWithoutTenantInput>
    create: XOR<PaymentCreateWithoutTenantInput, PaymentUncheckedCreateWithoutTenantInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutTenantInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutTenantInput, PaymentUncheckedUpdateWithoutTenantInput>
  }

  export type PaymentUpdateManyWithWhereWithoutTenantInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutTenantInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    paymentNumber?: StringFilter<"Payment"> | string
    invoiceId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    referenceNumber?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    tenantId?: StringFilter<"Payment"> | string
    createdBy?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type PharmacyOrderUpsertWithWhereUniqueWithoutTenantInput = {
    where: PharmacyOrderWhereUniqueInput
    update: XOR<PharmacyOrderUpdateWithoutTenantInput, PharmacyOrderUncheckedUpdateWithoutTenantInput>
    create: XOR<PharmacyOrderCreateWithoutTenantInput, PharmacyOrderUncheckedCreateWithoutTenantInput>
  }

  export type PharmacyOrderUpdateWithWhereUniqueWithoutTenantInput = {
    where: PharmacyOrderWhereUniqueInput
    data: XOR<PharmacyOrderUpdateWithoutTenantInput, PharmacyOrderUncheckedUpdateWithoutTenantInput>
  }

  export type PharmacyOrderUpdateManyWithWhereWithoutTenantInput = {
    where: PharmacyOrderScalarWhereInput
    data: XOR<PharmacyOrderUpdateManyMutationInput, PharmacyOrderUncheckedUpdateManyWithoutTenantInput>
  }

  export type PharmacyOrderScalarWhereInput = {
    AND?: PharmacyOrderScalarWhereInput | PharmacyOrderScalarWhereInput[]
    OR?: PharmacyOrderScalarWhereInput[]
    NOT?: PharmacyOrderScalarWhereInput | PharmacyOrderScalarWhereInput[]
    id?: StringFilter<"PharmacyOrder"> | string
    orderNumber?: StringFilter<"PharmacyOrder"> | string
    patientId?: StringFilter<"PharmacyOrder"> | string
    doctorId?: StringNullableFilter<"PharmacyOrder"> | string | null
    status?: EnumPharmacyOrderStatusFilter<"PharmacyOrder"> | $Enums.PharmacyOrderStatus
    orderDate?: DateTimeFilter<"PharmacyOrder"> | Date | string
    dispensedDate?: DateTimeNullableFilter<"PharmacyOrder"> | Date | string | null
    notes?: StringNullableFilter<"PharmacyOrder"> | string | null
    tenantId?: StringFilter<"PharmacyOrder"> | string
    createdAt?: DateTimeFilter<"PharmacyOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PharmacyOrder"> | Date | string
    invoiceId?: StringNullableFilter<"PharmacyOrder"> | string | null
    createdBy?: StringNullableFilter<"PharmacyOrder"> | string | null
    updatedBy?: StringNullableFilter<"PharmacyOrder"> | string | null
  }

  export type PharmacyOrderItemUpsertWithWhereUniqueWithoutTenantInput = {
    where: PharmacyOrderItemWhereUniqueInput
    update: XOR<PharmacyOrderItemUpdateWithoutTenantInput, PharmacyOrderItemUncheckedUpdateWithoutTenantInput>
    create: XOR<PharmacyOrderItemCreateWithoutTenantInput, PharmacyOrderItemUncheckedCreateWithoutTenantInput>
  }

  export type PharmacyOrderItemUpdateWithWhereUniqueWithoutTenantInput = {
    where: PharmacyOrderItemWhereUniqueInput
    data: XOR<PharmacyOrderItemUpdateWithoutTenantInput, PharmacyOrderItemUncheckedUpdateWithoutTenantInput>
  }

  export type PharmacyOrderItemUpdateManyWithWhereWithoutTenantInput = {
    where: PharmacyOrderItemScalarWhereInput
    data: XOR<PharmacyOrderItemUpdateManyMutationInput, PharmacyOrderItemUncheckedUpdateManyWithoutTenantInput>
  }

  export type PharmacyOrderItemScalarWhereInput = {
    AND?: PharmacyOrderItemScalarWhereInput | PharmacyOrderItemScalarWhereInput[]
    OR?: PharmacyOrderItemScalarWhereInput[]
    NOT?: PharmacyOrderItemScalarWhereInput | PharmacyOrderItemScalarWhereInput[]
    id?: StringFilter<"PharmacyOrderItem"> | string
    orderId?: StringFilter<"PharmacyOrderItem"> | string
    medicationId?: StringFilter<"PharmacyOrderItem"> | string
    quantity?: IntFilter<"PharmacyOrderItem"> | number
    dosage?: StringNullableFilter<"PharmacyOrderItem"> | string | null
    frequency?: StringNullableFilter<"PharmacyOrderItem"> | string | null
    duration?: StringNullableFilter<"PharmacyOrderItem"> | string | null
    instructions?: StringNullableFilter<"PharmacyOrderItem"> | string | null
    status?: EnumPharmacyItemStatusFilter<"PharmacyOrderItem"> | $Enums.PharmacyItemStatus
    tenantId?: StringFilter<"PharmacyOrderItem"> | string
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutTenantInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutTenantInput, PrescriptionUncheckedUpdateWithoutTenantInput>
    create: XOR<PrescriptionCreateWithoutTenantInput, PrescriptionUncheckedCreateWithoutTenantInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutTenantInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutTenantInput, PrescriptionUncheckedUpdateWithoutTenantInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutTenantInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutTenantInput>
  }

  export type PrescriptionScalarWhereInput = {
    AND?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
    OR?: PrescriptionScalarWhereInput[]
    NOT?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
    id?: StringFilter<"Prescription"> | string
    patientId?: StringFilter<"Prescription"> | string
    doctorId?: StringFilter<"Prescription"> | string
    diagnosis?: StringNullableFilter<"Prescription"> | string | null
    notes?: StringNullableFilter<"Prescription"> | string | null
    status?: EnumPrescriptionStatusFilter<"Prescription"> | $Enums.PrescriptionStatus
    tenantId?: StringFilter<"Prescription"> | string
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    updatedAt?: DateTimeFilter<"Prescription"> | Date | string
  }

  export type PrescriptionItemUpsertWithWhereUniqueWithoutTenantInput = {
    where: PrescriptionItemWhereUniqueInput
    update: XOR<PrescriptionItemUpdateWithoutTenantInput, PrescriptionItemUncheckedUpdateWithoutTenantInput>
    create: XOR<PrescriptionItemCreateWithoutTenantInput, PrescriptionItemUncheckedCreateWithoutTenantInput>
  }

  export type PrescriptionItemUpdateWithWhereUniqueWithoutTenantInput = {
    where: PrescriptionItemWhereUniqueInput
    data: XOR<PrescriptionItemUpdateWithoutTenantInput, PrescriptionItemUncheckedUpdateWithoutTenantInput>
  }

  export type PrescriptionItemUpdateManyWithWhereWithoutTenantInput = {
    where: PrescriptionItemScalarWhereInput
    data: XOR<PrescriptionItemUpdateManyMutationInput, PrescriptionItemUncheckedUpdateManyWithoutTenantInput>
  }

  export type PrescriptionItemScalarWhereInput = {
    AND?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
    OR?: PrescriptionItemScalarWhereInput[]
    NOT?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
    id?: StringFilter<"PrescriptionItem"> | string
    prescriptionId?: StringFilter<"PrescriptionItem"> | string
    medicationId?: StringFilter<"PrescriptionItem"> | string
    patientId?: StringFilter<"PrescriptionItem"> | string
    dosage?: StringFilter<"PrescriptionItem"> | string
    frequency?: StringFilter<"PrescriptionItem"> | string
    duration?: StringFilter<"PrescriptionItem"> | string
    instructions?: StringNullableFilter<"PrescriptionItem"> | string | null
    isDispensed?: BoolFilter<"PrescriptionItem"> | boolean
    tenantId?: StringFilter<"PrescriptionItem"> | string
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutTenantInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutTenantInput, RefreshTokenUncheckedUpdateWithoutTenantInput>
    create: XOR<RefreshTokenCreateWithoutTenantInput, RefreshTokenUncheckedCreateWithoutTenantInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutTenantInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutTenantInput, RefreshTokenUncheckedUpdateWithoutTenantInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutTenantInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutTenantInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    jti?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    ipAddress?: StringNullableFilter<"RefreshToken"> | string | null
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    tenantId?: StringFilter<"RefreshToken"> | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type SpecialtyUpsertWithWhereUniqueWithoutTenantInput = {
    where: SpecialtyWhereUniqueInput
    update: XOR<SpecialtyUpdateWithoutTenantInput, SpecialtyUncheckedUpdateWithoutTenantInput>
    create: XOR<SpecialtyCreateWithoutTenantInput, SpecialtyUncheckedCreateWithoutTenantInput>
  }

  export type SpecialtyUpdateWithWhereUniqueWithoutTenantInput = {
    where: SpecialtyWhereUniqueInput
    data: XOR<SpecialtyUpdateWithoutTenantInput, SpecialtyUncheckedUpdateWithoutTenantInput>
  }

  export type SpecialtyUpdateManyWithWhereWithoutTenantInput = {
    where: SpecialtyScalarWhereInput
    data: XOR<SpecialtyUpdateManyMutationInput, SpecialtyUncheckedUpdateManyWithoutTenantInput>
  }

  export type SpecialtyScalarWhereInput = {
    AND?: SpecialtyScalarWhereInput | SpecialtyScalarWhereInput[]
    OR?: SpecialtyScalarWhereInput[]
    NOT?: SpecialtyScalarWhereInput | SpecialtyScalarWhereInput[]
    id?: StringFilter<"Specialty"> | string
    name?: StringFilter<"Specialty"> | string
    code?: StringNullableFilter<"Specialty"> | string | null
    description?: StringNullableFilter<"Specialty"> | string | null
    isActive?: BoolFilter<"Specialty"> | boolean
    tenantId?: StringFilter<"Specialty"> | string
    createdAt?: DateTimeFilter<"Specialty"> | Date | string
    updatedAt?: DateTimeFilter<"Specialty"> | Date | string
  }

  export type StaffUpsertWithWhereUniqueWithoutTenantInput = {
    where: StaffWhereUniqueInput
    update: XOR<StaffUpdateWithoutTenantInput, StaffUncheckedUpdateWithoutTenantInput>
    create: XOR<StaffCreateWithoutTenantInput, StaffUncheckedCreateWithoutTenantInput>
  }

  export type StaffUpdateWithWhereUniqueWithoutTenantInput = {
    where: StaffWhereUniqueInput
    data: XOR<StaffUpdateWithoutTenantInput, StaffUncheckedUpdateWithoutTenantInput>
  }

  export type StaffUpdateManyWithWhereWithoutTenantInput = {
    where: StaffScalarWhereInput
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    specialization?: StringNullableFilter<"User"> | string | null
    experience?: IntNullableFilter<"User"> | number | null
    licenseNumber?: StringNullableFilter<"User"> | string | null
    signature?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    tenantId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type PatientUpsertWithWhereUniqueWithoutTenantInput = {
    where: PatientWhereUniqueInput
    update: XOR<PatientUpdateWithoutTenantInput, PatientUncheckedUpdateWithoutTenantInput>
    create: XOR<PatientCreateWithoutTenantInput, PatientUncheckedCreateWithoutTenantInput>
  }

  export type PatientUpdateWithWhereUniqueWithoutTenantInput = {
    where: PatientWhereUniqueInput
    data: XOR<PatientUpdateWithoutTenantInput, PatientUncheckedUpdateWithoutTenantInput>
  }

  export type PatientUpdateManyWithWhereWithoutTenantInput = {
    where: PatientScalarWhereInput
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyWithoutTenantInput>
  }

  export type PatientScalarWhereInput = {
    AND?: PatientScalarWhereInput | PatientScalarWhereInput[]
    OR?: PatientScalarWhereInput[]
    NOT?: PatientScalarWhereInput | PatientScalarWhereInput[]
    id?: StringFilter<"Patient"> | string
    medicalRecordNumber?: StringFilter<"Patient"> | string
    registrationNumber?: StringNullableFilter<"Patient"> | string | null
    externalId?: StringNullableFilter<"Patient"> | string | null
    firstName?: StringFilter<"Patient"> | string
    middleName?: StringNullableFilter<"Patient"> | string | null
    lastName?: StringFilter<"Patient"> | string
    dateOfBirth?: DateTimeNullableFilter<"Patient"> | Date | string | null
    gender?: EnumGenderNullableFilter<"Patient"> | $Enums.Gender | null
    bloodType?: EnumBloodTypeNullableFilter<"Patient"> | $Enums.BloodType | null
    maritalStatus?: EnumMaritalStatusNullableFilter<"Patient"> | $Enums.MaritalStatus | null
    email?: StringNullableFilter<"Patient"> | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    address?: StringNullableFilter<"Patient"> | string | null
    city?: StringNullableFilter<"Patient"> | string | null
    state?: StringNullableFilter<"Patient"> | string | null
    country?: StringNullableFilter<"Patient"> | string | null
    pincode?: StringNullableFilter<"Patient"> | string | null
    phoneVerified?: BoolFilter<"Patient"> | boolean
    emailVerified?: BoolFilter<"Patient"> | boolean
    allergies?: JsonNullableFilter<"Patient">
    chronicConditions?: JsonNullableFilter<"Patient">
    currentMedications?: JsonNullableFilter<"Patient">
    knownAllergies?: JsonNullableFilter<"Patient">
    familyHistory?: JsonNullableFilter<"Patient">
    insuranceProvider?: StringNullableFilter<"Patient"> | string | null
    insuranceId?: StringNullableFilter<"Patient"> | string | null
    insuranceGroup?: StringNullableFilter<"Patient"> | string | null
    insuranceValidUntil?: DateTimeNullableFilter<"Patient"> | Date | string | null
    insuranceType?: EnumInsuranceTypeNullableFilter<"Patient"> | $Enums.InsuranceType | null
    tenantId?: StringFilter<"Patient"> | string
    createdBy?: StringNullableFilter<"Patient"> | string | null
    updatedBy?: StringNullableFilter<"Patient"> | string | null
    isActive?: BoolFilter<"Patient"> | boolean
    isVerified?: BoolFilter<"Patient"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Patient"> | Date | string | null
  }

  export type StudyUpsertWithWhereUniqueWithoutTenantInput = {
    where: StudyWhereUniqueInput
    update: XOR<StudyUpdateWithoutTenantInput, StudyUncheckedUpdateWithoutTenantInput>
    create: XOR<StudyCreateWithoutTenantInput, StudyUncheckedCreateWithoutTenantInput>
  }

  export type StudyUpdateWithWhereUniqueWithoutTenantInput = {
    where: StudyWhereUniqueInput
    data: XOR<StudyUpdateWithoutTenantInput, StudyUncheckedUpdateWithoutTenantInput>
  }

  export type StudyUpdateManyWithWhereWithoutTenantInput = {
    where: StudyScalarWhereInput
    data: XOR<StudyUpdateManyMutationInput, StudyUncheckedUpdateManyWithoutTenantInput>
  }

  export type StudyScalarWhereInput = {
    AND?: StudyScalarWhereInput | StudyScalarWhereInput[]
    OR?: StudyScalarWhereInput[]
    NOT?: StudyScalarWhereInput | StudyScalarWhereInput[]
    id?: StringFilter<"Study"> | string
    studyId?: StringFilter<"Study"> | string
    patientId?: StringFilter<"Study"> | string
    patientName?: StringFilter<"Study"> | string
    modalityId?: StringFilter<"Study"> | string
    status?: EnumStudyStatusFilter<"Study"> | $Enums.StudyStatus
    studyDate?: DateTimeFilter<"Study"> | Date | string
    priority?: EnumPriorityNullableFilter<"Study"> | $Enums.Priority | null
    description?: StringNullableFilter<"Study"> | string | null
    notes?: StringNullableFilter<"Study"> | string | null
    isActive?: BoolFilter<"Study"> | boolean
    tenantId?: StringFilter<"Study"> | string
    createdAt?: DateTimeFilter<"Study"> | Date | string
    updatedAt?: DateTimeFilter<"Study"> | Date | string
  }

  export type RadReportUpsertWithWhereUniqueWithoutTenantInput = {
    where: RadReportWhereUniqueInput
    update: XOR<RadReportUpdateWithoutTenantInput, RadReportUncheckedUpdateWithoutTenantInput>
    create: XOR<RadReportCreateWithoutTenantInput, RadReportUncheckedCreateWithoutTenantInput>
  }

  export type RadReportUpdateWithWhereUniqueWithoutTenantInput = {
    where: RadReportWhereUniqueInput
    data: XOR<RadReportUpdateWithoutTenantInput, RadReportUncheckedUpdateWithoutTenantInput>
  }

  export type RadReportUpdateManyWithWhereWithoutTenantInput = {
    where: RadReportScalarWhereInput
    data: XOR<RadReportUpdateManyMutationInput, RadReportUncheckedUpdateManyWithoutTenantInput>
  }

  export type RadReportScalarWhereInput = {
    AND?: RadReportScalarWhereInput | RadReportScalarWhereInput[]
    OR?: RadReportScalarWhereInput[]
    NOT?: RadReportScalarWhereInput | RadReportScalarWhereInput[]
    id?: StringFilter<"RadReport"> | string
    reportId?: StringFilter<"RadReport"> | string
    studyId?: StringFilter<"RadReport"> | string
    reportTemplateId?: StringNullableFilter<"RadReport"> | string | null
    status?: EnumReportStatusFilter<"RadReport"> | $Enums.ReportStatus
    findings?: StringNullableFilter<"RadReport"> | string | null
    impression?: StringNullableFilter<"RadReport"> | string | null
    conclusion?: StringNullableFilter<"RadReport"> | string | null
    reportDateTime?: DateTimeFilter<"RadReport"> | Date | string
    verifiedBy?: StringNullableFilter<"RadReport"> | string | null
    verifiedAt?: DateTimeNullableFilter<"RadReport"> | Date | string | null
    isActive?: BoolFilter<"RadReport"> | boolean
    tenantId?: StringFilter<"RadReport"> | string
    createdAt?: DateTimeFilter<"RadReport"> | Date | string
    updatedAt?: DateTimeFilter<"RadReport"> | Date | string
  }

  export type ReportTemplateUpsertWithWhereUniqueWithoutTenantInput = {
    where: ReportTemplateWhereUniqueInput
    update: XOR<ReportTemplateUpdateWithoutTenantInput, ReportTemplateUncheckedUpdateWithoutTenantInput>
    create: XOR<ReportTemplateCreateWithoutTenantInput, ReportTemplateUncheckedCreateWithoutTenantInput>
  }

  export type ReportTemplateUpdateWithWhereUniqueWithoutTenantInput = {
    where: ReportTemplateWhereUniqueInput
    data: XOR<ReportTemplateUpdateWithoutTenantInput, ReportTemplateUncheckedUpdateWithoutTenantInput>
  }

  export type ReportTemplateUpdateManyWithWhereWithoutTenantInput = {
    where: ReportTemplateScalarWhereInput
    data: XOR<ReportTemplateUpdateManyMutationInput, ReportTemplateUncheckedUpdateManyWithoutTenantInput>
  }

  export type ReportTemplateScalarWhereInput = {
    AND?: ReportTemplateScalarWhereInput | ReportTemplateScalarWhereInput[]
    OR?: ReportTemplateScalarWhereInput[]
    NOT?: ReportTemplateScalarWhereInput | ReportTemplateScalarWhereInput[]
    id?: StringFilter<"ReportTemplate"> | string
    name?: StringFilter<"ReportTemplate"> | string
    description?: StringNullableFilter<"ReportTemplate"> | string | null
    template?: StringFilter<"ReportTemplate"> | string
    isActive?: BoolFilter<"ReportTemplate"> | boolean
    tenantId?: StringFilter<"ReportTemplate"> | string
    createdAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ReportTemplate"> | Date | string
  }

  export type TelemedicineConsultationUpsertWithWhereUniqueWithoutTenantInput = {
    where: TelemedicineConsultationWhereUniqueInput
    update: XOR<TelemedicineConsultationUpdateWithoutTenantInput, TelemedicineConsultationUncheckedUpdateWithoutTenantInput>
    create: XOR<TelemedicineConsultationCreateWithoutTenantInput, TelemedicineConsultationUncheckedCreateWithoutTenantInput>
  }

  export type TelemedicineConsultationUpdateWithWhereUniqueWithoutTenantInput = {
    where: TelemedicineConsultationWhereUniqueInput
    data: XOR<TelemedicineConsultationUpdateWithoutTenantInput, TelemedicineConsultationUncheckedUpdateWithoutTenantInput>
  }

  export type TelemedicineConsultationUpdateManyWithWhereWithoutTenantInput = {
    where: TelemedicineConsultationScalarWhereInput
    data: XOR<TelemedicineConsultationUpdateManyMutationInput, TelemedicineConsultationUncheckedUpdateManyWithoutTenantInput>
  }

  export type TelemedicineConsultationScalarWhereInput = {
    AND?: TelemedicineConsultationScalarWhereInput | TelemedicineConsultationScalarWhereInput[]
    OR?: TelemedicineConsultationScalarWhereInput[]
    NOT?: TelemedicineConsultationScalarWhereInput | TelemedicineConsultationScalarWhereInput[]
    id?: StringFilter<"TelemedicineConsultation"> | string
    patientId?: StringFilter<"TelemedicineConsultation"> | string
    doctorId?: StringNullableFilter<"TelemedicineConsultation"> | string | null
    status?: EnumTelemedicineStatusFilter<"TelemedicineConsultation"> | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFilter<"TelemedicineConsultation"> | Date | string
    startedAt?: DateTimeNullableFilter<"TelemedicineConsultation"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"TelemedicineConsultation"> | Date | string | null
    duration?: IntNullableFilter<"TelemedicineConsultation"> | number | null
    consultationType?: EnumConsultationTypeFilter<"TelemedicineConsultation"> | $Enums.ConsultationType
    reason?: StringNullableFilter<"TelemedicineConsultation"> | string | null
    notes?: StringNullableFilter<"TelemedicineConsultation"> | string | null
    prescription?: StringNullableFilter<"TelemedicineConsultation"> | string | null
    followUpRequired?: BoolFilter<"TelemedicineConsultation"> | boolean
    followUpDate?: DateTimeNullableFilter<"TelemedicineConsultation"> | Date | string | null
    isEmergency?: BoolFilter<"TelemedicineConsultation"> | boolean
    isActive?: BoolFilter<"TelemedicineConsultation"> | boolean
    tenantId?: StringFilter<"TelemedicineConsultation"> | string
    createdAt?: DateTimeFilter<"TelemedicineConsultation"> | Date | string
    updatedAt?: DateTimeFilter<"TelemedicineConsultation"> | Date | string
  }

  export type VideoRoomUpsertWithWhereUniqueWithoutTenantInput = {
    where: VideoRoomWhereUniqueInput
    update: XOR<VideoRoomUpdateWithoutTenantInput, VideoRoomUncheckedUpdateWithoutTenantInput>
    create: XOR<VideoRoomCreateWithoutTenantInput, VideoRoomUncheckedCreateWithoutTenantInput>
  }

  export type VideoRoomUpdateWithWhereUniqueWithoutTenantInput = {
    where: VideoRoomWhereUniqueInput
    data: XOR<VideoRoomUpdateWithoutTenantInput, VideoRoomUncheckedUpdateWithoutTenantInput>
  }

  export type VideoRoomUpdateManyWithWhereWithoutTenantInput = {
    where: VideoRoomScalarWhereInput
    data: XOR<VideoRoomUpdateManyMutationInput, VideoRoomUncheckedUpdateManyWithoutTenantInput>
  }

  export type VideoRoomScalarWhereInput = {
    AND?: VideoRoomScalarWhereInput | VideoRoomScalarWhereInput[]
    OR?: VideoRoomScalarWhereInput[]
    NOT?: VideoRoomScalarWhereInput | VideoRoomScalarWhereInput[]
    id?: StringFilter<"VideoRoom"> | string
    consultationId?: StringFilter<"VideoRoom"> | string
    roomId?: StringFilter<"VideoRoom"> | string
    status?: EnumVideoRoomStatusFilter<"VideoRoom"> | $Enums.VideoRoomStatus
    startedAt?: DateTimeNullableFilter<"VideoRoom"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"VideoRoom"> | Date | string | null
    maxParticipants?: IntFilter<"VideoRoom"> | number
    recordingEnabled?: BoolFilter<"VideoRoom"> | boolean
    recordingUrl?: StringNullableFilter<"VideoRoom"> | string | null
    isActive?: BoolFilter<"VideoRoom"> | boolean
    tenantId?: StringFilter<"VideoRoom"> | string
    createdAt?: DateTimeFilter<"VideoRoom"> | Date | string
    updatedAt?: DateTimeFilter<"VideoRoom"> | Date | string
  }

  export type VideoParticipantUpsertWithWhereUniqueWithoutTenantInput = {
    where: VideoParticipantWhereUniqueInput
    update: XOR<VideoParticipantUpdateWithoutTenantInput, VideoParticipantUncheckedUpdateWithoutTenantInput>
    create: XOR<VideoParticipantCreateWithoutTenantInput, VideoParticipantUncheckedCreateWithoutTenantInput>
  }

  export type VideoParticipantUpdateWithWhereUniqueWithoutTenantInput = {
    where: VideoParticipantWhereUniqueInput
    data: XOR<VideoParticipantUpdateWithoutTenantInput, VideoParticipantUncheckedUpdateWithoutTenantInput>
  }

  export type VideoParticipantUpdateManyWithWhereWithoutTenantInput = {
    where: VideoParticipantScalarWhereInput
    data: XOR<VideoParticipantUpdateManyMutationInput, VideoParticipantUncheckedUpdateManyWithoutTenantInput>
  }

  export type VideoParticipantScalarWhereInput = {
    AND?: VideoParticipantScalarWhereInput | VideoParticipantScalarWhereInput[]
    OR?: VideoParticipantScalarWhereInput[]
    NOT?: VideoParticipantScalarWhereInput | VideoParticipantScalarWhereInput[]
    id?: StringFilter<"VideoParticipant"> | string
    roomId?: StringFilter<"VideoParticipant"> | string
    userId?: StringFilter<"VideoParticipant"> | string
    participantType?: EnumParticipantTypeFilter<"VideoParticipant"> | $Enums.ParticipantType
    joinedAt?: DateTimeNullableFilter<"VideoParticipant"> | Date | string | null
    leftAt?: DateTimeNullableFilter<"VideoParticipant"> | Date | string | null
    isActive?: BoolFilter<"VideoParticipant"> | boolean
    tenantId?: StringFilter<"VideoParticipant"> | string
    createdAt?: DateTimeFilter<"VideoParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"VideoParticipant"> | Date | string
  }

  export type VideoRecordingUpsertWithWhereUniqueWithoutTenantInput = {
    where: VideoRecordingWhereUniqueInput
    update: XOR<VideoRecordingUpdateWithoutTenantInput, VideoRecordingUncheckedUpdateWithoutTenantInput>
    create: XOR<VideoRecordingCreateWithoutTenantInput, VideoRecordingUncheckedCreateWithoutTenantInput>
  }

  export type VideoRecordingUpdateWithWhereUniqueWithoutTenantInput = {
    where: VideoRecordingWhereUniqueInput
    data: XOR<VideoRecordingUpdateWithoutTenantInput, VideoRecordingUncheckedUpdateWithoutTenantInput>
  }

  export type VideoRecordingUpdateManyWithWhereWithoutTenantInput = {
    where: VideoRecordingScalarWhereInput
    data: XOR<VideoRecordingUpdateManyMutationInput, VideoRecordingUncheckedUpdateManyWithoutTenantInput>
  }

  export type VideoRecordingScalarWhereInput = {
    AND?: VideoRecordingScalarWhereInput | VideoRecordingScalarWhereInput[]
    OR?: VideoRecordingScalarWhereInput[]
    NOT?: VideoRecordingScalarWhereInput | VideoRecordingScalarWhereInput[]
    id?: StringFilter<"VideoRecording"> | string
    roomId?: StringFilter<"VideoRecording"> | string
    fileName?: StringFilter<"VideoRecording"> | string
    filePath?: StringFilter<"VideoRecording"> | string
    fileSize?: IntFilter<"VideoRecording"> | number
    duration?: IntNullableFilter<"VideoRecording"> | number | null
    status?: EnumRecordingStatusFilter<"VideoRecording"> | $Enums.RecordingStatus
    isActive?: BoolFilter<"VideoRecording"> | boolean
    tenantId?: StringFilter<"VideoRecording"> | string
    createdAt?: DateTimeFilter<"VideoRecording"> | Date | string
    updatedAt?: DateTimeFilter<"VideoRecording"> | Date | string
  }

  export type VideoMessageUpsertWithWhereUniqueWithoutTenantInput = {
    where: VideoMessageWhereUniqueInput
    update: XOR<VideoMessageUpdateWithoutTenantInput, VideoMessageUncheckedUpdateWithoutTenantInput>
    create: XOR<VideoMessageCreateWithoutTenantInput, VideoMessageUncheckedCreateWithoutTenantInput>
  }

  export type VideoMessageUpdateWithWhereUniqueWithoutTenantInput = {
    where: VideoMessageWhereUniqueInput
    data: XOR<VideoMessageUpdateWithoutTenantInput, VideoMessageUncheckedUpdateWithoutTenantInput>
  }

  export type VideoMessageUpdateManyWithWhereWithoutTenantInput = {
    where: VideoMessageScalarWhereInput
    data: XOR<VideoMessageUpdateManyMutationInput, VideoMessageUncheckedUpdateManyWithoutTenantInput>
  }

  export type VideoMessageScalarWhereInput = {
    AND?: VideoMessageScalarWhereInput | VideoMessageScalarWhereInput[]
    OR?: VideoMessageScalarWhereInput[]
    NOT?: VideoMessageScalarWhereInput | VideoMessageScalarWhereInput[]
    id?: StringFilter<"VideoMessage"> | string
    roomId?: StringFilter<"VideoMessage"> | string
    senderId?: StringFilter<"VideoMessage"> | string
    message?: StringFilter<"VideoMessage"> | string
    messageType?: EnumMessageTypeFilter<"VideoMessage"> | $Enums.MessageType
    isActive?: BoolFilter<"VideoMessage"> | boolean
    tenantId?: StringFilter<"VideoMessage"> | string
    createdAt?: DateTimeFilter<"VideoMessage"> | Date | string
    updatedAt?: DateTimeFilter<"VideoMessage"> | Date | string
  }

  export type RadiologyOrderUpsertWithWhereUniqueWithoutTenantInput = {
    where: RadiologyOrderWhereUniqueInput
    update: XOR<RadiologyOrderUpdateWithoutTenantInput, RadiologyOrderUncheckedUpdateWithoutTenantInput>
    create: XOR<RadiologyOrderCreateWithoutTenantInput, RadiologyOrderUncheckedCreateWithoutTenantInput>
  }

  export type RadiologyOrderUpdateWithWhereUniqueWithoutTenantInput = {
    where: RadiologyOrderWhereUniqueInput
    data: XOR<RadiologyOrderUpdateWithoutTenantInput, RadiologyOrderUncheckedUpdateWithoutTenantInput>
  }

  export type RadiologyOrderUpdateManyWithWhereWithoutTenantInput = {
    where: RadiologyOrderScalarWhereInput
    data: XOR<RadiologyOrderUpdateManyMutationInput, RadiologyOrderUncheckedUpdateManyWithoutTenantInput>
  }

  export type RadiologyOrderScalarWhereInput = {
    AND?: RadiologyOrderScalarWhereInput | RadiologyOrderScalarWhereInput[]
    OR?: RadiologyOrderScalarWhereInput[]
    NOT?: RadiologyOrderScalarWhereInput | RadiologyOrderScalarWhereInput[]
    id?: StringFilter<"RadiologyOrder"> | string
    consultationId?: StringFilter<"RadiologyOrder"> | string
    patientId?: StringFilter<"RadiologyOrder"> | string
    doctorId?: StringFilter<"RadiologyOrder"> | string
    modalityId?: StringFilter<"RadiologyOrder"> | string
    studyType?: StringFilter<"RadiologyOrder"> | string
    priority?: EnumPriorityFilter<"RadiologyOrder"> | $Enums.Priority
    reason?: StringNullableFilter<"RadiologyOrder"> | string | null
    clinicalHistory?: StringNullableFilter<"RadiologyOrder"> | string | null
    status?: EnumRadiologyOrderStatusFilter<"RadiologyOrder"> | $Enums.RadiologyOrderStatus
    scheduledAt?: DateTimeNullableFilter<"RadiologyOrder"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"RadiologyOrder"> | Date | string | null
    isActive?: BoolFilter<"RadiologyOrder"> | boolean
    tenantId?: StringFilter<"RadiologyOrder"> | string
    createdAt?: DateTimeFilter<"RadiologyOrder"> | Date | string
    updatedAt?: DateTimeFilter<"RadiologyOrder"> | Date | string
    studyId?: StringNullableFilter<"RadiologyOrder"> | string | null
  }

  export type AppointmentCreateWithoutDoctorInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    status: $Enums.AppointmentStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAppointmentsInput
    department?: DepartmentCreateNestedOneWithoutAppointmentsInput
    patient: PatientCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutDoctorInput = {
    id?: string
    patientId: string
    departmentId?: string | null
    startTime: Date | string
    endTime: Date | string
    status: $Enums.AppointmentStatus
    reason?: string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateOrConnectWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput>
  }

  export type AppointmentCreateManyDoctorInputEnvelope = {
    data: AppointmentCreateManyDoctorInput | AppointmentCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type LabOrderCreateWithoutDoctorInput = {
    id?: string
    orderNumber: string
    status?: $Enums.LabOrderStatus
    orderDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutLabOrdersInput
    patient: PatientCreateNestedOneWithoutLabOrdersInput
    tests?: LabOrderTestCreateNestedManyWithoutOrderInput
    consultation?: TelemedicineConsultationCreateNestedOneWithoutLabOrdersInput
  }

  export type LabOrderUncheckedCreateWithoutDoctorInput = {
    id?: string
    orderNumber: string
    patientId: string
    status?: $Enums.LabOrderStatus
    orderDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationId?: string | null
    tests?: LabOrderTestUncheckedCreateNestedManyWithoutOrderInput
  }

  export type LabOrderCreateOrConnectWithoutDoctorInput = {
    where: LabOrderWhereUniqueInput
    create: XOR<LabOrderCreateWithoutDoctorInput, LabOrderUncheckedCreateWithoutDoctorInput>
  }

  export type LabOrderCreateManyDoctorInputEnvelope = {
    data: LabOrderCreateManyDoctorInput | LabOrderCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type PharmacyOrderCreateWithoutDoctorInput = {
    id?: string
    orderNumber: string
    status?: $Enums.PharmacyOrderStatus
    orderDate?: Date | string
    dispensedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    tenant: TenantCreateNestedOneWithoutPharmacyOrdersInput
    patient: PatientCreateNestedOneWithoutPharmacyOrdersInput
    invoice?: InvoiceCreateNestedOneWithoutPharmacyOrderInput
    items?: PharmacyOrderItemCreateNestedManyWithoutOrderInput
  }

  export type PharmacyOrderUncheckedCreateWithoutDoctorInput = {
    id?: string
    orderNumber: string
    patientId: string
    status?: $Enums.PharmacyOrderStatus
    orderDate?: Date | string
    dispensedDate?: Date | string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    items?: PharmacyOrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type PharmacyOrderCreateOrConnectWithoutDoctorInput = {
    where: PharmacyOrderWhereUniqueInput
    create: XOR<PharmacyOrderCreateWithoutDoctorInput, PharmacyOrderUncheckedCreateWithoutDoctorInput>
  }

  export type PharmacyOrderCreateManyDoctorInputEnvelope = {
    data: PharmacyOrderCreateManyDoctorInput | PharmacyOrderCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionCreateWithoutDoctorInput = {
    id?: string
    diagnosis?: string | null
    notes?: string | null
    status?: $Enums.PrescriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPrescriptionsInput
    patient: PatientCreateNestedOneWithoutPrescriptionsInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutDoctorInput = {
    id?: string
    patientId: string
    diagnosis?: string | null
    notes?: string | null
    status?: $Enums.PrescriptionStatus
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutDoctorInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput>
  }

  export type PrescriptionCreateManyDoctorInputEnvelope = {
    data: PrescriptionCreateManyDoctorInput | PrescriptionCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type TelemedicineConsultationCreateWithoutDoctorInput = {
    id?: string
    status?: $Enums.TelemedicineStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    consultationType?: $Enums.ConsultationType
    reason?: string | null
    notes?: string | null
    prescription?: string | null
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    isEmergency?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutTelemedicineConsultationsInput
    tenant: TenantCreateNestedOneWithoutTelemedicineConsultationsInput
    videoRoom?: VideoRoomCreateNestedOneWithoutConsultationInput
    labOrders?: LabOrderCreateNestedManyWithoutConsultationInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutConsultationInput
  }

  export type TelemedicineConsultationUncheckedCreateWithoutDoctorInput = {
    id?: string
    patientId: string
    status?: $Enums.TelemedicineStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    consultationType?: $Enums.ConsultationType
    reason?: string | null
    notes?: string | null
    prescription?: string | null
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    isEmergency?: boolean
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    videoRoom?: VideoRoomUncheckedCreateNestedOneWithoutConsultationInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutConsultationInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type TelemedicineConsultationCreateOrConnectWithoutDoctorInput = {
    where: TelemedicineConsultationWhereUniqueInput
    create: XOR<TelemedicineConsultationCreateWithoutDoctorInput, TelemedicineConsultationUncheckedCreateWithoutDoctorInput>
  }

  export type TelemedicineConsultationCreateManyDoctorInputEnvelope = {
    data: TelemedicineConsultationCreateManyDoctorInput | TelemedicineConsultationCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type RadiologyOrderCreateWithoutDoctorInput = {
    id?: string
    studyType: string
    priority?: $Enums.Priority
    reason?: string | null
    clinicalHistory?: string | null
    status?: $Enums.RadiologyOrderStatus
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    consultation: TelemedicineConsultationCreateNestedOneWithoutRadiologyOrdersInput
    patient: PatientCreateNestedOneWithoutRadiologyOrdersInput
    modality: ModalityCreateNestedOneWithoutRadiologyOrdersInput
    tenant: TenantCreateNestedOneWithoutRadiologyOrdersInput
    study?: StudyCreateNestedOneWithoutRadiologyOrdersInput
  }

  export type RadiologyOrderUncheckedCreateWithoutDoctorInput = {
    id?: string
    consultationId: string
    patientId: string
    modalityId: string
    studyType: string
    priority?: $Enums.Priority
    reason?: string | null
    clinicalHistory?: string | null
    status?: $Enums.RadiologyOrderStatus
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studyId?: string | null
  }

  export type RadiologyOrderCreateOrConnectWithoutDoctorInput = {
    where: RadiologyOrderWhereUniqueInput
    create: XOR<RadiologyOrderCreateWithoutDoctorInput, RadiologyOrderUncheckedCreateWithoutDoctorInput>
  }

  export type RadiologyOrderCreateManyDoctorInputEnvelope = {
    data: RadiologyOrderCreateManyDoctorInput | RadiologyOrderCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    jti: string
    token: string
    revoked?: boolean
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    jti: string
    token: string
    revoked?: boolean
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StaffCreateWithoutUserInput = {
    id?: string
    employeeId?: string | null
    designation?: string | null
    joiningDate?: Date | string | null
    qualification?: string | null
    experience?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStaffInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
  }

  export type StaffUncheckedCreateWithoutUserInput = {
    id?: string
    employeeId?: string | null
    designation?: string | null
    departmentId?: string | null
    joiningDate?: Date | string | null
    qualification?: string | null
    experience?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffCreateOrConnectWithoutUserInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entityType?: string | null
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entityType?: string | null
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    tenantId: string
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MedicalRecordCreateWithoutDoctorInput = {
    id?: string
    recordType: string
    title: string
    description?: string | null
    date?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMedicalRecordsInput
    patient: PatientCreateNestedOneWithoutMedicalRecordsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedMedicalRecordsInput
  }

  export type MedicalRecordUncheckedCreateWithoutDoctorInput = {
    id?: string
    patientId: string
    recordType: string
    title: string
    description?: string | null
    date?: Date | string
    updatedById?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalRecordCreateOrConnectWithoutDoctorInput = {
    where: MedicalRecordWhereUniqueInput
    create: XOR<MedicalRecordCreateWithoutDoctorInput, MedicalRecordUncheckedCreateWithoutDoctorInput>
  }

  export type MedicalRecordCreateManyDoctorInputEnvelope = {
    data: MedicalRecordCreateManyDoctorInput | MedicalRecordCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type MedicalRecordCreateWithoutUpdatedByInput = {
    id?: string
    recordType: string
    title: string
    description?: string | null
    date?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMedicalRecordsInput
    patient: PatientCreateNestedOneWithoutMedicalRecordsInput
    doctor?: UserCreateNestedOneWithoutCreatedMedicalRecordsInput
  }

  export type MedicalRecordUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    patientId: string
    recordType: string
    title: string
    description?: string | null
    date?: Date | string
    doctorId?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalRecordCreateOrConnectWithoutUpdatedByInput = {
    where: MedicalRecordWhereUniqueInput
    create: XOR<MedicalRecordCreateWithoutUpdatedByInput, MedicalRecordUncheckedCreateWithoutUpdatedByInput>
  }

  export type MedicalRecordCreateManyUpdatedByInputEnvelope = {
    data: MedicalRecordCreateManyUpdatedByInput | MedicalRecordCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutDoctorInput, AppointmentUncheckedUpdateWithoutDoctorInput>
    create: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutDoctorInput, AppointmentUncheckedUpdateWithoutDoctorInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutDoctorInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutDoctorInput>
  }

  export type LabOrderUpsertWithWhereUniqueWithoutDoctorInput = {
    where: LabOrderWhereUniqueInput
    update: XOR<LabOrderUpdateWithoutDoctorInput, LabOrderUncheckedUpdateWithoutDoctorInput>
    create: XOR<LabOrderCreateWithoutDoctorInput, LabOrderUncheckedCreateWithoutDoctorInput>
  }

  export type LabOrderUpdateWithWhereUniqueWithoutDoctorInput = {
    where: LabOrderWhereUniqueInput
    data: XOR<LabOrderUpdateWithoutDoctorInput, LabOrderUncheckedUpdateWithoutDoctorInput>
  }

  export type LabOrderUpdateManyWithWhereWithoutDoctorInput = {
    where: LabOrderScalarWhereInput
    data: XOR<LabOrderUpdateManyMutationInput, LabOrderUncheckedUpdateManyWithoutDoctorInput>
  }

  export type PharmacyOrderUpsertWithWhereUniqueWithoutDoctorInput = {
    where: PharmacyOrderWhereUniqueInput
    update: XOR<PharmacyOrderUpdateWithoutDoctorInput, PharmacyOrderUncheckedUpdateWithoutDoctorInput>
    create: XOR<PharmacyOrderCreateWithoutDoctorInput, PharmacyOrderUncheckedCreateWithoutDoctorInput>
  }

  export type PharmacyOrderUpdateWithWhereUniqueWithoutDoctorInput = {
    where: PharmacyOrderWhereUniqueInput
    data: XOR<PharmacyOrderUpdateWithoutDoctorInput, PharmacyOrderUncheckedUpdateWithoutDoctorInput>
  }

  export type PharmacyOrderUpdateManyWithWhereWithoutDoctorInput = {
    where: PharmacyOrderScalarWhereInput
    data: XOR<PharmacyOrderUpdateManyMutationInput, PharmacyOrderUncheckedUpdateManyWithoutDoctorInput>
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutDoctorInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutDoctorInput, PrescriptionUncheckedUpdateWithoutDoctorInput>
    create: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutDoctorInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutDoctorInput, PrescriptionUncheckedUpdateWithoutDoctorInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutDoctorInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutDoctorInput>
  }

  export type TelemedicineConsultationUpsertWithWhereUniqueWithoutDoctorInput = {
    where: TelemedicineConsultationWhereUniqueInput
    update: XOR<TelemedicineConsultationUpdateWithoutDoctorInput, TelemedicineConsultationUncheckedUpdateWithoutDoctorInput>
    create: XOR<TelemedicineConsultationCreateWithoutDoctorInput, TelemedicineConsultationUncheckedCreateWithoutDoctorInput>
  }

  export type TelemedicineConsultationUpdateWithWhereUniqueWithoutDoctorInput = {
    where: TelemedicineConsultationWhereUniqueInput
    data: XOR<TelemedicineConsultationUpdateWithoutDoctorInput, TelemedicineConsultationUncheckedUpdateWithoutDoctorInput>
  }

  export type TelemedicineConsultationUpdateManyWithWhereWithoutDoctorInput = {
    where: TelemedicineConsultationScalarWhereInput
    data: XOR<TelemedicineConsultationUpdateManyMutationInput, TelemedicineConsultationUncheckedUpdateManyWithoutDoctorInput>
  }

  export type RadiologyOrderUpsertWithWhereUniqueWithoutDoctorInput = {
    where: RadiologyOrderWhereUniqueInput
    update: XOR<RadiologyOrderUpdateWithoutDoctorInput, RadiologyOrderUncheckedUpdateWithoutDoctorInput>
    create: XOR<RadiologyOrderCreateWithoutDoctorInput, RadiologyOrderUncheckedCreateWithoutDoctorInput>
  }

  export type RadiologyOrderUpdateWithWhereUniqueWithoutDoctorInput = {
    where: RadiologyOrderWhereUniqueInput
    data: XOR<RadiologyOrderUpdateWithoutDoctorInput, RadiologyOrderUncheckedUpdateWithoutDoctorInput>
  }

  export type RadiologyOrderUpdateManyWithWhereWithoutDoctorInput = {
    where: RadiologyOrderScalarWhereInput
    data: XOR<RadiologyOrderUpdateManyMutationInput, RadiologyOrderUncheckedUpdateManyWithoutDoctorInput>
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type StaffUpsertWithoutUserInput = {
    update: XOR<StaffUpdateWithoutUserInput, StaffUncheckedUpdateWithoutUserInput>
    create: XOR<StaffCreateWithoutUserInput, StaffUncheckedCreateWithoutUserInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutUserInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutUserInput, StaffUncheckedUpdateWithoutUserInput>
  }

  export type StaffUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStaffNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type MedicalRecordUpsertWithWhereUniqueWithoutDoctorInput = {
    where: MedicalRecordWhereUniqueInput
    update: XOR<MedicalRecordUpdateWithoutDoctorInput, MedicalRecordUncheckedUpdateWithoutDoctorInput>
    create: XOR<MedicalRecordCreateWithoutDoctorInput, MedicalRecordUncheckedCreateWithoutDoctorInput>
  }

  export type MedicalRecordUpdateWithWhereUniqueWithoutDoctorInput = {
    where: MedicalRecordWhereUniqueInput
    data: XOR<MedicalRecordUpdateWithoutDoctorInput, MedicalRecordUncheckedUpdateWithoutDoctorInput>
  }

  export type MedicalRecordUpdateManyWithWhereWithoutDoctorInput = {
    where: MedicalRecordScalarWhereInput
    data: XOR<MedicalRecordUpdateManyMutationInput, MedicalRecordUncheckedUpdateManyWithoutDoctorInput>
  }

  export type MedicalRecordUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: MedicalRecordWhereUniqueInput
    update: XOR<MedicalRecordUpdateWithoutUpdatedByInput, MedicalRecordUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<MedicalRecordCreateWithoutUpdatedByInput, MedicalRecordUncheckedCreateWithoutUpdatedByInput>
  }

  export type MedicalRecordUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: MedicalRecordWhereUniqueInput
    data: XOR<MedicalRecordUpdateWithoutUpdatedByInput, MedicalRecordUncheckedUpdateWithoutUpdatedByInput>
  }

  export type MedicalRecordUpdateManyWithWhereWithoutUpdatedByInput = {
    where: MedicalRecordScalarWhereInput
    data: XOR<MedicalRecordUpdateManyMutationInput, MedicalRecordUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderCreateNestedManyWithoutDoctorInput
    staff?: StaffCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordCreateNestedManyWithoutUpdatedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderUncheckedCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutDoctorInput
    staff?: StaffUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type TenantCreateWithoutRefreshTokensInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutRefreshTokensInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutRefreshTokensInput, TenantUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUpdateManyWithoutDoctorNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUpdateManyWithoutUpdatedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUncheckedUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    staff?: StaffUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type TenantUpsertWithoutRefreshTokensInput = {
    update: XOR<TenantUpdateWithoutRefreshTokensInput, TenantUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<TenantCreateWithoutRefreshTokensInput, TenantUncheckedCreateWithoutRefreshTokensInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutRefreshTokensInput, TenantUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type TenantUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type AppointmentCreateWithoutPatientInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    status: $Enums.AppointmentStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAppointmentsInput
    department?: DepartmentCreateNestedOneWithoutAppointmentsInput
    doctor: UserCreateNestedOneWithoutDoctorAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutPatientInput = {
    id?: string
    doctorId: string
    departmentId?: string | null
    startTime: Date | string
    endTime: Date | string
    status: $Enums.AppointmentStatus
    reason?: string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateOrConnectWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentCreateManyPatientInputEnvelope = {
    data: AppointmentCreateManyPatientInput | AppointmentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutPatientInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    subTotal?: number
    taxAmount?: number
    discountAmount?: number
    totalAmount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    pharmacyOrder?: PharmacyOrderCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPatientInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    subTotal?: number
    taxAmount?: number
    discountAmount?: number
    totalAmount?: number
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    pharmacyOrder?: PharmacyOrderUncheckedCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput>
  }

  export type InvoiceCreateManyPatientInputEnvelope = {
    data: InvoiceCreateManyPatientInput | InvoiceCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type LabOrderCreateWithoutPatientInput = {
    id?: string
    orderNumber: string
    status?: $Enums.LabOrderStatus
    orderDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutLabOrdersInput
    doctor?: UserCreateNestedOneWithoutDoctorLabOrdersInput
    tests?: LabOrderTestCreateNestedManyWithoutOrderInput
    consultation?: TelemedicineConsultationCreateNestedOneWithoutLabOrdersInput
  }

  export type LabOrderUncheckedCreateWithoutPatientInput = {
    id?: string
    orderNumber: string
    doctorId?: string | null
    status?: $Enums.LabOrderStatus
    orderDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationId?: string | null
    tests?: LabOrderTestUncheckedCreateNestedManyWithoutOrderInput
  }

  export type LabOrderCreateOrConnectWithoutPatientInput = {
    where: LabOrderWhereUniqueInput
    create: XOR<LabOrderCreateWithoutPatientInput, LabOrderUncheckedCreateWithoutPatientInput>
  }

  export type LabOrderCreateManyPatientInputEnvelope = {
    data: LabOrderCreateManyPatientInput | LabOrderCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type MedicalRecordCreateWithoutPatientInput = {
    id?: string
    recordType: string
    title: string
    description?: string | null
    date?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMedicalRecordsInput
    doctor?: UserCreateNestedOneWithoutCreatedMedicalRecordsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedMedicalRecordsInput
  }

  export type MedicalRecordUncheckedCreateWithoutPatientInput = {
    id?: string
    recordType: string
    title: string
    description?: string | null
    date?: Date | string
    doctorId?: string | null
    updatedById?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalRecordCreateOrConnectWithoutPatientInput = {
    where: MedicalRecordWhereUniqueInput
    create: XOR<MedicalRecordCreateWithoutPatientInput, MedicalRecordUncheckedCreateWithoutPatientInput>
  }

  export type MedicalRecordCreateManyPatientInputEnvelope = {
    data: MedicalRecordCreateManyPatientInput | MedicalRecordCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PharmacyOrderCreateWithoutPatientInput = {
    id?: string
    orderNumber: string
    status?: $Enums.PharmacyOrderStatus
    orderDate?: Date | string
    dispensedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    tenant: TenantCreateNestedOneWithoutPharmacyOrdersInput
    doctor?: UserCreateNestedOneWithoutDoctorPrescriptionsInput
    invoice?: InvoiceCreateNestedOneWithoutPharmacyOrderInput
    items?: PharmacyOrderItemCreateNestedManyWithoutOrderInput
  }

  export type PharmacyOrderUncheckedCreateWithoutPatientInput = {
    id?: string
    orderNumber: string
    doctorId?: string | null
    status?: $Enums.PharmacyOrderStatus
    orderDate?: Date | string
    dispensedDate?: Date | string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    createdBy?: string | null
    updatedBy?: string | null
    items?: PharmacyOrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type PharmacyOrderCreateOrConnectWithoutPatientInput = {
    where: PharmacyOrderWhereUniqueInput
    create: XOR<PharmacyOrderCreateWithoutPatientInput, PharmacyOrderUncheckedCreateWithoutPatientInput>
  }

  export type PharmacyOrderCreateManyPatientInputEnvelope = {
    data: PharmacyOrderCreateManyPatientInput | PharmacyOrderCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionCreateWithoutPatientInput = {
    id?: string
    diagnosis?: string | null
    notes?: string | null
    status?: $Enums.PrescriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPrescriptionsInput
    doctor: UserCreateNestedOneWithoutPrescriptionsInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutPatientInput = {
    id?: string
    doctorId: string
    diagnosis?: string | null
    notes?: string | null
    status?: $Enums.PrescriptionStatus
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput>
  }

  export type PrescriptionCreateManyPatientInputEnvelope = {
    data: PrescriptionCreateManyPatientInput | PrescriptionCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionItemCreateWithoutPatientInput = {
    id?: string
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    isDispensed?: boolean
    tenant: TenantCreateNestedOneWithoutPrescriptionItemsInput
    medication: MedicationCreateNestedOneWithoutPrescriptionItemsInput
    prescription: PrescriptionCreateNestedOneWithoutPrescriptionItemsInput
  }

  export type PrescriptionItemUncheckedCreateWithoutPatientInput = {
    id?: string
    prescriptionId: string
    medicationId: string
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    isDispensed?: boolean
    tenantId: string
  }

  export type PrescriptionItemCreateOrConnectWithoutPatientInput = {
    where: PrescriptionItemWhereUniqueInput
    create: XOR<PrescriptionItemCreateWithoutPatientInput, PrescriptionItemUncheckedCreateWithoutPatientInput>
  }

  export type PrescriptionItemCreateManyPatientInputEnvelope = {
    data: PrescriptionItemCreateManyPatientInput | PrescriptionItemCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type StudyCreateWithoutPatientInput = {
    id?: string
    studyId: string
    patientName: string
    status?: $Enums.StudyStatus
    studyDate?: Date | string
    priority?: $Enums.Priority | null
    description?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modality: ModalityCreateNestedOneWithoutStudiesInput
    tenant: TenantCreateNestedOneWithoutStudiesInput
    series?: SeriesCreateNestedManyWithoutStudyInput
    radReports?: RadReportCreateNestedManyWithoutStudyInput
    radiationDoses?: RadiationDoseCreateNestedManyWithoutStudyInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutStudyInput
  }

  export type StudyUncheckedCreateWithoutPatientInput = {
    id?: string
    studyId: string
    patientName: string
    modalityId: string
    status?: $Enums.StudyStatus
    studyDate?: Date | string
    priority?: $Enums.Priority | null
    description?: string | null
    notes?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    series?: SeriesUncheckedCreateNestedManyWithoutStudyInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutStudyInput
    radiationDoses?: RadiationDoseUncheckedCreateNestedManyWithoutStudyInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutStudyInput
  }

  export type StudyCreateOrConnectWithoutPatientInput = {
    where: StudyWhereUniqueInput
    create: XOR<StudyCreateWithoutPatientInput, StudyUncheckedCreateWithoutPatientInput>
  }

  export type StudyCreateManyPatientInputEnvelope = {
    data: StudyCreateManyPatientInput | StudyCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type TelemedicineConsultationCreateWithoutPatientInput = {
    id?: string
    status?: $Enums.TelemedicineStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    consultationType?: $Enums.ConsultationType
    reason?: string | null
    notes?: string | null
    prescription?: string | null
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    isEmergency?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor?: UserCreateNestedOneWithoutDoctorTelemedicineInput
    tenant: TenantCreateNestedOneWithoutTelemedicineConsultationsInput
    videoRoom?: VideoRoomCreateNestedOneWithoutConsultationInput
    labOrders?: LabOrderCreateNestedManyWithoutConsultationInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutConsultationInput
  }

  export type TelemedicineConsultationUncheckedCreateWithoutPatientInput = {
    id?: string
    doctorId?: string | null
    status?: $Enums.TelemedicineStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    consultationType?: $Enums.ConsultationType
    reason?: string | null
    notes?: string | null
    prescription?: string | null
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    isEmergency?: boolean
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    videoRoom?: VideoRoomUncheckedCreateNestedOneWithoutConsultationInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutConsultationInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type TelemedicineConsultationCreateOrConnectWithoutPatientInput = {
    where: TelemedicineConsultationWhereUniqueInput
    create: XOR<TelemedicineConsultationCreateWithoutPatientInput, TelemedicineConsultationUncheckedCreateWithoutPatientInput>
  }

  export type TelemedicineConsultationCreateManyPatientInputEnvelope = {
    data: TelemedicineConsultationCreateManyPatientInput | TelemedicineConsultationCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type RadiologyOrderCreateWithoutPatientInput = {
    id?: string
    studyType: string
    priority?: $Enums.Priority
    reason?: string | null
    clinicalHistory?: string | null
    status?: $Enums.RadiologyOrderStatus
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    consultation: TelemedicineConsultationCreateNestedOneWithoutRadiologyOrdersInput
    doctor: UserCreateNestedOneWithoutDoctorRadiologyOrdersInput
    modality: ModalityCreateNestedOneWithoutRadiologyOrdersInput
    tenant: TenantCreateNestedOneWithoutRadiologyOrdersInput
    study?: StudyCreateNestedOneWithoutRadiologyOrdersInput
  }

  export type RadiologyOrderUncheckedCreateWithoutPatientInput = {
    id?: string
    consultationId: string
    doctorId: string
    modalityId: string
    studyType: string
    priority?: $Enums.Priority
    reason?: string | null
    clinicalHistory?: string | null
    status?: $Enums.RadiologyOrderStatus
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studyId?: string | null
  }

  export type RadiologyOrderCreateOrConnectWithoutPatientInput = {
    where: RadiologyOrderWhereUniqueInput
    create: XOR<RadiologyOrderCreateWithoutPatientInput, RadiologyOrderUncheckedCreateWithoutPatientInput>
  }

  export type RadiologyOrderCreateManyPatientInputEnvelope = {
    data: RadiologyOrderCreateManyPatientInput | RadiologyOrderCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutPatientsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPatientsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPatientsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPatientsInput, TenantUncheckedCreateWithoutPatientsInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutPatientInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutPatientInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutPatientInput, InvoiceUncheckedUpdateWithoutPatientInput>
    create: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutPatientInput, InvoiceUncheckedUpdateWithoutPatientInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutPatientInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutPatientInput>
  }

  export type LabOrderUpsertWithWhereUniqueWithoutPatientInput = {
    where: LabOrderWhereUniqueInput
    update: XOR<LabOrderUpdateWithoutPatientInput, LabOrderUncheckedUpdateWithoutPatientInput>
    create: XOR<LabOrderCreateWithoutPatientInput, LabOrderUncheckedCreateWithoutPatientInput>
  }

  export type LabOrderUpdateWithWhereUniqueWithoutPatientInput = {
    where: LabOrderWhereUniqueInput
    data: XOR<LabOrderUpdateWithoutPatientInput, LabOrderUncheckedUpdateWithoutPatientInput>
  }

  export type LabOrderUpdateManyWithWhereWithoutPatientInput = {
    where: LabOrderScalarWhereInput
    data: XOR<LabOrderUpdateManyMutationInput, LabOrderUncheckedUpdateManyWithoutPatientInput>
  }

  export type MedicalRecordUpsertWithWhereUniqueWithoutPatientInput = {
    where: MedicalRecordWhereUniqueInput
    update: XOR<MedicalRecordUpdateWithoutPatientInput, MedicalRecordUncheckedUpdateWithoutPatientInput>
    create: XOR<MedicalRecordCreateWithoutPatientInput, MedicalRecordUncheckedCreateWithoutPatientInput>
  }

  export type MedicalRecordUpdateWithWhereUniqueWithoutPatientInput = {
    where: MedicalRecordWhereUniqueInput
    data: XOR<MedicalRecordUpdateWithoutPatientInput, MedicalRecordUncheckedUpdateWithoutPatientInput>
  }

  export type MedicalRecordUpdateManyWithWhereWithoutPatientInput = {
    where: MedicalRecordScalarWhereInput
    data: XOR<MedicalRecordUpdateManyMutationInput, MedicalRecordUncheckedUpdateManyWithoutPatientInput>
  }

  export type PharmacyOrderUpsertWithWhereUniqueWithoutPatientInput = {
    where: PharmacyOrderWhereUniqueInput
    update: XOR<PharmacyOrderUpdateWithoutPatientInput, PharmacyOrderUncheckedUpdateWithoutPatientInput>
    create: XOR<PharmacyOrderCreateWithoutPatientInput, PharmacyOrderUncheckedCreateWithoutPatientInput>
  }

  export type PharmacyOrderUpdateWithWhereUniqueWithoutPatientInput = {
    where: PharmacyOrderWhereUniqueInput
    data: XOR<PharmacyOrderUpdateWithoutPatientInput, PharmacyOrderUncheckedUpdateWithoutPatientInput>
  }

  export type PharmacyOrderUpdateManyWithWhereWithoutPatientInput = {
    where: PharmacyOrderScalarWhereInput
    data: XOR<PharmacyOrderUpdateManyMutationInput, PharmacyOrderUncheckedUpdateManyWithoutPatientInput>
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutPatientInput, PrescriptionUncheckedUpdateWithoutPatientInput>
    create: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutPatientInput, PrescriptionUncheckedUpdateWithoutPatientInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutPatientInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutPatientInput>
  }

  export type PrescriptionItemUpsertWithWhereUniqueWithoutPatientInput = {
    where: PrescriptionItemWhereUniqueInput
    update: XOR<PrescriptionItemUpdateWithoutPatientInput, PrescriptionItemUncheckedUpdateWithoutPatientInput>
    create: XOR<PrescriptionItemCreateWithoutPatientInput, PrescriptionItemUncheckedCreateWithoutPatientInput>
  }

  export type PrescriptionItemUpdateWithWhereUniqueWithoutPatientInput = {
    where: PrescriptionItemWhereUniqueInput
    data: XOR<PrescriptionItemUpdateWithoutPatientInput, PrescriptionItemUncheckedUpdateWithoutPatientInput>
  }

  export type PrescriptionItemUpdateManyWithWhereWithoutPatientInput = {
    where: PrescriptionItemScalarWhereInput
    data: XOR<PrescriptionItemUpdateManyMutationInput, PrescriptionItemUncheckedUpdateManyWithoutPatientInput>
  }

  export type StudyUpsertWithWhereUniqueWithoutPatientInput = {
    where: StudyWhereUniqueInput
    update: XOR<StudyUpdateWithoutPatientInput, StudyUncheckedUpdateWithoutPatientInput>
    create: XOR<StudyCreateWithoutPatientInput, StudyUncheckedCreateWithoutPatientInput>
  }

  export type StudyUpdateWithWhereUniqueWithoutPatientInput = {
    where: StudyWhereUniqueInput
    data: XOR<StudyUpdateWithoutPatientInput, StudyUncheckedUpdateWithoutPatientInput>
  }

  export type StudyUpdateManyWithWhereWithoutPatientInput = {
    where: StudyScalarWhereInput
    data: XOR<StudyUpdateManyMutationInput, StudyUncheckedUpdateManyWithoutPatientInput>
  }

  export type TelemedicineConsultationUpsertWithWhereUniqueWithoutPatientInput = {
    where: TelemedicineConsultationWhereUniqueInput
    update: XOR<TelemedicineConsultationUpdateWithoutPatientInput, TelemedicineConsultationUncheckedUpdateWithoutPatientInput>
    create: XOR<TelemedicineConsultationCreateWithoutPatientInput, TelemedicineConsultationUncheckedCreateWithoutPatientInput>
  }

  export type TelemedicineConsultationUpdateWithWhereUniqueWithoutPatientInput = {
    where: TelemedicineConsultationWhereUniqueInput
    data: XOR<TelemedicineConsultationUpdateWithoutPatientInput, TelemedicineConsultationUncheckedUpdateWithoutPatientInput>
  }

  export type TelemedicineConsultationUpdateManyWithWhereWithoutPatientInput = {
    where: TelemedicineConsultationScalarWhereInput
    data: XOR<TelemedicineConsultationUpdateManyMutationInput, TelemedicineConsultationUncheckedUpdateManyWithoutPatientInput>
  }

  export type RadiologyOrderUpsertWithWhereUniqueWithoutPatientInput = {
    where: RadiologyOrderWhereUniqueInput
    update: XOR<RadiologyOrderUpdateWithoutPatientInput, RadiologyOrderUncheckedUpdateWithoutPatientInput>
    create: XOR<RadiologyOrderCreateWithoutPatientInput, RadiologyOrderUncheckedCreateWithoutPatientInput>
  }

  export type RadiologyOrderUpdateWithWhereUniqueWithoutPatientInput = {
    where: RadiologyOrderWhereUniqueInput
    data: XOR<RadiologyOrderUpdateWithoutPatientInput, RadiologyOrderUncheckedUpdateWithoutPatientInput>
  }

  export type RadiologyOrderUpdateManyWithWhereWithoutPatientInput = {
    where: RadiologyOrderScalarWhereInput
    data: XOR<RadiologyOrderUpdateManyMutationInput, RadiologyOrderUncheckedUpdateManyWithoutPatientInput>
  }

  export type TenantUpsertWithoutPatientsInput = {
    update: XOR<TenantUpdateWithoutPatientsInput, TenantUncheckedUpdateWithoutPatientsInput>
    create: XOR<TenantCreateWithoutPatientsInput, TenantUncheckedCreateWithoutPatientsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPatientsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPatientsInput, TenantUncheckedUpdateWithoutPatientsInput>
  }

  export type TenantUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAppointmentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAppointmentsInput, TenantUncheckedCreateWithoutAppointmentsInput>
  }

  export type DepartmentCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDepartmentsInput
    staff?: StaffCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    staff?: StaffUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutAppointmentsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutAppointmentsInput, DepartmentUncheckedCreateWithoutAppointmentsInput>
  }

  export type UserCreateWithoutDoctorAppointmentsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorLabOrders?: LabOrderCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    staff?: StaffCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordCreateNestedManyWithoutUpdatedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutDoctorAppointmentsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorLabOrders?: LabOrderUncheckedCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    staff?: StaffUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutDoctorAppointmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoctorAppointmentsInput, UserUncheckedCreateWithoutDoctorAppointmentsInput>
  }

  export type PatientCreateWithoutAppointmentsInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutPatientInput
    studies?: StudyCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutPatientInput
    tenant: TenantCreateNestedOneWithoutPatientsInput
  }

  export type PatientUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    tenantId: string
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutPatientInput
    studies?: StudyUncheckedCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAppointmentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
  }

  export type TenantUpsertWithoutAppointmentsInput = {
    update: XOR<TenantUpdateWithoutAppointmentsInput, TenantUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<TenantCreateWithoutAppointmentsInput, TenantUncheckedCreateWithoutAppointmentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAppointmentsInput, TenantUncheckedUpdateWithoutAppointmentsInput>
  }

  export type TenantUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type DepartmentUpsertWithoutAppointmentsInput = {
    update: XOR<DepartmentUpdateWithoutAppointmentsInput, DepartmentUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<DepartmentCreateWithoutAppointmentsInput, DepartmentUncheckedCreateWithoutAppointmentsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutAppointmentsInput, DepartmentUncheckedUpdateWithoutAppointmentsInput>
  }

  export type DepartmentUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDepartmentsNestedInput
    staff?: StaffUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type UserUpsertWithoutDoctorAppointmentsInput = {
    update: XOR<UserUpdateWithoutDoctorAppointmentsInput, UserUncheckedUpdateWithoutDoctorAppointmentsInput>
    create: XOR<UserCreateWithoutDoctorAppointmentsInput, UserUncheckedCreateWithoutDoctorAppointmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDoctorAppointmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDoctorAppointmentsInput, UserUncheckedUpdateWithoutDoctorAppointmentsInput>
  }

  export type UserUpdateWithoutDoctorAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorLabOrders?: LabOrderUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUpdateManyWithoutUpdatedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutDoctorAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorLabOrders?: LabOrderUncheckedUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    staff?: StaffUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type PatientUpsertWithoutAppointmentsInput = {
    update: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PatientUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutPatientNestedInput
    studies?: StudyUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutPatientNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutPatientNestedInput
    studies?: StudyUncheckedUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type TenantCreateWithoutPrescriptionsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPrescriptionsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPrescriptionsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPrescriptionsInput, TenantUncheckedCreateWithoutPrescriptionsInput>
  }

  export type UserCreateWithoutPrescriptionsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    staff?: StaffCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordCreateNestedManyWithoutUpdatedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutPrescriptionsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderUncheckedCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderUncheckedCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    staff?: StaffUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutPrescriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPrescriptionsInput, UserUncheckedCreateWithoutPrescriptionsInput>
  }

  export type PatientCreateWithoutPrescriptionsInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutPatientInput
    studies?: StudyCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutPatientInput
    tenant: TenantCreateNestedOneWithoutPatientsInput
  }

  export type PatientUncheckedCreateWithoutPrescriptionsInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    tenantId: string
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutPatientInput
    studies?: StudyUncheckedCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPrescriptionsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
  }

  export type PrescriptionItemCreateWithoutPrescriptionInput = {
    id?: string
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    isDispensed?: boolean
    tenant: TenantCreateNestedOneWithoutPrescriptionItemsInput
    patient: PatientCreateNestedOneWithoutPrescriptionItemsInput
    medication: MedicationCreateNestedOneWithoutPrescriptionItemsInput
  }

  export type PrescriptionItemUncheckedCreateWithoutPrescriptionInput = {
    id?: string
    medicationId: string
    patientId: string
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    isDispensed?: boolean
    tenantId: string
  }

  export type PrescriptionItemCreateOrConnectWithoutPrescriptionInput = {
    where: PrescriptionItemWhereUniqueInput
    create: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput>
  }

  export type PrescriptionItemCreateManyPrescriptionInputEnvelope = {
    data: PrescriptionItemCreateManyPrescriptionInput | PrescriptionItemCreateManyPrescriptionInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutPrescriptionsInput = {
    update: XOR<TenantUpdateWithoutPrescriptionsInput, TenantUncheckedUpdateWithoutPrescriptionsInput>
    create: XOR<TenantCreateWithoutPrescriptionsInput, TenantUncheckedCreateWithoutPrescriptionsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPrescriptionsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPrescriptionsInput, TenantUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type TenantUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutPrescriptionsInput = {
    update: XOR<UserUpdateWithoutPrescriptionsInput, UserUncheckedUpdateWithoutPrescriptionsInput>
    create: XOR<UserCreateWithoutPrescriptionsInput, UserUncheckedCreateWithoutPrescriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPrescriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPrescriptionsInput, UserUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type UserUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUpdateManyWithoutUpdatedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUncheckedUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    staff?: StaffUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type PatientUpsertWithoutPrescriptionsInput = {
    update: XOR<PatientUpdateWithoutPrescriptionsInput, PatientUncheckedUpdateWithoutPrescriptionsInput>
    create: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPrescriptionsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPrescriptionsInput, PatientUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type PatientUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutPatientNestedInput
    studies?: StudyUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutPatientNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutPatientNestedInput
    studies?: StudyUncheckedUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput = {
    where: PrescriptionItemWhereUniqueInput
    update: XOR<PrescriptionItemUpdateWithoutPrescriptionInput, PrescriptionItemUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput>
  }

  export type PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput = {
    where: PrescriptionItemWhereUniqueInput
    data: XOR<PrescriptionItemUpdateWithoutPrescriptionInput, PrescriptionItemUncheckedUpdateWithoutPrescriptionInput>
  }

  export type PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput = {
    where: PrescriptionItemScalarWhereInput
    data: XOR<PrescriptionItemUpdateManyMutationInput, PrescriptionItemUncheckedUpdateManyWithoutPrescriptionInput>
  }

  export type TenantCreateWithoutPrescriptionItemsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPrescriptionItemsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPrescriptionItemsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPrescriptionItemsInput, TenantUncheckedCreateWithoutPrescriptionItemsInput>
  }

  export type PatientCreateWithoutPrescriptionItemsInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    studies?: StudyCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutPatientInput
    tenant: TenantCreateNestedOneWithoutPatientsInput
  }

  export type PatientUncheckedCreateWithoutPrescriptionItemsInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    tenantId: string
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    studies?: StudyUncheckedCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPrescriptionItemsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPrescriptionItemsInput, PatientUncheckedCreateWithoutPrescriptionItemsInput>
  }

  export type MedicationCreateWithoutPrescriptionItemsInput = {
    id?: string
    name: string
    genericName?: string | null
    description?: string | null
    strength?: string | null
    unit?: string | null
    dosageForm?: string | null
    route?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMedicationsInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutMedicationInput
  }

  export type MedicationUncheckedCreateWithoutPrescriptionItemsInput = {
    id?: string
    name: string
    genericName?: string | null
    description?: string | null
    strength?: string | null
    unit?: string | null
    dosageForm?: string | null
    route?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutMedicationInput
  }

  export type MedicationCreateOrConnectWithoutPrescriptionItemsInput = {
    where: MedicationWhereUniqueInput
    create: XOR<MedicationCreateWithoutPrescriptionItemsInput, MedicationUncheckedCreateWithoutPrescriptionItemsInput>
  }

  export type PrescriptionCreateWithoutPrescriptionItemsInput = {
    id?: string
    diagnosis?: string | null
    notes?: string | null
    status?: $Enums.PrescriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPrescriptionsInput
    doctor: UserCreateNestedOneWithoutPrescriptionsInput
    patient: PatientCreateNestedOneWithoutPrescriptionsInput
  }

  export type PrescriptionUncheckedCreateWithoutPrescriptionItemsInput = {
    id?: string
    patientId: string
    doctorId: string
    diagnosis?: string | null
    notes?: string | null
    status?: $Enums.PrescriptionStatus
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrescriptionCreateOrConnectWithoutPrescriptionItemsInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutPrescriptionItemsInput, PrescriptionUncheckedCreateWithoutPrescriptionItemsInput>
  }

  export type TenantUpsertWithoutPrescriptionItemsInput = {
    update: XOR<TenantUpdateWithoutPrescriptionItemsInput, TenantUncheckedUpdateWithoutPrescriptionItemsInput>
    create: XOR<TenantCreateWithoutPrescriptionItemsInput, TenantUncheckedCreateWithoutPrescriptionItemsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPrescriptionItemsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPrescriptionItemsInput, TenantUncheckedUpdateWithoutPrescriptionItemsInput>
  }

  export type TenantUpdateWithoutPrescriptionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPrescriptionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type PatientUpsertWithoutPrescriptionItemsInput = {
    update: XOR<PatientUpdateWithoutPrescriptionItemsInput, PatientUncheckedUpdateWithoutPrescriptionItemsInput>
    create: XOR<PatientCreateWithoutPrescriptionItemsInput, PatientUncheckedCreateWithoutPrescriptionItemsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPrescriptionItemsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPrescriptionItemsInput, PatientUncheckedUpdateWithoutPrescriptionItemsInput>
  }

  export type PatientUpdateWithoutPrescriptionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    studies?: StudyUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutPatientNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateWithoutPrescriptionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    studies?: StudyUncheckedUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type MedicationUpsertWithoutPrescriptionItemsInput = {
    update: XOR<MedicationUpdateWithoutPrescriptionItemsInput, MedicationUncheckedUpdateWithoutPrescriptionItemsInput>
    create: XOR<MedicationCreateWithoutPrescriptionItemsInput, MedicationUncheckedCreateWithoutPrescriptionItemsInput>
    where?: MedicationWhereInput
  }

  export type MedicationUpdateToOneWithWhereWithoutPrescriptionItemsInput = {
    where?: MedicationWhereInput
    data: XOR<MedicationUpdateWithoutPrescriptionItemsInput, MedicationUncheckedUpdateWithoutPrescriptionItemsInput>
  }

  export type MedicationUpdateWithoutPrescriptionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMedicationsNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutMedicationNestedInput
  }

  export type MedicationUncheckedUpdateWithoutPrescriptionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutMedicationNestedInput
  }

  export type PrescriptionUpsertWithoutPrescriptionItemsInput = {
    update: XOR<PrescriptionUpdateWithoutPrescriptionItemsInput, PrescriptionUncheckedUpdateWithoutPrescriptionItemsInput>
    create: XOR<PrescriptionCreateWithoutPrescriptionItemsInput, PrescriptionUncheckedCreateWithoutPrescriptionItemsInput>
    where?: PrescriptionWhereInput
  }

  export type PrescriptionUpdateToOneWithWhereWithoutPrescriptionItemsInput = {
    where?: PrescriptionWhereInput
    data: XOR<PrescriptionUpdateWithoutPrescriptionItemsInput, PrescriptionUncheckedUpdateWithoutPrescriptionItemsInput>
  }

  export type PrescriptionUpdateWithoutPrescriptionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPrescriptionsNestedInput
    doctor?: UserUpdateOneRequiredWithoutPrescriptionsNestedInput
    patient?: PatientUpdateOneRequiredWithoutPrescriptionsNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutPrescriptionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutMedicalRecordsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutMedicalRecordsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutMedicalRecordsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutMedicalRecordsInput, TenantUncheckedCreateWithoutMedicalRecordsInput>
  }

  export type PatientCreateWithoutMedicalRecordsInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutPatientInput
    studies?: StudyCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutPatientInput
    tenant: TenantCreateNestedOneWithoutPatientsInput
  }

  export type PatientUncheckedCreateWithoutMedicalRecordsInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    tenantId: string
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutPatientInput
    studies?: StudyUncheckedCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutMedicalRecordsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutMedicalRecordsInput, PatientUncheckedCreateWithoutMedicalRecordsInput>
  }

  export type UserCreateWithoutCreatedMedicalRecordsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    staff?: StaffCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    updatedMedicalRecords?: MedicalRecordCreateNestedManyWithoutUpdatedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCreatedMedicalRecordsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderUncheckedCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    staff?: StaffUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    updatedMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutCreatedMedicalRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedMedicalRecordsInput, UserUncheckedCreateWithoutCreatedMedicalRecordsInput>
  }

  export type UserCreateWithoutUpdatedMedicalRecordsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    staff?: StaffCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordCreateNestedManyWithoutDoctorInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutUpdatedMedicalRecordsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderUncheckedCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    staff?: StaffUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type UserCreateOrConnectWithoutUpdatedMedicalRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedMedicalRecordsInput, UserUncheckedCreateWithoutUpdatedMedicalRecordsInput>
  }

  export type TenantUpsertWithoutMedicalRecordsInput = {
    update: XOR<TenantUpdateWithoutMedicalRecordsInput, TenantUncheckedUpdateWithoutMedicalRecordsInput>
    create: XOR<TenantCreateWithoutMedicalRecordsInput, TenantUncheckedCreateWithoutMedicalRecordsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutMedicalRecordsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutMedicalRecordsInput, TenantUncheckedUpdateWithoutMedicalRecordsInput>
  }

  export type TenantUpdateWithoutMedicalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutMedicalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type PatientUpsertWithoutMedicalRecordsInput = {
    update: XOR<PatientUpdateWithoutMedicalRecordsInput, PatientUncheckedUpdateWithoutMedicalRecordsInput>
    create: XOR<PatientCreateWithoutMedicalRecordsInput, PatientUncheckedCreateWithoutMedicalRecordsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutMedicalRecordsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutMedicalRecordsInput, PatientUncheckedUpdateWithoutMedicalRecordsInput>
  }

  export type PatientUpdateWithoutMedicalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutPatientNestedInput
    studies?: StudyUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutPatientNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateWithoutMedicalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutPatientNestedInput
    studies?: StudyUncheckedUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutCreatedMedicalRecordsInput = {
    update: XOR<UserUpdateWithoutCreatedMedicalRecordsInput, UserUncheckedUpdateWithoutCreatedMedicalRecordsInput>
    create: XOR<UserCreateWithoutCreatedMedicalRecordsInput, UserUncheckedCreateWithoutCreatedMedicalRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedMedicalRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedMedicalRecordsInput, UserUncheckedUpdateWithoutCreatedMedicalRecordsInput>
  }

  export type UserUpdateWithoutCreatedMedicalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    updatedMedicalRecords?: MedicalRecordUpdateManyWithoutUpdatedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedMedicalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUncheckedUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    staff?: StaffUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    updatedMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithoutUpdatedMedicalRecordsInput = {
    update: XOR<UserUpdateWithoutUpdatedMedicalRecordsInput, UserUncheckedUpdateWithoutUpdatedMedicalRecordsInput>
    create: XOR<UserCreateWithoutUpdatedMedicalRecordsInput, UserUncheckedCreateWithoutUpdatedMedicalRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedMedicalRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedMedicalRecordsInput, UserUncheckedUpdateWithoutUpdatedMedicalRecordsInput>
  }

  export type UserUpdateWithoutUpdatedMedicalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUpdateManyWithoutDoctorNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedMedicalRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUncheckedUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    staff?: StaffUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type TenantCreateWithoutInvoicesInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInvoicesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
  }

  export type PatientCreateWithoutInvoicesInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutPatientInput
    studies?: StudyCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutPatientInput
    tenant: TenantCreateNestedOneWithoutPatientsInput
  }

  export type PatientUncheckedCreateWithoutInvoicesInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    tenantId: string
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutPatientInput
    studies?: StudyUncheckedCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutInvoicesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    id?: string
    itemType: string
    itemId: string
    description: string
    quantity?: number
    unitPrice: number
    discount?: number
    taxRate?: number
    totalAmount: number
    tenant: TenantCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    itemType: string
    itemId: string
    description: string
    quantity?: number
    unitPrice: number
    discount?: number
    taxRate?: number
    totalAmount: number
    tenantId: string
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string
    paymentNumber: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    referenceNumber?: string | null
    notes?: string | null
    status?: $Enums.PaymentStatus
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    paymentNumber: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    referenceNumber?: string | null
    notes?: string | null
    status?: $Enums.PaymentStatus
    tenantId: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type PharmacyOrderCreateWithoutInvoiceInput = {
    id?: string
    orderNumber: string
    status?: $Enums.PharmacyOrderStatus
    orderDate?: Date | string
    dispensedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    tenant: TenantCreateNestedOneWithoutPharmacyOrdersInput
    doctor?: UserCreateNestedOneWithoutDoctorPrescriptionsInput
    patient: PatientCreateNestedOneWithoutPharmacyOrdersInput
    items?: PharmacyOrderItemCreateNestedManyWithoutOrderInput
  }

  export type PharmacyOrderUncheckedCreateWithoutInvoiceInput = {
    id?: string
    orderNumber: string
    patientId: string
    doctorId?: string | null
    status?: $Enums.PharmacyOrderStatus
    orderDate?: Date | string
    dispensedDate?: Date | string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    items?: PharmacyOrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type PharmacyOrderCreateOrConnectWithoutInvoiceInput = {
    where: PharmacyOrderWhereUniqueInput
    create: XOR<PharmacyOrderCreateWithoutInvoiceInput, PharmacyOrderUncheckedCreateWithoutInvoiceInput>
  }

  export type TenantUpsertWithoutInvoicesInput = {
    update: XOR<TenantUpdateWithoutInvoicesInput, TenantUncheckedUpdateWithoutInvoicesInput>
    create: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInvoicesInput, TenantUncheckedUpdateWithoutInvoicesInput>
  }

  export type TenantUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type PatientUpsertWithoutInvoicesInput = {
    update: XOR<PatientUpdateWithoutInvoicesInput, PatientUncheckedUpdateWithoutInvoicesInput>
    create: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutInvoicesInput, PatientUncheckedUpdateWithoutInvoicesInput>
  }

  export type PatientUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutPatientNestedInput
    studies?: StudyUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutPatientNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutPatientNestedInput
    studies?: StudyUncheckedUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PharmacyOrderUpsertWithoutInvoiceInput = {
    update: XOR<PharmacyOrderUpdateWithoutInvoiceInput, PharmacyOrderUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PharmacyOrderCreateWithoutInvoiceInput, PharmacyOrderUncheckedCreateWithoutInvoiceInput>
    where?: PharmacyOrderWhereInput
  }

  export type PharmacyOrderUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: PharmacyOrderWhereInput
    data: XOR<PharmacyOrderUpdateWithoutInvoiceInput, PharmacyOrderUncheckedUpdateWithoutInvoiceInput>
  }

  export type PharmacyOrderUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumPharmacyOrderStatusFieldUpdateOperationsInput | $Enums.PharmacyOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dispensedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutPharmacyOrdersNestedInput
    doctor?: UserUpdateOneWithoutDoctorPrescriptionsNestedInput
    patient?: PatientUpdateOneRequiredWithoutPharmacyOrdersNestedInput
    items?: PharmacyOrderItemUpdateManyWithoutOrderNestedInput
  }

  export type PharmacyOrderUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPharmacyOrderStatusFieldUpdateOperationsInput | $Enums.PharmacyOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dispensedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    items?: PharmacyOrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type TenantCreateWithoutInvoiceItemsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutInvoiceItemsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInvoiceItemsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInvoiceItemsInput, TenantUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type InvoiceCreateWithoutInvoiceItemsInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    subTotal?: number
    taxAmount?: number
    discountAmount?: number
    totalAmount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    patient: PatientCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
    pharmacyOrder?: PharmacyOrderCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutInvoiceItemsInput = {
    id?: string
    invoiceNumber: string
    patientId: string
    date?: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    subTotal?: number
    taxAmount?: number
    discountAmount?: number
    totalAmount?: number
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
    pharmacyOrder?: PharmacyOrderUncheckedCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutInvoiceItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutInvoiceItemsInput, InvoiceUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type TenantUpsertWithoutInvoiceItemsInput = {
    update: XOR<TenantUpdateWithoutInvoiceItemsInput, TenantUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<TenantCreateWithoutInvoiceItemsInput, TenantUncheckedCreateWithoutInvoiceItemsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInvoiceItemsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInvoiceItemsInput, TenantUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type TenantUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type InvoiceUpsertWithoutInvoiceItemsInput = {
    update: XOR<InvoiceUpdateWithoutInvoiceItemsInput, InvoiceUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<InvoiceCreateWithoutInvoiceItemsInput, InvoiceUncheckedCreateWithoutInvoiceItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutInvoiceItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutInvoiceItemsInput, InvoiceUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type InvoiceUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    patient?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    pharmacyOrder?: PharmacyOrderUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    pharmacyOrder?: PharmacyOrderUncheckedUpdateOneWithoutInvoiceNestedInput
  }

  export type TenantCreateWithoutPaymentsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPaymentsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPaymentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    subTotal?: number
    taxAmount?: number
    discountAmount?: number
    totalAmount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    patient: PatientCreateNestedOneWithoutInvoicesInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    pharmacyOrder?: PharmacyOrderCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    invoiceNumber: string
    patientId: string
    date?: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    subTotal?: number
    taxAmount?: number
    discountAmount?: number
    totalAmount?: number
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    pharmacyOrder?: PharmacyOrderUncheckedCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type TenantUpsertWithoutPaymentsInput = {
    update: XOR<TenantUpdateWithoutPaymentsInput, TenantUncheckedUpdateWithoutPaymentsInput>
    create: XOR<TenantCreateWithoutPaymentsInput, TenantUncheckedCreateWithoutPaymentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPaymentsInput, TenantUncheckedUpdateWithoutPaymentsInput>
  }

  export type TenantUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    patient?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    pharmacyOrder?: PharmacyOrderUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    pharmacyOrder?: PharmacyOrderUncheckedUpdateOneWithoutInvoiceNestedInput
  }

  export type LabOrderTestCreateWithoutTestInput = {
    id?: string
    status?: $Enums.LabTestStatus
    result?: string | null
    resultDate?: Date | string | null
    referenceRange?: string | null
    notes?: string | null
    tenant: TenantCreateNestedOneWithoutLabOrderTestsInput
    order: LabOrderCreateNestedOneWithoutTestsInput
  }

  export type LabOrderTestUncheckedCreateWithoutTestInput = {
    id?: string
    orderId: string
    status?: $Enums.LabTestStatus
    result?: string | null
    resultDate?: Date | string | null
    referenceRange?: string | null
    notes?: string | null
    tenantId: string
  }

  export type LabOrderTestCreateOrConnectWithoutTestInput = {
    where: LabOrderTestWhereUniqueInput
    create: XOR<LabOrderTestCreateWithoutTestInput, LabOrderTestUncheckedCreateWithoutTestInput>
  }

  export type LabOrderTestCreateManyTestInputEnvelope = {
    data: LabOrderTestCreateManyTestInput | LabOrderTestCreateManyTestInput[]
    skipDuplicates?: boolean
  }

  export type TenantCreateWithoutLabTestsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutLabTestsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutLabTestsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutLabTestsInput, TenantUncheckedCreateWithoutLabTestsInput>
  }

  export type LabOrderTestUpsertWithWhereUniqueWithoutTestInput = {
    where: LabOrderTestWhereUniqueInput
    update: XOR<LabOrderTestUpdateWithoutTestInput, LabOrderTestUncheckedUpdateWithoutTestInput>
    create: XOR<LabOrderTestCreateWithoutTestInput, LabOrderTestUncheckedCreateWithoutTestInput>
  }

  export type LabOrderTestUpdateWithWhereUniqueWithoutTestInput = {
    where: LabOrderTestWhereUniqueInput
    data: XOR<LabOrderTestUpdateWithoutTestInput, LabOrderTestUncheckedUpdateWithoutTestInput>
  }

  export type LabOrderTestUpdateManyWithWhereWithoutTestInput = {
    where: LabOrderTestScalarWhereInput
    data: XOR<LabOrderTestUpdateManyMutationInput, LabOrderTestUncheckedUpdateManyWithoutTestInput>
  }

  export type TenantUpsertWithoutLabTestsInput = {
    update: XOR<TenantUpdateWithoutLabTestsInput, TenantUncheckedUpdateWithoutLabTestsInput>
    create: XOR<TenantCreateWithoutLabTestsInput, TenantUncheckedCreateWithoutLabTestsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutLabTestsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutLabTestsInput, TenantUncheckedUpdateWithoutLabTestsInput>
  }

  export type TenantUpdateWithoutLabTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutLabTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutLabOrdersInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutLabOrdersInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutLabOrdersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutLabOrdersInput, TenantUncheckedCreateWithoutLabOrdersInput>
  }

  export type UserCreateWithoutDoctorLabOrdersInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    staff?: StaffCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordCreateNestedManyWithoutUpdatedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutDoctorLabOrdersInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    staff?: StaffUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutDoctorLabOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoctorLabOrdersInput, UserUncheckedCreateWithoutDoctorLabOrdersInput>
  }

  export type PatientCreateWithoutLabOrdersInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutPatientInput
    studies?: StudyCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutPatientInput
    tenant: TenantCreateNestedOneWithoutPatientsInput
  }

  export type PatientUncheckedCreateWithoutLabOrdersInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    tenantId: string
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutPatientInput
    studies?: StudyUncheckedCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutLabOrdersInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutLabOrdersInput, PatientUncheckedCreateWithoutLabOrdersInput>
  }

  export type LabOrderTestCreateWithoutOrderInput = {
    id?: string
    status?: $Enums.LabTestStatus
    result?: string | null
    resultDate?: Date | string | null
    referenceRange?: string | null
    notes?: string | null
    tenant: TenantCreateNestedOneWithoutLabOrderTestsInput
    test: LabTestCreateNestedOneWithoutLabOrdersInput
  }

  export type LabOrderTestUncheckedCreateWithoutOrderInput = {
    id?: string
    testId: string
    status?: $Enums.LabTestStatus
    result?: string | null
    resultDate?: Date | string | null
    referenceRange?: string | null
    notes?: string | null
    tenantId: string
  }

  export type LabOrderTestCreateOrConnectWithoutOrderInput = {
    where: LabOrderTestWhereUniqueInput
    create: XOR<LabOrderTestCreateWithoutOrderInput, LabOrderTestUncheckedCreateWithoutOrderInput>
  }

  export type LabOrderTestCreateManyOrderInputEnvelope = {
    data: LabOrderTestCreateManyOrderInput | LabOrderTestCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type TelemedicineConsultationCreateWithoutLabOrdersInput = {
    id?: string
    status?: $Enums.TelemedicineStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    consultationType?: $Enums.ConsultationType
    reason?: string | null
    notes?: string | null
    prescription?: string | null
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    isEmergency?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutTelemedicineConsultationsInput
    doctor?: UserCreateNestedOneWithoutDoctorTelemedicineInput
    tenant: TenantCreateNestedOneWithoutTelemedicineConsultationsInput
    videoRoom?: VideoRoomCreateNestedOneWithoutConsultationInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutConsultationInput
  }

  export type TelemedicineConsultationUncheckedCreateWithoutLabOrdersInput = {
    id?: string
    patientId: string
    doctorId?: string | null
    status?: $Enums.TelemedicineStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    consultationType?: $Enums.ConsultationType
    reason?: string | null
    notes?: string | null
    prescription?: string | null
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    isEmergency?: boolean
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    videoRoom?: VideoRoomUncheckedCreateNestedOneWithoutConsultationInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type TelemedicineConsultationCreateOrConnectWithoutLabOrdersInput = {
    where: TelemedicineConsultationWhereUniqueInput
    create: XOR<TelemedicineConsultationCreateWithoutLabOrdersInput, TelemedicineConsultationUncheckedCreateWithoutLabOrdersInput>
  }

  export type TenantUpsertWithoutLabOrdersInput = {
    update: XOR<TenantUpdateWithoutLabOrdersInput, TenantUncheckedUpdateWithoutLabOrdersInput>
    create: XOR<TenantCreateWithoutLabOrdersInput, TenantUncheckedCreateWithoutLabOrdersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutLabOrdersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutLabOrdersInput, TenantUncheckedUpdateWithoutLabOrdersInput>
  }

  export type TenantUpdateWithoutLabOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutLabOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutDoctorLabOrdersInput = {
    update: XOR<UserUpdateWithoutDoctorLabOrdersInput, UserUncheckedUpdateWithoutDoctorLabOrdersInput>
    create: XOR<UserCreateWithoutDoctorLabOrdersInput, UserUncheckedCreateWithoutDoctorLabOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDoctorLabOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDoctorLabOrdersInput, UserUncheckedUpdateWithoutDoctorLabOrdersInput>
  }

  export type UserUpdateWithoutDoctorLabOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUpdateManyWithoutUpdatedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutDoctorLabOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    staff?: StaffUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type PatientUpsertWithoutLabOrdersInput = {
    update: XOR<PatientUpdateWithoutLabOrdersInput, PatientUncheckedUpdateWithoutLabOrdersInput>
    create: XOR<PatientCreateWithoutLabOrdersInput, PatientUncheckedCreateWithoutLabOrdersInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutLabOrdersInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutLabOrdersInput, PatientUncheckedUpdateWithoutLabOrdersInput>
  }

  export type PatientUpdateWithoutLabOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutPatientNestedInput
    studies?: StudyUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutPatientNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateWithoutLabOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutPatientNestedInput
    studies?: StudyUncheckedUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type LabOrderTestUpsertWithWhereUniqueWithoutOrderInput = {
    where: LabOrderTestWhereUniqueInput
    update: XOR<LabOrderTestUpdateWithoutOrderInput, LabOrderTestUncheckedUpdateWithoutOrderInput>
    create: XOR<LabOrderTestCreateWithoutOrderInput, LabOrderTestUncheckedCreateWithoutOrderInput>
  }

  export type LabOrderTestUpdateWithWhereUniqueWithoutOrderInput = {
    where: LabOrderTestWhereUniqueInput
    data: XOR<LabOrderTestUpdateWithoutOrderInput, LabOrderTestUncheckedUpdateWithoutOrderInput>
  }

  export type LabOrderTestUpdateManyWithWhereWithoutOrderInput = {
    where: LabOrderTestScalarWhereInput
    data: XOR<LabOrderTestUpdateManyMutationInput, LabOrderTestUncheckedUpdateManyWithoutOrderInput>
  }

  export type TelemedicineConsultationUpsertWithoutLabOrdersInput = {
    update: XOR<TelemedicineConsultationUpdateWithoutLabOrdersInput, TelemedicineConsultationUncheckedUpdateWithoutLabOrdersInput>
    create: XOR<TelemedicineConsultationCreateWithoutLabOrdersInput, TelemedicineConsultationUncheckedCreateWithoutLabOrdersInput>
    where?: TelemedicineConsultationWhereInput
  }

  export type TelemedicineConsultationUpdateToOneWithWhereWithoutLabOrdersInput = {
    where?: TelemedicineConsultationWhereInput
    data: XOR<TelemedicineConsultationUpdateWithoutLabOrdersInput, TelemedicineConsultationUncheckedUpdateWithoutLabOrdersInput>
  }

  export type TelemedicineConsultationUpdateWithoutLabOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTelemedicineStatusFieldUpdateOperationsInput | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    consultationType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutTelemedicineConsultationsNestedInput
    doctor?: UserUpdateOneWithoutDoctorTelemedicineNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTelemedicineConsultationsNestedInput
    videoRoom?: VideoRoomUpdateOneWithoutConsultationNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutConsultationNestedInput
  }

  export type TelemedicineConsultationUncheckedUpdateWithoutLabOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTelemedicineStatusFieldUpdateOperationsInput | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    consultationType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoRoom?: VideoRoomUncheckedUpdateOneWithoutConsultationNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type TenantCreateWithoutLabOrderTestsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutLabOrderTestsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutLabOrderTestsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutLabOrderTestsInput, TenantUncheckedCreateWithoutLabOrderTestsInput>
  }

  export type LabTestCreateWithoutLabOrdersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    category: string
    price?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutLabTestsInput
  }

  export type LabTestUncheckedCreateWithoutLabOrdersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    category: string
    price?: number | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabTestCreateOrConnectWithoutLabOrdersInput = {
    where: LabTestWhereUniqueInput
    create: XOR<LabTestCreateWithoutLabOrdersInput, LabTestUncheckedCreateWithoutLabOrdersInput>
  }

  export type LabOrderCreateWithoutTestsInput = {
    id?: string
    orderNumber: string
    status?: $Enums.LabOrderStatus
    orderDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutLabOrdersInput
    doctor?: UserCreateNestedOneWithoutDoctorLabOrdersInput
    patient: PatientCreateNestedOneWithoutLabOrdersInput
    consultation?: TelemedicineConsultationCreateNestedOneWithoutLabOrdersInput
  }

  export type LabOrderUncheckedCreateWithoutTestsInput = {
    id?: string
    orderNumber: string
    patientId: string
    doctorId?: string | null
    status?: $Enums.LabOrderStatus
    orderDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationId?: string | null
  }

  export type LabOrderCreateOrConnectWithoutTestsInput = {
    where: LabOrderWhereUniqueInput
    create: XOR<LabOrderCreateWithoutTestsInput, LabOrderUncheckedCreateWithoutTestsInput>
  }

  export type TenantUpsertWithoutLabOrderTestsInput = {
    update: XOR<TenantUpdateWithoutLabOrderTestsInput, TenantUncheckedUpdateWithoutLabOrderTestsInput>
    create: XOR<TenantCreateWithoutLabOrderTestsInput, TenantUncheckedCreateWithoutLabOrderTestsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutLabOrderTestsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutLabOrderTestsInput, TenantUncheckedUpdateWithoutLabOrderTestsInput>
  }

  export type TenantUpdateWithoutLabOrderTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutLabOrderTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type LabTestUpsertWithoutLabOrdersInput = {
    update: XOR<LabTestUpdateWithoutLabOrdersInput, LabTestUncheckedUpdateWithoutLabOrdersInput>
    create: XOR<LabTestCreateWithoutLabOrdersInput, LabTestUncheckedCreateWithoutLabOrdersInput>
    where?: LabTestWhereInput
  }

  export type LabTestUpdateToOneWithWhereWithoutLabOrdersInput = {
    where?: LabTestWhereInput
    data: XOR<LabTestUpdateWithoutLabOrdersInput, LabTestUncheckedUpdateWithoutLabOrdersInput>
  }

  export type LabTestUpdateWithoutLabOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutLabTestsNestedInput
  }

  export type LabTestUncheckedUpdateWithoutLabOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabOrderUpsertWithoutTestsInput = {
    update: XOR<LabOrderUpdateWithoutTestsInput, LabOrderUncheckedUpdateWithoutTestsInput>
    create: XOR<LabOrderCreateWithoutTestsInput, LabOrderUncheckedCreateWithoutTestsInput>
    where?: LabOrderWhereInput
  }

  export type LabOrderUpdateToOneWithWhereWithoutTestsInput = {
    where?: LabOrderWhereInput
    data: XOR<LabOrderUpdateWithoutTestsInput, LabOrderUncheckedUpdateWithoutTestsInput>
  }

  export type LabOrderUpdateWithoutTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutLabOrdersNestedInput
    doctor?: UserUpdateOneWithoutDoctorLabOrdersNestedInput
    patient?: PatientUpdateOneRequiredWithoutLabOrdersNestedInput
    consultation?: TelemedicineConsultationUpdateOneWithoutLabOrdersNestedInput
  }

  export type LabOrderUncheckedUpdateWithoutTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TenantCreateWithoutMedicationsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutMedicationsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutMedicationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutMedicationsInput, TenantUncheckedCreateWithoutMedicationsInput>
  }

  export type PharmacyOrderItemCreateWithoutMedicationInput = {
    id?: string
    quantity?: number
    dosage?: string | null
    frequency?: string | null
    duration?: string | null
    instructions?: string | null
    status?: $Enums.PharmacyItemStatus
    tenant: TenantCreateNestedOneWithoutPharmacyOrderItemsInput
    order: PharmacyOrderCreateNestedOneWithoutItemsInput
  }

  export type PharmacyOrderItemUncheckedCreateWithoutMedicationInput = {
    id?: string
    orderId: string
    quantity?: number
    dosage?: string | null
    frequency?: string | null
    duration?: string | null
    instructions?: string | null
    status?: $Enums.PharmacyItemStatus
    tenantId: string
  }

  export type PharmacyOrderItemCreateOrConnectWithoutMedicationInput = {
    where: PharmacyOrderItemWhereUniqueInput
    create: XOR<PharmacyOrderItemCreateWithoutMedicationInput, PharmacyOrderItemUncheckedCreateWithoutMedicationInput>
  }

  export type PharmacyOrderItemCreateManyMedicationInputEnvelope = {
    data: PharmacyOrderItemCreateManyMedicationInput | PharmacyOrderItemCreateManyMedicationInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionItemCreateWithoutMedicationInput = {
    id?: string
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    isDispensed?: boolean
    tenant: TenantCreateNestedOneWithoutPrescriptionItemsInput
    patient: PatientCreateNestedOneWithoutPrescriptionItemsInput
    prescription: PrescriptionCreateNestedOneWithoutPrescriptionItemsInput
  }

  export type PrescriptionItemUncheckedCreateWithoutMedicationInput = {
    id?: string
    prescriptionId: string
    patientId: string
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    isDispensed?: boolean
    tenantId: string
  }

  export type PrescriptionItemCreateOrConnectWithoutMedicationInput = {
    where: PrescriptionItemWhereUniqueInput
    create: XOR<PrescriptionItemCreateWithoutMedicationInput, PrescriptionItemUncheckedCreateWithoutMedicationInput>
  }

  export type PrescriptionItemCreateManyMedicationInputEnvelope = {
    data: PrescriptionItemCreateManyMedicationInput | PrescriptionItemCreateManyMedicationInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutMedicationsInput = {
    update: XOR<TenantUpdateWithoutMedicationsInput, TenantUncheckedUpdateWithoutMedicationsInput>
    create: XOR<TenantCreateWithoutMedicationsInput, TenantUncheckedCreateWithoutMedicationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutMedicationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutMedicationsInput, TenantUncheckedUpdateWithoutMedicationsInput>
  }

  export type TenantUpdateWithoutMedicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutMedicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type PharmacyOrderItemUpsertWithWhereUniqueWithoutMedicationInput = {
    where: PharmacyOrderItemWhereUniqueInput
    update: XOR<PharmacyOrderItemUpdateWithoutMedicationInput, PharmacyOrderItemUncheckedUpdateWithoutMedicationInput>
    create: XOR<PharmacyOrderItemCreateWithoutMedicationInput, PharmacyOrderItemUncheckedCreateWithoutMedicationInput>
  }

  export type PharmacyOrderItemUpdateWithWhereUniqueWithoutMedicationInput = {
    where: PharmacyOrderItemWhereUniqueInput
    data: XOR<PharmacyOrderItemUpdateWithoutMedicationInput, PharmacyOrderItemUncheckedUpdateWithoutMedicationInput>
  }

  export type PharmacyOrderItemUpdateManyWithWhereWithoutMedicationInput = {
    where: PharmacyOrderItemScalarWhereInput
    data: XOR<PharmacyOrderItemUpdateManyMutationInput, PharmacyOrderItemUncheckedUpdateManyWithoutMedicationInput>
  }

  export type PrescriptionItemUpsertWithWhereUniqueWithoutMedicationInput = {
    where: PrescriptionItemWhereUniqueInput
    update: XOR<PrescriptionItemUpdateWithoutMedicationInput, PrescriptionItemUncheckedUpdateWithoutMedicationInput>
    create: XOR<PrescriptionItemCreateWithoutMedicationInput, PrescriptionItemUncheckedCreateWithoutMedicationInput>
  }

  export type PrescriptionItemUpdateWithWhereUniqueWithoutMedicationInput = {
    where: PrescriptionItemWhereUniqueInput
    data: XOR<PrescriptionItemUpdateWithoutMedicationInput, PrescriptionItemUncheckedUpdateWithoutMedicationInput>
  }

  export type PrescriptionItemUpdateManyWithWhereWithoutMedicationInput = {
    where: PrescriptionItemScalarWhereInput
    data: XOR<PrescriptionItemUpdateManyMutationInput, PrescriptionItemUncheckedUpdateManyWithoutMedicationInput>
  }

  export type TenantCreateWithoutPharmacyOrdersInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPharmacyOrdersInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPharmacyOrdersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPharmacyOrdersInput, TenantUncheckedCreateWithoutPharmacyOrdersInput>
  }

  export type UserCreateWithoutDoctorPrescriptionsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    staff?: StaffCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordCreateNestedManyWithoutUpdatedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutDoctorPrescriptionsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    staff?: StaffUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutDoctorPrescriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoctorPrescriptionsInput, UserUncheckedCreateWithoutDoctorPrescriptionsInput>
  }

  export type PatientCreateWithoutPharmacyOrdersInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutPatientInput
    studies?: StudyCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutPatientInput
    tenant: TenantCreateNestedOneWithoutPatientsInput
  }

  export type PatientUncheckedCreateWithoutPharmacyOrdersInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    tenantId: string
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutPatientInput
    studies?: StudyUncheckedCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPharmacyOrdersInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPharmacyOrdersInput, PatientUncheckedCreateWithoutPharmacyOrdersInput>
  }

  export type InvoiceCreateWithoutPharmacyOrderInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    subTotal?: number
    taxAmount?: number
    discountAmount?: number
    totalAmount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    patient: PatientCreateNestedOneWithoutInvoicesInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPharmacyOrderInput = {
    id?: string
    invoiceNumber: string
    patientId: string
    date?: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    subTotal?: number
    taxAmount?: number
    discountAmount?: number
    totalAmount?: number
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPharmacyOrderInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPharmacyOrderInput, InvoiceUncheckedCreateWithoutPharmacyOrderInput>
  }

  export type PharmacyOrderItemCreateWithoutOrderInput = {
    id?: string
    quantity?: number
    dosage?: string | null
    frequency?: string | null
    duration?: string | null
    instructions?: string | null
    status?: $Enums.PharmacyItemStatus
    tenant: TenantCreateNestedOneWithoutPharmacyOrderItemsInput
    medication: MedicationCreateNestedOneWithoutPharmacyOrderItemsInput
  }

  export type PharmacyOrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    medicationId: string
    quantity?: number
    dosage?: string | null
    frequency?: string | null
    duration?: string | null
    instructions?: string | null
    status?: $Enums.PharmacyItemStatus
    tenantId: string
  }

  export type PharmacyOrderItemCreateOrConnectWithoutOrderInput = {
    where: PharmacyOrderItemWhereUniqueInput
    create: XOR<PharmacyOrderItemCreateWithoutOrderInput, PharmacyOrderItemUncheckedCreateWithoutOrderInput>
  }

  export type PharmacyOrderItemCreateManyOrderInputEnvelope = {
    data: PharmacyOrderItemCreateManyOrderInput | PharmacyOrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutPharmacyOrdersInput = {
    update: XOR<TenantUpdateWithoutPharmacyOrdersInput, TenantUncheckedUpdateWithoutPharmacyOrdersInput>
    create: XOR<TenantCreateWithoutPharmacyOrdersInput, TenantUncheckedCreateWithoutPharmacyOrdersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPharmacyOrdersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPharmacyOrdersInput, TenantUncheckedUpdateWithoutPharmacyOrdersInput>
  }

  export type TenantUpdateWithoutPharmacyOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPharmacyOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutDoctorPrescriptionsInput = {
    update: XOR<UserUpdateWithoutDoctorPrescriptionsInput, UserUncheckedUpdateWithoutDoctorPrescriptionsInput>
    create: XOR<UserCreateWithoutDoctorPrescriptionsInput, UserUncheckedCreateWithoutDoctorPrescriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDoctorPrescriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDoctorPrescriptionsInput, UserUncheckedUpdateWithoutDoctorPrescriptionsInput>
  }

  export type UserUpdateWithoutDoctorPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUpdateManyWithoutUpdatedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutDoctorPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    staff?: StaffUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type PatientUpsertWithoutPharmacyOrdersInput = {
    update: XOR<PatientUpdateWithoutPharmacyOrdersInput, PatientUncheckedUpdateWithoutPharmacyOrdersInput>
    create: XOR<PatientCreateWithoutPharmacyOrdersInput, PatientUncheckedCreateWithoutPharmacyOrdersInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPharmacyOrdersInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPharmacyOrdersInput, PatientUncheckedUpdateWithoutPharmacyOrdersInput>
  }

  export type PatientUpdateWithoutPharmacyOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutPatientNestedInput
    studies?: StudyUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutPatientNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateWithoutPharmacyOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutPatientNestedInput
    studies?: StudyUncheckedUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type InvoiceUpsertWithoutPharmacyOrderInput = {
    update: XOR<InvoiceUpdateWithoutPharmacyOrderInput, InvoiceUncheckedUpdateWithoutPharmacyOrderInput>
    create: XOR<InvoiceCreateWithoutPharmacyOrderInput, InvoiceUncheckedCreateWithoutPharmacyOrderInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPharmacyOrderInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPharmacyOrderInput, InvoiceUncheckedUpdateWithoutPharmacyOrderInput>
  }

  export type InvoiceUpdateWithoutPharmacyOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    patient?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPharmacyOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type PharmacyOrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: PharmacyOrderItemWhereUniqueInput
    update: XOR<PharmacyOrderItemUpdateWithoutOrderInput, PharmacyOrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<PharmacyOrderItemCreateWithoutOrderInput, PharmacyOrderItemUncheckedCreateWithoutOrderInput>
  }

  export type PharmacyOrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: PharmacyOrderItemWhereUniqueInput
    data: XOR<PharmacyOrderItemUpdateWithoutOrderInput, PharmacyOrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type PharmacyOrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: PharmacyOrderItemScalarWhereInput
    data: XOR<PharmacyOrderItemUpdateManyMutationInput, PharmacyOrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type TenantCreateWithoutPharmacyOrderItemsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPharmacyOrderItemsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPharmacyOrderItemsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPharmacyOrderItemsInput, TenantUncheckedCreateWithoutPharmacyOrderItemsInput>
  }

  export type MedicationCreateWithoutPharmacyOrderItemsInput = {
    id?: string
    name: string
    genericName?: string | null
    description?: string | null
    strength?: string | null
    unit?: string | null
    dosageForm?: string | null
    route?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMedicationsInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutMedicationInput
  }

  export type MedicationUncheckedCreateWithoutPharmacyOrderItemsInput = {
    id?: string
    name: string
    genericName?: string | null
    description?: string | null
    strength?: string | null
    unit?: string | null
    dosageForm?: string | null
    route?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutMedicationInput
  }

  export type MedicationCreateOrConnectWithoutPharmacyOrderItemsInput = {
    where: MedicationWhereUniqueInput
    create: XOR<MedicationCreateWithoutPharmacyOrderItemsInput, MedicationUncheckedCreateWithoutPharmacyOrderItemsInput>
  }

  export type PharmacyOrderCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    status?: $Enums.PharmacyOrderStatus
    orderDate?: Date | string
    dispensedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
    tenant: TenantCreateNestedOneWithoutPharmacyOrdersInput
    doctor?: UserCreateNestedOneWithoutDoctorPrescriptionsInput
    patient: PatientCreateNestedOneWithoutPharmacyOrdersInput
    invoice?: InvoiceCreateNestedOneWithoutPharmacyOrderInput
  }

  export type PharmacyOrderUncheckedCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    patientId: string
    doctorId?: string | null
    status?: $Enums.PharmacyOrderStatus
    orderDate?: Date | string
    dispensedDate?: Date | string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type PharmacyOrderCreateOrConnectWithoutItemsInput = {
    where: PharmacyOrderWhereUniqueInput
    create: XOR<PharmacyOrderCreateWithoutItemsInput, PharmacyOrderUncheckedCreateWithoutItemsInput>
  }

  export type TenantUpsertWithoutPharmacyOrderItemsInput = {
    update: XOR<TenantUpdateWithoutPharmacyOrderItemsInput, TenantUncheckedUpdateWithoutPharmacyOrderItemsInput>
    create: XOR<TenantCreateWithoutPharmacyOrderItemsInput, TenantUncheckedCreateWithoutPharmacyOrderItemsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPharmacyOrderItemsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPharmacyOrderItemsInput, TenantUncheckedUpdateWithoutPharmacyOrderItemsInput>
  }

  export type TenantUpdateWithoutPharmacyOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPharmacyOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type MedicationUpsertWithoutPharmacyOrderItemsInput = {
    update: XOR<MedicationUpdateWithoutPharmacyOrderItemsInput, MedicationUncheckedUpdateWithoutPharmacyOrderItemsInput>
    create: XOR<MedicationCreateWithoutPharmacyOrderItemsInput, MedicationUncheckedCreateWithoutPharmacyOrderItemsInput>
    where?: MedicationWhereInput
  }

  export type MedicationUpdateToOneWithWhereWithoutPharmacyOrderItemsInput = {
    where?: MedicationWhereInput
    data: XOR<MedicationUpdateWithoutPharmacyOrderItemsInput, MedicationUncheckedUpdateWithoutPharmacyOrderItemsInput>
  }

  export type MedicationUpdateWithoutPharmacyOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMedicationsNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutMedicationNestedInput
  }

  export type MedicationUncheckedUpdateWithoutPharmacyOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutMedicationNestedInput
  }

  export type PharmacyOrderUpsertWithoutItemsInput = {
    update: XOR<PharmacyOrderUpdateWithoutItemsInput, PharmacyOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<PharmacyOrderCreateWithoutItemsInput, PharmacyOrderUncheckedCreateWithoutItemsInput>
    where?: PharmacyOrderWhereInput
  }

  export type PharmacyOrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: PharmacyOrderWhereInput
    data: XOR<PharmacyOrderUpdateWithoutItemsInput, PharmacyOrderUncheckedUpdateWithoutItemsInput>
  }

  export type PharmacyOrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumPharmacyOrderStatusFieldUpdateOperationsInput | $Enums.PharmacyOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dispensedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutPharmacyOrdersNestedInput
    doctor?: UserUpdateOneWithoutDoctorPrescriptionsNestedInput
    patient?: PatientUpdateOneRequiredWithoutPharmacyOrdersNestedInput
    invoice?: InvoiceUpdateOneWithoutPharmacyOrderNestedInput
  }

  export type PharmacyOrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPharmacyOrderStatusFieldUpdateOperationsInput | $Enums.PharmacyOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dispensedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TenantCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAuditLogsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    staff?: StaffCreateNestedOneWithoutUserInput
    createdMedicalRecords?: MedicalRecordCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordCreateNestedManyWithoutUpdatedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderUncheckedCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    staff?: StaffUncheckedCreateNestedOneWithoutUserInput
    createdMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type TenantUpsertWithoutAuditLogsInput = {
    update: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type TenantUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUpdateManyWithoutUpdatedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUncheckedUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    staff?: StaffUncheckedUpdateOneWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type StudyCreateWithoutModalityInput = {
    id?: string
    studyId: string
    patientName: string
    status?: $Enums.StudyStatus
    studyDate?: Date | string
    priority?: $Enums.Priority | null
    description?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutStudiesInput
    tenant: TenantCreateNestedOneWithoutStudiesInput
    series?: SeriesCreateNestedManyWithoutStudyInput
    radReports?: RadReportCreateNestedManyWithoutStudyInput
    radiationDoses?: RadiationDoseCreateNestedManyWithoutStudyInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutStudyInput
  }

  export type StudyUncheckedCreateWithoutModalityInput = {
    id?: string
    studyId: string
    patientId: string
    patientName: string
    status?: $Enums.StudyStatus
    studyDate?: Date | string
    priority?: $Enums.Priority | null
    description?: string | null
    notes?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    series?: SeriesUncheckedCreateNestedManyWithoutStudyInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutStudyInput
    radiationDoses?: RadiationDoseUncheckedCreateNestedManyWithoutStudyInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutStudyInput
  }

  export type StudyCreateOrConnectWithoutModalityInput = {
    where: StudyWhereUniqueInput
    create: XOR<StudyCreateWithoutModalityInput, StudyUncheckedCreateWithoutModalityInput>
  }

  export type StudyCreateManyModalityInputEnvelope = {
    data: StudyCreateManyModalityInput | StudyCreateManyModalityInput[]
    skipDuplicates?: boolean
  }

  export type RadiologyOrderCreateWithoutModalityInput = {
    id?: string
    studyType: string
    priority?: $Enums.Priority
    reason?: string | null
    clinicalHistory?: string | null
    status?: $Enums.RadiologyOrderStatus
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    consultation: TelemedicineConsultationCreateNestedOneWithoutRadiologyOrdersInput
    patient: PatientCreateNestedOneWithoutRadiologyOrdersInput
    doctor: UserCreateNestedOneWithoutDoctorRadiologyOrdersInput
    tenant: TenantCreateNestedOneWithoutRadiologyOrdersInput
    study?: StudyCreateNestedOneWithoutRadiologyOrdersInput
  }

  export type RadiologyOrderUncheckedCreateWithoutModalityInput = {
    id?: string
    consultationId: string
    patientId: string
    doctorId: string
    studyType: string
    priority?: $Enums.Priority
    reason?: string | null
    clinicalHistory?: string | null
    status?: $Enums.RadiologyOrderStatus
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studyId?: string | null
  }

  export type RadiologyOrderCreateOrConnectWithoutModalityInput = {
    where: RadiologyOrderWhereUniqueInput
    create: XOR<RadiologyOrderCreateWithoutModalityInput, RadiologyOrderUncheckedCreateWithoutModalityInput>
  }

  export type RadiologyOrderCreateManyModalityInputEnvelope = {
    data: RadiologyOrderCreateManyModalityInput | RadiologyOrderCreateManyModalityInput[]
    skipDuplicates?: boolean
  }

  export type StudyUpsertWithWhereUniqueWithoutModalityInput = {
    where: StudyWhereUniqueInput
    update: XOR<StudyUpdateWithoutModalityInput, StudyUncheckedUpdateWithoutModalityInput>
    create: XOR<StudyCreateWithoutModalityInput, StudyUncheckedCreateWithoutModalityInput>
  }

  export type StudyUpdateWithWhereUniqueWithoutModalityInput = {
    where: StudyWhereUniqueInput
    data: XOR<StudyUpdateWithoutModalityInput, StudyUncheckedUpdateWithoutModalityInput>
  }

  export type StudyUpdateManyWithWhereWithoutModalityInput = {
    where: StudyScalarWhereInput
    data: XOR<StudyUpdateManyMutationInput, StudyUncheckedUpdateManyWithoutModalityInput>
  }

  export type RadiologyOrderUpsertWithWhereUniqueWithoutModalityInput = {
    where: RadiologyOrderWhereUniqueInput
    update: XOR<RadiologyOrderUpdateWithoutModalityInput, RadiologyOrderUncheckedUpdateWithoutModalityInput>
    create: XOR<RadiologyOrderCreateWithoutModalityInput, RadiologyOrderUncheckedCreateWithoutModalityInput>
  }

  export type RadiologyOrderUpdateWithWhereUniqueWithoutModalityInput = {
    where: RadiologyOrderWhereUniqueInput
    data: XOR<RadiologyOrderUpdateWithoutModalityInput, RadiologyOrderUncheckedUpdateWithoutModalityInput>
  }

  export type RadiologyOrderUpdateManyWithWhereWithoutModalityInput = {
    where: RadiologyOrderScalarWhereInput
    data: XOR<RadiologyOrderUpdateManyMutationInput, RadiologyOrderUncheckedUpdateManyWithoutModalityInput>
  }

  export type ModalityCreateWithoutStudiesInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutModalityInput
  }

  export type ModalityUncheckedCreateWithoutStudiesInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutModalityInput
  }

  export type ModalityCreateOrConnectWithoutStudiesInput = {
    where: ModalityWhereUniqueInput
    create: XOR<ModalityCreateWithoutStudiesInput, ModalityUncheckedCreateWithoutStudiesInput>
  }

  export type PatientCreateWithoutStudiesInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutPatientInput
    tenant: TenantCreateNestedOneWithoutPatientsInput
  }

  export type PatientUncheckedCreateWithoutStudiesInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    tenantId: string
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutStudiesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutStudiesInput, PatientUncheckedCreateWithoutStudiesInput>
  }

  export type TenantCreateWithoutStudiesInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutStudiesInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutStudiesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutStudiesInput, TenantUncheckedCreateWithoutStudiesInput>
  }

  export type SeriesCreateWithoutStudyInput = {
    id?: string
    seriesUid: string
    number: number
    description?: string | null
    modality: string
    bodyPart?: string | null
    count?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUncheckedCreateWithoutStudyInput = {
    id?: string
    seriesUid: string
    number: number
    description?: string | null
    modality: string
    bodyPart?: string | null
    count?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type SeriesCreateOrConnectWithoutStudyInput = {
    where: SeriesWhereUniqueInput
    create: XOR<SeriesCreateWithoutStudyInput, SeriesUncheckedCreateWithoutStudyInput>
  }

  export type SeriesCreateManyStudyInputEnvelope = {
    data: SeriesCreateManyStudyInput | SeriesCreateManyStudyInput[]
    skipDuplicates?: boolean
  }

  export type RadReportCreateWithoutStudyInput = {
    id?: string
    reportId: string
    status?: $Enums.ReportStatus
    findings?: string | null
    impression?: string | null
    conclusion?: string | null
    reportDateTime?: Date | string
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutRadReportsInput
    reportTemplate?: ReportTemplateCreateNestedOneWithoutRadReportsInput
  }

  export type RadReportUncheckedCreateWithoutStudyInput = {
    id?: string
    reportId: string
    reportTemplateId?: string | null
    status?: $Enums.ReportStatus
    findings?: string | null
    impression?: string | null
    conclusion?: string | null
    reportDateTime?: Date | string
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadReportCreateOrConnectWithoutStudyInput = {
    where: RadReportWhereUniqueInput
    create: XOR<RadReportCreateWithoutStudyInput, RadReportUncheckedCreateWithoutStudyInput>
  }

  export type RadReportCreateManyStudyInputEnvelope = {
    data: RadReportCreateManyStudyInput | RadReportCreateManyStudyInput[]
    skipDuplicates?: boolean
  }

  export type RadiationDoseCreateWithoutStudyInput = {
    id?: string
    deviceName?: string | null
    deviceType?: string | null
    exposureTime?: number | null
    kvp?: number | null
    ma?: number | null
    doseAreaProduct?: number | null
    doseLengthProduct?: number | null
    ctdiVol?: number | null
    dlp?: number | null
    effectiveDose?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiationDoseUncheckedCreateWithoutStudyInput = {
    id?: string
    deviceName?: string | null
    deviceType?: string | null
    exposureTime?: number | null
    kvp?: number | null
    ma?: number | null
    doseAreaProduct?: number | null
    doseLengthProduct?: number | null
    ctdiVol?: number | null
    dlp?: number | null
    effectiveDose?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiationDoseCreateOrConnectWithoutStudyInput = {
    where: RadiationDoseWhereUniqueInput
    create: XOR<RadiationDoseCreateWithoutStudyInput, RadiationDoseUncheckedCreateWithoutStudyInput>
  }

  export type RadiationDoseCreateManyStudyInputEnvelope = {
    data: RadiationDoseCreateManyStudyInput | RadiationDoseCreateManyStudyInput[]
    skipDuplicates?: boolean
  }

  export type RadiologyOrderCreateWithoutStudyInput = {
    id?: string
    studyType: string
    priority?: $Enums.Priority
    reason?: string | null
    clinicalHistory?: string | null
    status?: $Enums.RadiologyOrderStatus
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    consultation: TelemedicineConsultationCreateNestedOneWithoutRadiologyOrdersInput
    patient: PatientCreateNestedOneWithoutRadiologyOrdersInput
    doctor: UserCreateNestedOneWithoutDoctorRadiologyOrdersInput
    modality: ModalityCreateNestedOneWithoutRadiologyOrdersInput
    tenant: TenantCreateNestedOneWithoutRadiologyOrdersInput
  }

  export type RadiologyOrderUncheckedCreateWithoutStudyInput = {
    id?: string
    consultationId: string
    patientId: string
    doctorId: string
    modalityId: string
    studyType: string
    priority?: $Enums.Priority
    reason?: string | null
    clinicalHistory?: string | null
    status?: $Enums.RadiologyOrderStatus
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiologyOrderCreateOrConnectWithoutStudyInput = {
    where: RadiologyOrderWhereUniqueInput
    create: XOR<RadiologyOrderCreateWithoutStudyInput, RadiologyOrderUncheckedCreateWithoutStudyInput>
  }

  export type RadiologyOrderCreateManyStudyInputEnvelope = {
    data: RadiologyOrderCreateManyStudyInput | RadiologyOrderCreateManyStudyInput[]
    skipDuplicates?: boolean
  }

  export type ModalityUpsertWithoutStudiesInput = {
    update: XOR<ModalityUpdateWithoutStudiesInput, ModalityUncheckedUpdateWithoutStudiesInput>
    create: XOR<ModalityCreateWithoutStudiesInput, ModalityUncheckedCreateWithoutStudiesInput>
    where?: ModalityWhereInput
  }

  export type ModalityUpdateToOneWithWhereWithoutStudiesInput = {
    where?: ModalityWhereInput
    data: XOR<ModalityUpdateWithoutStudiesInput, ModalityUncheckedUpdateWithoutStudiesInput>
  }

  export type ModalityUpdateWithoutStudiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    radiologyOrders?: RadiologyOrderUpdateManyWithoutModalityNestedInput
  }

  export type ModalityUncheckedUpdateWithoutStudiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutModalityNestedInput
  }

  export type PatientUpsertWithoutStudiesInput = {
    update: XOR<PatientUpdateWithoutStudiesInput, PatientUncheckedUpdateWithoutStudiesInput>
    create: XOR<PatientCreateWithoutStudiesInput, PatientUncheckedCreateWithoutStudiesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutStudiesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutStudiesInput, PatientUncheckedUpdateWithoutStudiesInput>
  }

  export type PatientUpdateWithoutStudiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutPatientNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateWithoutStudiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type TenantUpsertWithoutStudiesInput = {
    update: XOR<TenantUpdateWithoutStudiesInput, TenantUncheckedUpdateWithoutStudiesInput>
    create: XOR<TenantCreateWithoutStudiesInput, TenantUncheckedCreateWithoutStudiesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutStudiesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutStudiesInput, TenantUncheckedUpdateWithoutStudiesInput>
  }

  export type TenantUpdateWithoutStudiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutStudiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SeriesUpsertWithWhereUniqueWithoutStudyInput = {
    where: SeriesWhereUniqueInput
    update: XOR<SeriesUpdateWithoutStudyInput, SeriesUncheckedUpdateWithoutStudyInput>
    create: XOR<SeriesCreateWithoutStudyInput, SeriesUncheckedCreateWithoutStudyInput>
  }

  export type SeriesUpdateWithWhereUniqueWithoutStudyInput = {
    where: SeriesWhereUniqueInput
    data: XOR<SeriesUpdateWithoutStudyInput, SeriesUncheckedUpdateWithoutStudyInput>
  }

  export type SeriesUpdateManyWithWhereWithoutStudyInput = {
    where: SeriesScalarWhereInput
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyWithoutStudyInput>
  }

  export type SeriesScalarWhereInput = {
    AND?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
    OR?: SeriesScalarWhereInput[]
    NOT?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
    id?: StringFilter<"Series"> | string
    seriesUid?: StringFilter<"Series"> | string
    studyId?: StringFilter<"Series"> | string
    number?: IntFilter<"Series"> | number
    description?: StringNullableFilter<"Series"> | string | null
    modality?: StringFilter<"Series"> | string
    bodyPart?: StringNullableFilter<"Series"> | string | null
    count?: IntFilter<"Series"> | number
    isActive?: BoolFilter<"Series"> | boolean
    createdAt?: DateTimeFilter<"Series"> | Date | string
    updatedAt?: DateTimeFilter<"Series"> | Date | string
  }

  export type RadReportUpsertWithWhereUniqueWithoutStudyInput = {
    where: RadReportWhereUniqueInput
    update: XOR<RadReportUpdateWithoutStudyInput, RadReportUncheckedUpdateWithoutStudyInput>
    create: XOR<RadReportCreateWithoutStudyInput, RadReportUncheckedCreateWithoutStudyInput>
  }

  export type RadReportUpdateWithWhereUniqueWithoutStudyInput = {
    where: RadReportWhereUniqueInput
    data: XOR<RadReportUpdateWithoutStudyInput, RadReportUncheckedUpdateWithoutStudyInput>
  }

  export type RadReportUpdateManyWithWhereWithoutStudyInput = {
    where: RadReportScalarWhereInput
    data: XOR<RadReportUpdateManyMutationInput, RadReportUncheckedUpdateManyWithoutStudyInput>
  }

  export type RadiationDoseUpsertWithWhereUniqueWithoutStudyInput = {
    where: RadiationDoseWhereUniqueInput
    update: XOR<RadiationDoseUpdateWithoutStudyInput, RadiationDoseUncheckedUpdateWithoutStudyInput>
    create: XOR<RadiationDoseCreateWithoutStudyInput, RadiationDoseUncheckedCreateWithoutStudyInput>
  }

  export type RadiationDoseUpdateWithWhereUniqueWithoutStudyInput = {
    where: RadiationDoseWhereUniqueInput
    data: XOR<RadiationDoseUpdateWithoutStudyInput, RadiationDoseUncheckedUpdateWithoutStudyInput>
  }

  export type RadiationDoseUpdateManyWithWhereWithoutStudyInput = {
    where: RadiationDoseScalarWhereInput
    data: XOR<RadiationDoseUpdateManyMutationInput, RadiationDoseUncheckedUpdateManyWithoutStudyInput>
  }

  export type RadiationDoseScalarWhereInput = {
    AND?: RadiationDoseScalarWhereInput | RadiationDoseScalarWhereInput[]
    OR?: RadiationDoseScalarWhereInput[]
    NOT?: RadiationDoseScalarWhereInput | RadiationDoseScalarWhereInput[]
    id?: StringFilter<"RadiationDose"> | string
    studyId?: StringFilter<"RadiationDose"> | string
    deviceName?: StringNullableFilter<"RadiationDose"> | string | null
    deviceType?: StringNullableFilter<"RadiationDose"> | string | null
    exposureTime?: FloatNullableFilter<"RadiationDose"> | number | null
    kvp?: FloatNullableFilter<"RadiationDose"> | number | null
    ma?: FloatNullableFilter<"RadiationDose"> | number | null
    doseAreaProduct?: FloatNullableFilter<"RadiationDose"> | number | null
    doseLengthProduct?: FloatNullableFilter<"RadiationDose"> | number | null
    ctdiVol?: FloatNullableFilter<"RadiationDose"> | number | null
    dlp?: FloatNullableFilter<"RadiationDose"> | number | null
    effectiveDose?: FloatNullableFilter<"RadiationDose"> | number | null
    isActive?: BoolFilter<"RadiationDose"> | boolean
    createdAt?: DateTimeFilter<"RadiationDose"> | Date | string
    updatedAt?: DateTimeFilter<"RadiationDose"> | Date | string
  }

  export type RadiologyOrderUpsertWithWhereUniqueWithoutStudyInput = {
    where: RadiologyOrderWhereUniqueInput
    update: XOR<RadiologyOrderUpdateWithoutStudyInput, RadiologyOrderUncheckedUpdateWithoutStudyInput>
    create: XOR<RadiologyOrderCreateWithoutStudyInput, RadiologyOrderUncheckedCreateWithoutStudyInput>
  }

  export type RadiologyOrderUpdateWithWhereUniqueWithoutStudyInput = {
    where: RadiologyOrderWhereUniqueInput
    data: XOR<RadiologyOrderUpdateWithoutStudyInput, RadiologyOrderUncheckedUpdateWithoutStudyInput>
  }

  export type RadiologyOrderUpdateManyWithWhereWithoutStudyInput = {
    where: RadiologyOrderScalarWhereInput
    data: XOR<RadiologyOrderUpdateManyMutationInput, RadiologyOrderUncheckedUpdateManyWithoutStudyInput>
  }

  export type StudyCreateWithoutSeriesInput = {
    id?: string
    studyId: string
    patientName: string
    status?: $Enums.StudyStatus
    studyDate?: Date | string
    priority?: $Enums.Priority | null
    description?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modality: ModalityCreateNestedOneWithoutStudiesInput
    patient: PatientCreateNestedOneWithoutStudiesInput
    tenant: TenantCreateNestedOneWithoutStudiesInput
    radReports?: RadReportCreateNestedManyWithoutStudyInput
    radiationDoses?: RadiationDoseCreateNestedManyWithoutStudyInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutStudyInput
  }

  export type StudyUncheckedCreateWithoutSeriesInput = {
    id?: string
    studyId: string
    patientId: string
    patientName: string
    modalityId: string
    status?: $Enums.StudyStatus
    studyDate?: Date | string
    priority?: $Enums.Priority | null
    description?: string | null
    notes?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    radReports?: RadReportUncheckedCreateNestedManyWithoutStudyInput
    radiationDoses?: RadiationDoseUncheckedCreateNestedManyWithoutStudyInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutStudyInput
  }

  export type StudyCreateOrConnectWithoutSeriesInput = {
    where: StudyWhereUniqueInput
    create: XOR<StudyCreateWithoutSeriesInput, StudyUncheckedCreateWithoutSeriesInput>
  }

  export type ImageCreateWithoutSeriesInput = {
    id?: string
    sopInstanceUid: string
    number: number
    path: string
    size: number
    contentType: string
    width: number
    height: number
    windowCenter?: number | null
    windowWidth?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageUncheckedCreateWithoutSeriesInput = {
    id?: string
    sopInstanceUid: string
    number: number
    path: string
    size: number
    contentType: string
    width: number
    height: number
    windowCenter?: number | null
    windowWidth?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageCreateOrConnectWithoutSeriesInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutSeriesInput, ImageUncheckedCreateWithoutSeriesInput>
  }

  export type ImageCreateManySeriesInputEnvelope = {
    data: ImageCreateManySeriesInput | ImageCreateManySeriesInput[]
    skipDuplicates?: boolean
  }

  export type StudyUpsertWithoutSeriesInput = {
    update: XOR<StudyUpdateWithoutSeriesInput, StudyUncheckedUpdateWithoutSeriesInput>
    create: XOR<StudyCreateWithoutSeriesInput, StudyUncheckedCreateWithoutSeriesInput>
    where?: StudyWhereInput
  }

  export type StudyUpdateToOneWithWhereWithoutSeriesInput = {
    where?: StudyWhereInput
    data: XOR<StudyUpdateWithoutSeriesInput, StudyUncheckedUpdateWithoutSeriesInput>
  }

  export type StudyUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    patientName?: StringFieldUpdateOperationsInput | string
    status?: EnumStudyStatusFieldUpdateOperationsInput | $Enums.StudyStatus
    studyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modality?: ModalityUpdateOneRequiredWithoutStudiesNestedInput
    patient?: PatientUpdateOneRequiredWithoutStudiesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutStudiesNestedInput
    radReports?: RadReportUpdateManyWithoutStudyNestedInput
    radiationDoses?: RadiationDoseUpdateManyWithoutStudyNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutStudyNestedInput
  }

  export type StudyUncheckedUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientName?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    status?: EnumStudyStatusFieldUpdateOperationsInput | $Enums.StudyStatus
    studyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    radReports?: RadReportUncheckedUpdateManyWithoutStudyNestedInput
    radiationDoses?: RadiationDoseUncheckedUpdateManyWithoutStudyNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutStudyNestedInput
  }

  export type ImageUpsertWithWhereUniqueWithoutSeriesInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutSeriesInput, ImageUncheckedUpdateWithoutSeriesInput>
    create: XOR<ImageCreateWithoutSeriesInput, ImageUncheckedCreateWithoutSeriesInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutSeriesInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutSeriesInput, ImageUncheckedUpdateWithoutSeriesInput>
  }

  export type ImageUpdateManyWithWhereWithoutSeriesInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutSeriesInput>
  }

  export type ImageScalarWhereInput = {
    AND?: ImageScalarWhereInput | ImageScalarWhereInput[]
    OR?: ImageScalarWhereInput[]
    NOT?: ImageScalarWhereInput | ImageScalarWhereInput[]
    id?: StringFilter<"Image"> | string
    sopInstanceUid?: StringFilter<"Image"> | string
    seriesId?: StringFilter<"Image"> | string
    number?: IntFilter<"Image"> | number
    path?: StringFilter<"Image"> | string
    size?: IntFilter<"Image"> | number
    contentType?: StringFilter<"Image"> | string
    width?: IntFilter<"Image"> | number
    height?: IntFilter<"Image"> | number
    windowCenter?: FloatNullableFilter<"Image"> | number | null
    windowWidth?: FloatNullableFilter<"Image"> | number | null
    isActive?: BoolFilter<"Image"> | boolean
    createdAt?: DateTimeFilter<"Image"> | Date | string
    updatedAt?: DateTimeFilter<"Image"> | Date | string
  }

  export type SeriesCreateWithoutImagesInput = {
    id?: string
    seriesUid: string
    number: number
    description?: string | null
    modality: string
    bodyPart?: string | null
    count?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    study: StudyCreateNestedOneWithoutSeriesInput
  }

  export type SeriesUncheckedCreateWithoutImagesInput = {
    id?: string
    seriesUid: string
    studyId: string
    number: number
    description?: string | null
    modality: string
    bodyPart?: string | null
    count?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeriesCreateOrConnectWithoutImagesInput = {
    where: SeriesWhereUniqueInput
    create: XOR<SeriesCreateWithoutImagesInput, SeriesUncheckedCreateWithoutImagesInput>
  }

  export type SeriesUpsertWithoutImagesInput = {
    update: XOR<SeriesUpdateWithoutImagesInput, SeriesUncheckedUpdateWithoutImagesInput>
    create: XOR<SeriesCreateWithoutImagesInput, SeriesUncheckedCreateWithoutImagesInput>
    where?: SeriesWhereInput
  }

  export type SeriesUpdateToOneWithWhereWithoutImagesInput = {
    where?: SeriesWhereInput
    data: XOR<SeriesUpdateWithoutImagesInput, SeriesUncheckedUpdateWithoutImagesInput>
  }

  export type SeriesUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesUid?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    modality?: StringFieldUpdateOperationsInput | string
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    count?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    study?: StudyUpdateOneRequiredWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesUid?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    modality?: StringFieldUpdateOperationsInput | string
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    count?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyCreateWithoutRadReportsInput = {
    id?: string
    studyId: string
    patientName: string
    status?: $Enums.StudyStatus
    studyDate?: Date | string
    priority?: $Enums.Priority | null
    description?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modality: ModalityCreateNestedOneWithoutStudiesInput
    patient: PatientCreateNestedOneWithoutStudiesInput
    tenant: TenantCreateNestedOneWithoutStudiesInput
    series?: SeriesCreateNestedManyWithoutStudyInput
    radiationDoses?: RadiationDoseCreateNestedManyWithoutStudyInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutStudyInput
  }

  export type StudyUncheckedCreateWithoutRadReportsInput = {
    id?: string
    studyId: string
    patientId: string
    patientName: string
    modalityId: string
    status?: $Enums.StudyStatus
    studyDate?: Date | string
    priority?: $Enums.Priority | null
    description?: string | null
    notes?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    series?: SeriesUncheckedCreateNestedManyWithoutStudyInput
    radiationDoses?: RadiationDoseUncheckedCreateNestedManyWithoutStudyInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutStudyInput
  }

  export type StudyCreateOrConnectWithoutRadReportsInput = {
    where: StudyWhereUniqueInput
    create: XOR<StudyCreateWithoutRadReportsInput, StudyUncheckedCreateWithoutRadReportsInput>
  }

  export type TenantCreateWithoutRadReportsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutRadReportsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutRadReportsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutRadReportsInput, TenantUncheckedCreateWithoutRadReportsInput>
  }

  export type ReportTemplateCreateWithoutRadReportsInput = {
    id?: string
    name: string
    description?: string | null
    template: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutReportTemplatesInput
  }

  export type ReportTemplateUncheckedCreateWithoutRadReportsInput = {
    id?: string
    name: string
    description?: string | null
    template: string
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportTemplateCreateOrConnectWithoutRadReportsInput = {
    where: ReportTemplateWhereUniqueInput
    create: XOR<ReportTemplateCreateWithoutRadReportsInput, ReportTemplateUncheckedCreateWithoutRadReportsInput>
  }

  export type StudyUpsertWithoutRadReportsInput = {
    update: XOR<StudyUpdateWithoutRadReportsInput, StudyUncheckedUpdateWithoutRadReportsInput>
    create: XOR<StudyCreateWithoutRadReportsInput, StudyUncheckedCreateWithoutRadReportsInput>
    where?: StudyWhereInput
  }

  export type StudyUpdateToOneWithWhereWithoutRadReportsInput = {
    where?: StudyWhereInput
    data: XOR<StudyUpdateWithoutRadReportsInput, StudyUncheckedUpdateWithoutRadReportsInput>
  }

  export type StudyUpdateWithoutRadReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    patientName?: StringFieldUpdateOperationsInput | string
    status?: EnumStudyStatusFieldUpdateOperationsInput | $Enums.StudyStatus
    studyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modality?: ModalityUpdateOneRequiredWithoutStudiesNestedInput
    patient?: PatientUpdateOneRequiredWithoutStudiesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutStudiesNestedInput
    series?: SeriesUpdateManyWithoutStudyNestedInput
    radiationDoses?: RadiationDoseUpdateManyWithoutStudyNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutStudyNestedInput
  }

  export type StudyUncheckedUpdateWithoutRadReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientName?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    status?: EnumStudyStatusFieldUpdateOperationsInput | $Enums.StudyStatus
    studyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: SeriesUncheckedUpdateManyWithoutStudyNestedInput
    radiationDoses?: RadiationDoseUncheckedUpdateManyWithoutStudyNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutStudyNestedInput
  }

  export type TenantUpsertWithoutRadReportsInput = {
    update: XOR<TenantUpdateWithoutRadReportsInput, TenantUncheckedUpdateWithoutRadReportsInput>
    create: XOR<TenantCreateWithoutRadReportsInput, TenantUncheckedCreateWithoutRadReportsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutRadReportsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutRadReportsInput, TenantUncheckedUpdateWithoutRadReportsInput>
  }

  export type TenantUpdateWithoutRadReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutRadReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ReportTemplateUpsertWithoutRadReportsInput = {
    update: XOR<ReportTemplateUpdateWithoutRadReportsInput, ReportTemplateUncheckedUpdateWithoutRadReportsInput>
    create: XOR<ReportTemplateCreateWithoutRadReportsInput, ReportTemplateUncheckedCreateWithoutRadReportsInput>
    where?: ReportTemplateWhereInput
  }

  export type ReportTemplateUpdateToOneWithWhereWithoutRadReportsInput = {
    where?: ReportTemplateWhereInput
    data: XOR<ReportTemplateUpdateWithoutRadReportsInput, ReportTemplateUncheckedUpdateWithoutRadReportsInput>
  }

  export type ReportTemplateUpdateWithoutRadReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    template?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutReportTemplatesNestedInput
  }

  export type ReportTemplateUncheckedUpdateWithoutRadReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    template?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyCreateWithoutRadiationDosesInput = {
    id?: string
    studyId: string
    patientName: string
    status?: $Enums.StudyStatus
    studyDate?: Date | string
    priority?: $Enums.Priority | null
    description?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modality: ModalityCreateNestedOneWithoutStudiesInput
    patient: PatientCreateNestedOneWithoutStudiesInput
    tenant: TenantCreateNestedOneWithoutStudiesInput
    series?: SeriesCreateNestedManyWithoutStudyInput
    radReports?: RadReportCreateNestedManyWithoutStudyInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutStudyInput
  }

  export type StudyUncheckedCreateWithoutRadiationDosesInput = {
    id?: string
    studyId: string
    patientId: string
    patientName: string
    modalityId: string
    status?: $Enums.StudyStatus
    studyDate?: Date | string
    priority?: $Enums.Priority | null
    description?: string | null
    notes?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    series?: SeriesUncheckedCreateNestedManyWithoutStudyInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutStudyInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutStudyInput
  }

  export type StudyCreateOrConnectWithoutRadiationDosesInput = {
    where: StudyWhereUniqueInput
    create: XOR<StudyCreateWithoutRadiationDosesInput, StudyUncheckedCreateWithoutRadiationDosesInput>
  }

  export type StudyUpsertWithoutRadiationDosesInput = {
    update: XOR<StudyUpdateWithoutRadiationDosesInput, StudyUncheckedUpdateWithoutRadiationDosesInput>
    create: XOR<StudyCreateWithoutRadiationDosesInput, StudyUncheckedCreateWithoutRadiationDosesInput>
    where?: StudyWhereInput
  }

  export type StudyUpdateToOneWithWhereWithoutRadiationDosesInput = {
    where?: StudyWhereInput
    data: XOR<StudyUpdateWithoutRadiationDosesInput, StudyUncheckedUpdateWithoutRadiationDosesInput>
  }

  export type StudyUpdateWithoutRadiationDosesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    patientName?: StringFieldUpdateOperationsInput | string
    status?: EnumStudyStatusFieldUpdateOperationsInput | $Enums.StudyStatus
    studyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modality?: ModalityUpdateOneRequiredWithoutStudiesNestedInput
    patient?: PatientUpdateOneRequiredWithoutStudiesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutStudiesNestedInput
    series?: SeriesUpdateManyWithoutStudyNestedInput
    radReports?: RadReportUpdateManyWithoutStudyNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutStudyNestedInput
  }

  export type StudyUncheckedUpdateWithoutRadiationDosesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientName?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    status?: EnumStudyStatusFieldUpdateOperationsInput | $Enums.StudyStatus
    studyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: SeriesUncheckedUpdateManyWithoutStudyNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutStudyNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutStudyNestedInput
  }

  export type TenantCreateWithoutReportTemplatesInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutReportTemplatesInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutReportTemplatesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutReportTemplatesInput, TenantUncheckedCreateWithoutReportTemplatesInput>
  }

  export type RadReportCreateWithoutReportTemplateInput = {
    id?: string
    reportId: string
    status?: $Enums.ReportStatus
    findings?: string | null
    impression?: string | null
    conclusion?: string | null
    reportDateTime?: Date | string
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    study: StudyCreateNestedOneWithoutRadReportsInput
    tenant: TenantCreateNestedOneWithoutRadReportsInput
  }

  export type RadReportUncheckedCreateWithoutReportTemplateInput = {
    id?: string
    reportId: string
    studyId: string
    status?: $Enums.ReportStatus
    findings?: string | null
    impression?: string | null
    conclusion?: string | null
    reportDateTime?: Date | string
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadReportCreateOrConnectWithoutReportTemplateInput = {
    where: RadReportWhereUniqueInput
    create: XOR<RadReportCreateWithoutReportTemplateInput, RadReportUncheckedCreateWithoutReportTemplateInput>
  }

  export type RadReportCreateManyReportTemplateInputEnvelope = {
    data: RadReportCreateManyReportTemplateInput | RadReportCreateManyReportTemplateInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutReportTemplatesInput = {
    update: XOR<TenantUpdateWithoutReportTemplatesInput, TenantUncheckedUpdateWithoutReportTemplatesInput>
    create: XOR<TenantCreateWithoutReportTemplatesInput, TenantUncheckedCreateWithoutReportTemplatesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutReportTemplatesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutReportTemplatesInput, TenantUncheckedUpdateWithoutReportTemplatesInput>
  }

  export type TenantUpdateWithoutReportTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutReportTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type RadReportUpsertWithWhereUniqueWithoutReportTemplateInput = {
    where: RadReportWhereUniqueInput
    update: XOR<RadReportUpdateWithoutReportTemplateInput, RadReportUncheckedUpdateWithoutReportTemplateInput>
    create: XOR<RadReportCreateWithoutReportTemplateInput, RadReportUncheckedCreateWithoutReportTemplateInput>
  }

  export type RadReportUpdateWithWhereUniqueWithoutReportTemplateInput = {
    where: RadReportWhereUniqueInput
    data: XOR<RadReportUpdateWithoutReportTemplateInput, RadReportUncheckedUpdateWithoutReportTemplateInput>
  }

  export type RadReportUpdateManyWithWhereWithoutReportTemplateInput = {
    where: RadReportScalarWhereInput
    data: XOR<RadReportUpdateManyMutationInput, RadReportUncheckedUpdateManyWithoutReportTemplateInput>
  }

  export type PatientCreateWithoutTelemedicineConsultationsInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutPatientInput
    studies?: StudyCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutPatientInput
    tenant: TenantCreateNestedOneWithoutPatientsInput
  }

  export type PatientUncheckedCreateWithoutTelemedicineConsultationsInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    tenantId: string
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutPatientInput
    studies?: StudyUncheckedCreateNestedManyWithoutPatientInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutTelemedicineConsultationsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutTelemedicineConsultationsInput, PatientUncheckedCreateWithoutTelemedicineConsultationsInput>
  }

  export type UserCreateWithoutDoctorTelemedicineInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    staff?: StaffCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordCreateNestedManyWithoutUpdatedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutDoctorTelemedicineInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderUncheckedCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    staff?: StaffUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutDoctorTelemedicineInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoctorTelemedicineInput, UserUncheckedCreateWithoutDoctorTelemedicineInput>
  }

  export type TenantCreateWithoutTelemedicineConsultationsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTelemedicineConsultationsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTelemedicineConsultationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTelemedicineConsultationsInput, TenantUncheckedCreateWithoutTelemedicineConsultationsInput>
  }

  export type VideoRoomCreateWithoutConsultationInput = {
    id?: string
    roomId: string
    status?: $Enums.VideoRoomStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    maxParticipants?: number
    recordingEnabled?: boolean
    recordingUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVideoRoomsInput
    participants?: VideoParticipantCreateNestedManyWithoutRoomInput
    recordings?: VideoRecordingCreateNestedManyWithoutRoomInput
  }

  export type VideoRoomUncheckedCreateWithoutConsultationInput = {
    id?: string
    roomId: string
    status?: $Enums.VideoRoomStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    maxParticipants?: number
    recordingEnabled?: boolean
    recordingUrl?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: VideoParticipantUncheckedCreateNestedManyWithoutRoomInput
    recordings?: VideoRecordingUncheckedCreateNestedManyWithoutRoomInput
  }

  export type VideoRoomCreateOrConnectWithoutConsultationInput = {
    where: VideoRoomWhereUniqueInput
    create: XOR<VideoRoomCreateWithoutConsultationInput, VideoRoomUncheckedCreateWithoutConsultationInput>
  }

  export type LabOrderCreateWithoutConsultationInput = {
    id?: string
    orderNumber: string
    status?: $Enums.LabOrderStatus
    orderDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutLabOrdersInput
    doctor?: UserCreateNestedOneWithoutDoctorLabOrdersInput
    patient: PatientCreateNestedOneWithoutLabOrdersInput
    tests?: LabOrderTestCreateNestedManyWithoutOrderInput
  }

  export type LabOrderUncheckedCreateWithoutConsultationInput = {
    id?: string
    orderNumber: string
    patientId: string
    doctorId?: string | null
    status?: $Enums.LabOrderStatus
    orderDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tests?: LabOrderTestUncheckedCreateNestedManyWithoutOrderInput
  }

  export type LabOrderCreateOrConnectWithoutConsultationInput = {
    where: LabOrderWhereUniqueInput
    create: XOR<LabOrderCreateWithoutConsultationInput, LabOrderUncheckedCreateWithoutConsultationInput>
  }

  export type LabOrderCreateManyConsultationInputEnvelope = {
    data: LabOrderCreateManyConsultationInput | LabOrderCreateManyConsultationInput[]
    skipDuplicates?: boolean
  }

  export type RadiologyOrderCreateWithoutConsultationInput = {
    id?: string
    studyType: string
    priority?: $Enums.Priority
    reason?: string | null
    clinicalHistory?: string | null
    status?: $Enums.RadiologyOrderStatus
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutRadiologyOrdersInput
    doctor: UserCreateNestedOneWithoutDoctorRadiologyOrdersInput
    modality: ModalityCreateNestedOneWithoutRadiologyOrdersInput
    tenant: TenantCreateNestedOneWithoutRadiologyOrdersInput
    study?: StudyCreateNestedOneWithoutRadiologyOrdersInput
  }

  export type RadiologyOrderUncheckedCreateWithoutConsultationInput = {
    id?: string
    patientId: string
    doctorId: string
    modalityId: string
    studyType: string
    priority?: $Enums.Priority
    reason?: string | null
    clinicalHistory?: string | null
    status?: $Enums.RadiologyOrderStatus
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studyId?: string | null
  }

  export type RadiologyOrderCreateOrConnectWithoutConsultationInput = {
    where: RadiologyOrderWhereUniqueInput
    create: XOR<RadiologyOrderCreateWithoutConsultationInput, RadiologyOrderUncheckedCreateWithoutConsultationInput>
  }

  export type RadiologyOrderCreateManyConsultationInputEnvelope = {
    data: RadiologyOrderCreateManyConsultationInput | RadiologyOrderCreateManyConsultationInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutTelemedicineConsultationsInput = {
    update: XOR<PatientUpdateWithoutTelemedicineConsultationsInput, PatientUncheckedUpdateWithoutTelemedicineConsultationsInput>
    create: XOR<PatientCreateWithoutTelemedicineConsultationsInput, PatientUncheckedCreateWithoutTelemedicineConsultationsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutTelemedicineConsultationsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutTelemedicineConsultationsInput, PatientUncheckedUpdateWithoutTelemedicineConsultationsInput>
  }

  export type PatientUpdateWithoutTelemedicineConsultationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutPatientNestedInput
    studies?: StudyUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutPatientNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateWithoutTelemedicineConsultationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutPatientNestedInput
    studies?: StudyUncheckedUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutDoctorTelemedicineInput = {
    update: XOR<UserUpdateWithoutDoctorTelemedicineInput, UserUncheckedUpdateWithoutDoctorTelemedicineInput>
    create: XOR<UserCreateWithoutDoctorTelemedicineInput, UserUncheckedCreateWithoutDoctorTelemedicineInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDoctorTelemedicineInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDoctorTelemedicineInput, UserUncheckedUpdateWithoutDoctorTelemedicineInput>
  }

  export type UserUpdateWithoutDoctorTelemedicineInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUpdateManyWithoutUpdatedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutDoctorTelemedicineInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUncheckedUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    staff?: StaffUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type TenantUpsertWithoutTelemedicineConsultationsInput = {
    update: XOR<TenantUpdateWithoutTelemedicineConsultationsInput, TenantUncheckedUpdateWithoutTelemedicineConsultationsInput>
    create: XOR<TenantCreateWithoutTelemedicineConsultationsInput, TenantUncheckedCreateWithoutTelemedicineConsultationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTelemedicineConsultationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTelemedicineConsultationsInput, TenantUncheckedUpdateWithoutTelemedicineConsultationsInput>
  }

  export type TenantUpdateWithoutTelemedicineConsultationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTelemedicineConsultationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type VideoRoomUpsertWithoutConsultationInput = {
    update: XOR<VideoRoomUpdateWithoutConsultationInput, VideoRoomUncheckedUpdateWithoutConsultationInput>
    create: XOR<VideoRoomCreateWithoutConsultationInput, VideoRoomUncheckedCreateWithoutConsultationInput>
    where?: VideoRoomWhereInput
  }

  export type VideoRoomUpdateToOneWithWhereWithoutConsultationInput = {
    where?: VideoRoomWhereInput
    data: XOR<VideoRoomUpdateWithoutConsultationInput, VideoRoomUncheckedUpdateWithoutConsultationInput>
  }

  export type VideoRoomUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    status?: EnumVideoRoomStatusFieldUpdateOperationsInput | $Enums.VideoRoomStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVideoRoomsNestedInput
    participants?: VideoParticipantUpdateManyWithoutRoomNestedInput
    recordings?: VideoRecordingUpdateManyWithoutRoomNestedInput
  }

  export type VideoRoomUncheckedUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    status?: EnumVideoRoomStatusFieldUpdateOperationsInput | $Enums.VideoRoomStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: VideoParticipantUncheckedUpdateManyWithoutRoomNestedInput
    recordings?: VideoRecordingUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type LabOrderUpsertWithWhereUniqueWithoutConsultationInput = {
    where: LabOrderWhereUniqueInput
    update: XOR<LabOrderUpdateWithoutConsultationInput, LabOrderUncheckedUpdateWithoutConsultationInput>
    create: XOR<LabOrderCreateWithoutConsultationInput, LabOrderUncheckedCreateWithoutConsultationInput>
  }

  export type LabOrderUpdateWithWhereUniqueWithoutConsultationInput = {
    where: LabOrderWhereUniqueInput
    data: XOR<LabOrderUpdateWithoutConsultationInput, LabOrderUncheckedUpdateWithoutConsultationInput>
  }

  export type LabOrderUpdateManyWithWhereWithoutConsultationInput = {
    where: LabOrderScalarWhereInput
    data: XOR<LabOrderUpdateManyMutationInput, LabOrderUncheckedUpdateManyWithoutConsultationInput>
  }

  export type RadiologyOrderUpsertWithWhereUniqueWithoutConsultationInput = {
    where: RadiologyOrderWhereUniqueInput
    update: XOR<RadiologyOrderUpdateWithoutConsultationInput, RadiologyOrderUncheckedUpdateWithoutConsultationInput>
    create: XOR<RadiologyOrderCreateWithoutConsultationInput, RadiologyOrderUncheckedCreateWithoutConsultationInput>
  }

  export type RadiologyOrderUpdateWithWhereUniqueWithoutConsultationInput = {
    where: RadiologyOrderWhereUniqueInput
    data: XOR<RadiologyOrderUpdateWithoutConsultationInput, RadiologyOrderUncheckedUpdateWithoutConsultationInput>
  }

  export type RadiologyOrderUpdateManyWithWhereWithoutConsultationInput = {
    where: RadiologyOrderScalarWhereInput
    data: XOR<RadiologyOrderUpdateManyMutationInput, RadiologyOrderUncheckedUpdateManyWithoutConsultationInput>
  }

  export type TelemedicineConsultationCreateWithoutVideoRoomInput = {
    id?: string
    status?: $Enums.TelemedicineStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    consultationType?: $Enums.ConsultationType
    reason?: string | null
    notes?: string | null
    prescription?: string | null
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    isEmergency?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutTelemedicineConsultationsInput
    doctor?: UserCreateNestedOneWithoutDoctorTelemedicineInput
    tenant: TenantCreateNestedOneWithoutTelemedicineConsultationsInput
    labOrders?: LabOrderCreateNestedManyWithoutConsultationInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutConsultationInput
  }

  export type TelemedicineConsultationUncheckedCreateWithoutVideoRoomInput = {
    id?: string
    patientId: string
    doctorId?: string | null
    status?: $Enums.TelemedicineStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    consultationType?: $Enums.ConsultationType
    reason?: string | null
    notes?: string | null
    prescription?: string | null
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    isEmergency?: boolean
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutConsultationInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type TelemedicineConsultationCreateOrConnectWithoutVideoRoomInput = {
    where: TelemedicineConsultationWhereUniqueInput
    create: XOR<TelemedicineConsultationCreateWithoutVideoRoomInput, TelemedicineConsultationUncheckedCreateWithoutVideoRoomInput>
  }

  export type TenantCreateWithoutVideoRoomsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutVideoRoomsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutVideoRoomsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutVideoRoomsInput, TenantUncheckedCreateWithoutVideoRoomsInput>
  }

  export type VideoParticipantCreateWithoutRoomInput = {
    id?: string
    userId: string
    participantType: $Enums.ParticipantType
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVideoParticipantsInput
  }

  export type VideoParticipantUncheckedCreateWithoutRoomInput = {
    id?: string
    userId: string
    participantType: $Enums.ParticipantType
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoParticipantCreateOrConnectWithoutRoomInput = {
    where: VideoParticipantWhereUniqueInput
    create: XOR<VideoParticipantCreateWithoutRoomInput, VideoParticipantUncheckedCreateWithoutRoomInput>
  }

  export type VideoParticipantCreateManyRoomInputEnvelope = {
    data: VideoParticipantCreateManyRoomInput | VideoParticipantCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type VideoRecordingCreateWithoutRoomInput = {
    id?: string
    fileName: string
    filePath: string
    fileSize: number
    duration?: number | null
    status?: $Enums.RecordingStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutVideoRecordingsInput
  }

  export type VideoRecordingUncheckedCreateWithoutRoomInput = {
    id?: string
    fileName: string
    filePath: string
    fileSize: number
    duration?: number | null
    status?: $Enums.RecordingStatus
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoRecordingCreateOrConnectWithoutRoomInput = {
    where: VideoRecordingWhereUniqueInput
    create: XOR<VideoRecordingCreateWithoutRoomInput, VideoRecordingUncheckedCreateWithoutRoomInput>
  }

  export type VideoRecordingCreateManyRoomInputEnvelope = {
    data: VideoRecordingCreateManyRoomInput | VideoRecordingCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type TelemedicineConsultationUpsertWithoutVideoRoomInput = {
    update: XOR<TelemedicineConsultationUpdateWithoutVideoRoomInput, TelemedicineConsultationUncheckedUpdateWithoutVideoRoomInput>
    create: XOR<TelemedicineConsultationCreateWithoutVideoRoomInput, TelemedicineConsultationUncheckedCreateWithoutVideoRoomInput>
    where?: TelemedicineConsultationWhereInput
  }

  export type TelemedicineConsultationUpdateToOneWithWhereWithoutVideoRoomInput = {
    where?: TelemedicineConsultationWhereInput
    data: XOR<TelemedicineConsultationUpdateWithoutVideoRoomInput, TelemedicineConsultationUncheckedUpdateWithoutVideoRoomInput>
  }

  export type TelemedicineConsultationUpdateWithoutVideoRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTelemedicineStatusFieldUpdateOperationsInput | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    consultationType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutTelemedicineConsultationsNestedInput
    doctor?: UserUpdateOneWithoutDoctorTelemedicineNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTelemedicineConsultationsNestedInput
    labOrders?: LabOrderUpdateManyWithoutConsultationNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutConsultationNestedInput
  }

  export type TelemedicineConsultationUncheckedUpdateWithoutVideoRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTelemedicineStatusFieldUpdateOperationsInput | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    consultationType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labOrders?: LabOrderUncheckedUpdateManyWithoutConsultationNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type TenantUpsertWithoutVideoRoomsInput = {
    update: XOR<TenantUpdateWithoutVideoRoomsInput, TenantUncheckedUpdateWithoutVideoRoomsInput>
    create: XOR<TenantCreateWithoutVideoRoomsInput, TenantUncheckedCreateWithoutVideoRoomsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutVideoRoomsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutVideoRoomsInput, TenantUncheckedUpdateWithoutVideoRoomsInput>
  }

  export type TenantUpdateWithoutVideoRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutVideoRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type VideoParticipantUpsertWithWhereUniqueWithoutRoomInput = {
    where: VideoParticipantWhereUniqueInput
    update: XOR<VideoParticipantUpdateWithoutRoomInput, VideoParticipantUncheckedUpdateWithoutRoomInput>
    create: XOR<VideoParticipantCreateWithoutRoomInput, VideoParticipantUncheckedCreateWithoutRoomInput>
  }

  export type VideoParticipantUpdateWithWhereUniqueWithoutRoomInput = {
    where: VideoParticipantWhereUniqueInput
    data: XOR<VideoParticipantUpdateWithoutRoomInput, VideoParticipantUncheckedUpdateWithoutRoomInput>
  }

  export type VideoParticipantUpdateManyWithWhereWithoutRoomInput = {
    where: VideoParticipantScalarWhereInput
    data: XOR<VideoParticipantUpdateManyMutationInput, VideoParticipantUncheckedUpdateManyWithoutRoomInput>
  }

  export type VideoRecordingUpsertWithWhereUniqueWithoutRoomInput = {
    where: VideoRecordingWhereUniqueInput
    update: XOR<VideoRecordingUpdateWithoutRoomInput, VideoRecordingUncheckedUpdateWithoutRoomInput>
    create: XOR<VideoRecordingCreateWithoutRoomInput, VideoRecordingUncheckedCreateWithoutRoomInput>
  }

  export type VideoRecordingUpdateWithWhereUniqueWithoutRoomInput = {
    where: VideoRecordingWhereUniqueInput
    data: XOR<VideoRecordingUpdateWithoutRoomInput, VideoRecordingUncheckedUpdateWithoutRoomInput>
  }

  export type VideoRecordingUpdateManyWithWhereWithoutRoomInput = {
    where: VideoRecordingScalarWhereInput
    data: XOR<VideoRecordingUpdateManyMutationInput, VideoRecordingUncheckedUpdateManyWithoutRoomInput>
  }

  export type VideoRoomCreateWithoutParticipantsInput = {
    id?: string
    roomId: string
    status?: $Enums.VideoRoomStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    maxParticipants?: number
    recordingEnabled?: boolean
    recordingUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    consultation: TelemedicineConsultationCreateNestedOneWithoutVideoRoomInput
    tenant: TenantCreateNestedOneWithoutVideoRoomsInput
    recordings?: VideoRecordingCreateNestedManyWithoutRoomInput
  }

  export type VideoRoomUncheckedCreateWithoutParticipantsInput = {
    id?: string
    consultationId: string
    roomId: string
    status?: $Enums.VideoRoomStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    maxParticipants?: number
    recordingEnabled?: boolean
    recordingUrl?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    recordings?: VideoRecordingUncheckedCreateNestedManyWithoutRoomInput
  }

  export type VideoRoomCreateOrConnectWithoutParticipantsInput = {
    where: VideoRoomWhereUniqueInput
    create: XOR<VideoRoomCreateWithoutParticipantsInput, VideoRoomUncheckedCreateWithoutParticipantsInput>
  }

  export type TenantCreateWithoutVideoParticipantsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutVideoParticipantsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutVideoParticipantsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutVideoParticipantsInput, TenantUncheckedCreateWithoutVideoParticipantsInput>
  }

  export type VideoRoomUpsertWithoutParticipantsInput = {
    update: XOR<VideoRoomUpdateWithoutParticipantsInput, VideoRoomUncheckedUpdateWithoutParticipantsInput>
    create: XOR<VideoRoomCreateWithoutParticipantsInput, VideoRoomUncheckedCreateWithoutParticipantsInput>
    where?: VideoRoomWhereInput
  }

  export type VideoRoomUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: VideoRoomWhereInput
    data: XOR<VideoRoomUpdateWithoutParticipantsInput, VideoRoomUncheckedUpdateWithoutParticipantsInput>
  }

  export type VideoRoomUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    status?: EnumVideoRoomStatusFieldUpdateOperationsInput | $Enums.VideoRoomStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultation?: TelemedicineConsultationUpdateOneRequiredWithoutVideoRoomNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVideoRoomsNestedInput
    recordings?: VideoRecordingUpdateManyWithoutRoomNestedInput
  }

  export type VideoRoomUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    status?: EnumVideoRoomStatusFieldUpdateOperationsInput | $Enums.VideoRoomStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordings?: VideoRecordingUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type TenantUpsertWithoutVideoParticipantsInput = {
    update: XOR<TenantUpdateWithoutVideoParticipantsInput, TenantUncheckedUpdateWithoutVideoParticipantsInput>
    create: XOR<TenantCreateWithoutVideoParticipantsInput, TenantUncheckedCreateWithoutVideoParticipantsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutVideoParticipantsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutVideoParticipantsInput, TenantUncheckedUpdateWithoutVideoParticipantsInput>
  }

  export type TenantUpdateWithoutVideoParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutVideoParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type VideoRoomCreateWithoutRecordingsInput = {
    id?: string
    roomId: string
    status?: $Enums.VideoRoomStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    maxParticipants?: number
    recordingEnabled?: boolean
    recordingUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    consultation: TelemedicineConsultationCreateNestedOneWithoutVideoRoomInput
    tenant: TenantCreateNestedOneWithoutVideoRoomsInput
    participants?: VideoParticipantCreateNestedManyWithoutRoomInput
  }

  export type VideoRoomUncheckedCreateWithoutRecordingsInput = {
    id?: string
    consultationId: string
    roomId: string
    status?: $Enums.VideoRoomStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    maxParticipants?: number
    recordingEnabled?: boolean
    recordingUrl?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: VideoParticipantUncheckedCreateNestedManyWithoutRoomInput
  }

  export type VideoRoomCreateOrConnectWithoutRecordingsInput = {
    where: VideoRoomWhereUniqueInput
    create: XOR<VideoRoomCreateWithoutRecordingsInput, VideoRoomUncheckedCreateWithoutRecordingsInput>
  }

  export type TenantCreateWithoutVideoRecordingsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutVideoRecordingsInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutVideoRecordingsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutVideoRecordingsInput, TenantUncheckedCreateWithoutVideoRecordingsInput>
  }

  export type VideoRoomUpsertWithoutRecordingsInput = {
    update: XOR<VideoRoomUpdateWithoutRecordingsInput, VideoRoomUncheckedUpdateWithoutRecordingsInput>
    create: XOR<VideoRoomCreateWithoutRecordingsInput, VideoRoomUncheckedCreateWithoutRecordingsInput>
    where?: VideoRoomWhereInput
  }

  export type VideoRoomUpdateToOneWithWhereWithoutRecordingsInput = {
    where?: VideoRoomWhereInput
    data: XOR<VideoRoomUpdateWithoutRecordingsInput, VideoRoomUncheckedUpdateWithoutRecordingsInput>
  }

  export type VideoRoomUpdateWithoutRecordingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    status?: EnumVideoRoomStatusFieldUpdateOperationsInput | $Enums.VideoRoomStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultation?: TelemedicineConsultationUpdateOneRequiredWithoutVideoRoomNestedInput
    tenant?: TenantUpdateOneRequiredWithoutVideoRoomsNestedInput
    participants?: VideoParticipantUpdateManyWithoutRoomNestedInput
  }

  export type VideoRoomUncheckedUpdateWithoutRecordingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    status?: EnumVideoRoomStatusFieldUpdateOperationsInput | $Enums.VideoRoomStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: VideoParticipantUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type TenantUpsertWithoutVideoRecordingsInput = {
    update: XOR<TenantUpdateWithoutVideoRecordingsInput, TenantUncheckedUpdateWithoutVideoRecordingsInput>
    create: XOR<TenantCreateWithoutVideoRecordingsInput, TenantUncheckedCreateWithoutVideoRecordingsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutVideoRecordingsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutVideoRecordingsInput, TenantUncheckedUpdateWithoutVideoRecordingsInput>
  }

  export type TenantUpdateWithoutVideoRecordingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutVideoRecordingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutVideoMessagesInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutVideoMessagesInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    radiologyOrders?: RadiologyOrderUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutVideoMessagesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutVideoMessagesInput, TenantUncheckedCreateWithoutVideoMessagesInput>
  }

  export type TenantUpsertWithoutVideoMessagesInput = {
    update: XOR<TenantUpdateWithoutVideoMessagesInput, TenantUncheckedUpdateWithoutVideoMessagesInput>
    create: XOR<TenantCreateWithoutVideoMessagesInput, TenantUncheckedCreateWithoutVideoMessagesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutVideoMessagesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutVideoMessagesInput, TenantUncheckedUpdateWithoutVideoMessagesInput>
  }

  export type TenantUpdateWithoutVideoMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutVideoMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TelemedicineConsultationCreateWithoutRadiologyOrdersInput = {
    id?: string
    status?: $Enums.TelemedicineStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    consultationType?: $Enums.ConsultationType
    reason?: string | null
    notes?: string | null
    prescription?: string | null
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    isEmergency?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutTelemedicineConsultationsInput
    doctor?: UserCreateNestedOneWithoutDoctorTelemedicineInput
    tenant: TenantCreateNestedOneWithoutTelemedicineConsultationsInput
    videoRoom?: VideoRoomCreateNestedOneWithoutConsultationInput
    labOrders?: LabOrderCreateNestedManyWithoutConsultationInput
  }

  export type TelemedicineConsultationUncheckedCreateWithoutRadiologyOrdersInput = {
    id?: string
    patientId: string
    doctorId?: string | null
    status?: $Enums.TelemedicineStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    consultationType?: $Enums.ConsultationType
    reason?: string | null
    notes?: string | null
    prescription?: string | null
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    isEmergency?: boolean
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    videoRoom?: VideoRoomUncheckedCreateNestedOneWithoutConsultationInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type TelemedicineConsultationCreateOrConnectWithoutRadiologyOrdersInput = {
    where: TelemedicineConsultationWhereUniqueInput
    create: XOR<TelemedicineConsultationCreateWithoutRadiologyOrdersInput, TelemedicineConsultationUncheckedCreateWithoutRadiologyOrdersInput>
  }

  export type PatientCreateWithoutRadiologyOrdersInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutPatientInput
    studies?: StudyCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutPatientInput
    tenant: TenantCreateNestedOneWithoutPatientsInput
  }

  export type PatientUncheckedCreateWithoutRadiologyOrdersInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    tenantId: string
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutPatientInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutPatientInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutPatientInput
    studies?: StudyUncheckedCreateNestedManyWithoutPatientInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutRadiologyOrdersInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutRadiologyOrdersInput, PatientUncheckedCreateWithoutRadiologyOrdersInput>
  }

  export type UserCreateWithoutDoctorRadiologyOrdersInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    staff?: StaffCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordCreateNestedManyWithoutUpdatedByInput
    tenant: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutDoctorRadiologyOrdersInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorAppointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    doctorLabOrders?: LabOrderUncheckedCreateNestedManyWithoutDoctorInput
    doctorPrescriptions?: PharmacyOrderUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedCreateNestedManyWithoutDoctorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    staff?: StaffUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    createdMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutDoctorInput
    updatedMedicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutDoctorRadiologyOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoctorRadiologyOrdersInput, UserUncheckedCreateWithoutDoctorRadiologyOrdersInput>
  }

  export type ModalityCreateWithoutRadiologyOrdersInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studies?: StudyCreateNestedManyWithoutModalityInput
  }

  export type ModalityUncheckedCreateWithoutRadiologyOrdersInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studies?: StudyUncheckedCreateNestedManyWithoutModalityInput
  }

  export type ModalityCreateOrConnectWithoutRadiologyOrdersInput = {
    where: ModalityWhereUniqueInput
    create: XOR<ModalityCreateWithoutRadiologyOrdersInput, ModalityUncheckedCreateWithoutRadiologyOrdersInput>
  }

  export type TenantCreateWithoutRadiologyOrdersInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    departments?: DepartmentCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestCreateNestedManyWithoutTenantInput
    labTests?: LabTestCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordCreateNestedManyWithoutTenantInput
    medications?: MedicationCreateNestedManyWithoutTenantInput
    payments?: PaymentCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyCreateNestedManyWithoutTenantInput
    staff?: StaffCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    patients?: PatientCreateNestedManyWithoutTenantInput
    studies?: StudyCreateNestedManyWithoutTenantInput
    radReports?: RadReportCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutRadiologyOrdersInput = {
    id?: string
    name: string
    slug: string
    type?: $Enums.TenantType
    address?: string | null
    phone?: string | null
    email?: string | null
    logo?: string | null
    deletedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutTenantInput
    labOrders?: LabOrderUncheckedCreateNestedManyWithoutTenantInput
    labOrderTests?: LabOrderTestUncheckedCreateNestedManyWithoutTenantInput
    labTests?: LabTestUncheckedCreateNestedManyWithoutTenantInput
    medicalRecords?: MedicalRecordUncheckedCreateNestedManyWithoutTenantInput
    medications?: MedicationUncheckedCreateNestedManyWithoutTenantInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrders?: PharmacyOrderUncheckedCreateNestedManyWithoutTenantInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedCreateNestedManyWithoutTenantInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutTenantInput
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutTenantInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutTenantInput
    specialties?: SpecialtyUncheckedCreateNestedManyWithoutTenantInput
    staff?: StaffUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    patients?: PatientUncheckedCreateNestedManyWithoutTenantInput
    studies?: StudyUncheckedCreateNestedManyWithoutTenantInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutTenantInput
    reportTemplates?: ReportTemplateUncheckedCreateNestedManyWithoutTenantInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedCreateNestedManyWithoutTenantInput
    videoRooms?: VideoRoomUncheckedCreateNestedManyWithoutTenantInput
    videoParticipants?: VideoParticipantUncheckedCreateNestedManyWithoutTenantInput
    videoRecordings?: VideoRecordingUncheckedCreateNestedManyWithoutTenantInput
    videoMessages?: VideoMessageUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutRadiologyOrdersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutRadiologyOrdersInput, TenantUncheckedCreateWithoutRadiologyOrdersInput>
  }

  export type StudyCreateWithoutRadiologyOrdersInput = {
    id?: string
    studyId: string
    patientName: string
    status?: $Enums.StudyStatus
    studyDate?: Date | string
    priority?: $Enums.Priority | null
    description?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    modality: ModalityCreateNestedOneWithoutStudiesInput
    patient: PatientCreateNestedOneWithoutStudiesInput
    tenant: TenantCreateNestedOneWithoutStudiesInput
    series?: SeriesCreateNestedManyWithoutStudyInput
    radReports?: RadReportCreateNestedManyWithoutStudyInput
    radiationDoses?: RadiationDoseCreateNestedManyWithoutStudyInput
  }

  export type StudyUncheckedCreateWithoutRadiologyOrdersInput = {
    id?: string
    studyId: string
    patientId: string
    patientName: string
    modalityId: string
    status?: $Enums.StudyStatus
    studyDate?: Date | string
    priority?: $Enums.Priority | null
    description?: string | null
    notes?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    series?: SeriesUncheckedCreateNestedManyWithoutStudyInput
    radReports?: RadReportUncheckedCreateNestedManyWithoutStudyInput
    radiationDoses?: RadiationDoseUncheckedCreateNestedManyWithoutStudyInput
  }

  export type StudyCreateOrConnectWithoutRadiologyOrdersInput = {
    where: StudyWhereUniqueInput
    create: XOR<StudyCreateWithoutRadiologyOrdersInput, StudyUncheckedCreateWithoutRadiologyOrdersInput>
  }

  export type TelemedicineConsultationUpsertWithoutRadiologyOrdersInput = {
    update: XOR<TelemedicineConsultationUpdateWithoutRadiologyOrdersInput, TelemedicineConsultationUncheckedUpdateWithoutRadiologyOrdersInput>
    create: XOR<TelemedicineConsultationCreateWithoutRadiologyOrdersInput, TelemedicineConsultationUncheckedCreateWithoutRadiologyOrdersInput>
    where?: TelemedicineConsultationWhereInput
  }

  export type TelemedicineConsultationUpdateToOneWithWhereWithoutRadiologyOrdersInput = {
    where?: TelemedicineConsultationWhereInput
    data: XOR<TelemedicineConsultationUpdateWithoutRadiologyOrdersInput, TelemedicineConsultationUncheckedUpdateWithoutRadiologyOrdersInput>
  }

  export type TelemedicineConsultationUpdateWithoutRadiologyOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTelemedicineStatusFieldUpdateOperationsInput | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    consultationType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutTelemedicineConsultationsNestedInput
    doctor?: UserUpdateOneWithoutDoctorTelemedicineNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTelemedicineConsultationsNestedInput
    videoRoom?: VideoRoomUpdateOneWithoutConsultationNestedInput
    labOrders?: LabOrderUpdateManyWithoutConsultationNestedInput
  }

  export type TelemedicineConsultationUncheckedUpdateWithoutRadiologyOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTelemedicineStatusFieldUpdateOperationsInput | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    consultationType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoRoom?: VideoRoomUncheckedUpdateOneWithoutConsultationNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type PatientUpsertWithoutRadiologyOrdersInput = {
    update: XOR<PatientUpdateWithoutRadiologyOrdersInput, PatientUncheckedUpdateWithoutRadiologyOrdersInput>
    create: XOR<PatientCreateWithoutRadiologyOrdersInput, PatientUncheckedCreateWithoutRadiologyOrdersInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutRadiologyOrdersInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutRadiologyOrdersInput, PatientUncheckedUpdateWithoutRadiologyOrdersInput>
  }

  export type PatientUpdateWithoutRadiologyOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutPatientNestedInput
    studies?: StudyUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutPatientNestedInput
    tenant?: TenantUpdateOneRequiredWithoutPatientsNestedInput
  }

  export type PatientUncheckedUpdateWithoutRadiologyOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutPatientNestedInput
    studies?: StudyUncheckedUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutDoctorRadiologyOrdersInput = {
    update: XOR<UserUpdateWithoutDoctorRadiologyOrdersInput, UserUncheckedUpdateWithoutDoctorRadiologyOrdersInput>
    create: XOR<UserCreateWithoutDoctorRadiologyOrdersInput, UserUncheckedCreateWithoutDoctorRadiologyOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDoctorRadiologyOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDoctorRadiologyOrdersInput, UserUncheckedUpdateWithoutDoctorRadiologyOrdersInput>
  }

  export type UserUpdateWithoutDoctorRadiologyOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUpdateManyWithoutUpdatedByNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutDoctorRadiologyOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUncheckedUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    staff?: StaffUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type ModalityUpsertWithoutRadiologyOrdersInput = {
    update: XOR<ModalityUpdateWithoutRadiologyOrdersInput, ModalityUncheckedUpdateWithoutRadiologyOrdersInput>
    create: XOR<ModalityCreateWithoutRadiologyOrdersInput, ModalityUncheckedCreateWithoutRadiologyOrdersInput>
    where?: ModalityWhereInput
  }

  export type ModalityUpdateToOneWithWhereWithoutRadiologyOrdersInput = {
    where?: ModalityWhereInput
    data: XOR<ModalityUpdateWithoutRadiologyOrdersInput, ModalityUncheckedUpdateWithoutRadiologyOrdersInput>
  }

  export type ModalityUpdateWithoutRadiologyOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studies?: StudyUpdateManyWithoutModalityNestedInput
  }

  export type ModalityUncheckedUpdateWithoutRadiologyOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studies?: StudyUncheckedUpdateManyWithoutModalityNestedInput
  }

  export type TenantUpsertWithoutRadiologyOrdersInput = {
    update: XOR<TenantUpdateWithoutRadiologyOrdersInput, TenantUncheckedUpdateWithoutRadiologyOrdersInput>
    create: XOR<TenantCreateWithoutRadiologyOrdersInput, TenantUncheckedCreateWithoutRadiologyOrdersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutRadiologyOrdersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutRadiologyOrdersInput, TenantUncheckedUpdateWithoutRadiologyOrdersInput>
  }

  export type TenantUpdateWithoutRadiologyOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutTenantNestedInput
    medications?: MedicationUpdateManyWithoutTenantNestedInput
    payments?: PaymentUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUpdateManyWithoutTenantNestedInput
    staff?: StaffUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    patients?: PatientUpdateManyWithoutTenantNestedInput
    studies?: StudyUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutRadiologyOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutTenantNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutTenantNestedInput
    labOrderTests?: LabOrderTestUncheckedUpdateManyWithoutTenantNestedInput
    labTests?: LabTestUncheckedUpdateManyWithoutTenantNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutTenantNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutTenantNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutTenantNestedInput
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutTenantNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutTenantNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutTenantNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutTenantNestedInput
    specialties?: SpecialtyUncheckedUpdateManyWithoutTenantNestedInput
    staff?: StaffUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    patients?: PatientUncheckedUpdateManyWithoutTenantNestedInput
    studies?: StudyUncheckedUpdateManyWithoutTenantNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutTenantNestedInput
    reportTemplates?: ReportTemplateUncheckedUpdateManyWithoutTenantNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutTenantNestedInput
    videoRooms?: VideoRoomUncheckedUpdateManyWithoutTenantNestedInput
    videoParticipants?: VideoParticipantUncheckedUpdateManyWithoutTenantNestedInput
    videoRecordings?: VideoRecordingUncheckedUpdateManyWithoutTenantNestedInput
    videoMessages?: VideoMessageUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type StudyUpsertWithoutRadiologyOrdersInput = {
    update: XOR<StudyUpdateWithoutRadiologyOrdersInput, StudyUncheckedUpdateWithoutRadiologyOrdersInput>
    create: XOR<StudyCreateWithoutRadiologyOrdersInput, StudyUncheckedCreateWithoutRadiologyOrdersInput>
    where?: StudyWhereInput
  }

  export type StudyUpdateToOneWithWhereWithoutRadiologyOrdersInput = {
    where?: StudyWhereInput
    data: XOR<StudyUpdateWithoutRadiologyOrdersInput, StudyUncheckedUpdateWithoutRadiologyOrdersInput>
  }

  export type StudyUpdateWithoutRadiologyOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    patientName?: StringFieldUpdateOperationsInput | string
    status?: EnumStudyStatusFieldUpdateOperationsInput | $Enums.StudyStatus
    studyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modality?: ModalityUpdateOneRequiredWithoutStudiesNestedInput
    patient?: PatientUpdateOneRequiredWithoutStudiesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutStudiesNestedInput
    series?: SeriesUpdateManyWithoutStudyNestedInput
    radReports?: RadReportUpdateManyWithoutStudyNestedInput
    radiationDoses?: RadiationDoseUpdateManyWithoutStudyNestedInput
  }

  export type StudyUncheckedUpdateWithoutRadiologyOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientName?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    status?: EnumStudyStatusFieldUpdateOperationsInput | $Enums.StudyStatus
    studyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: SeriesUncheckedUpdateManyWithoutStudyNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutStudyNestedInput
    radiationDoses?: RadiationDoseUncheckedUpdateManyWithoutStudyNestedInput
  }

  export type AppointmentCreateManyDepartmentInput = {
    id?: string
    patientId: string
    doctorId: string
    startTime: Date | string
    endTime: Date | string
    status: $Enums.AppointmentStatus
    reason?: string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffCreateManyDepartmentInput = {
    id?: string
    userId: string
    employeeId?: string | null
    designation?: string | null
    joiningDate?: Date | string | null
    qualification?: string | null
    experience?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: UserUpdateOneRequiredWithoutDoctorAppointmentsNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStaffNestedInput
    user?: UserUpdateOneRequiredWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyTenantInput = {
    id?: string
    patientId: string
    doctorId: string
    departmentId?: string | null
    startTime: Date | string
    endTime: Date | string
    status: $Enums.AppointmentStatus
    reason?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyTenantInput = {
    id?: string
    userId: string
    action: string
    entityType?: string | null
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type DepartmentCreateManyTenantInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyTenantInput = {
    id?: string
    invoiceNumber: string
    patientId: string
    date?: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    subTotal?: number
    taxAmount?: number
    discountAmount?: number
    totalAmount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type InvoiceItemCreateManyTenantInput = {
    id?: string
    invoiceId: string
    itemType: string
    itemId: string
    description: string
    quantity?: number
    unitPrice: number
    discount?: number
    taxRate?: number
    totalAmount: number
  }

  export type LabOrderCreateManyTenantInput = {
    id?: string
    orderNumber: string
    patientId: string
    doctorId?: string | null
    status?: $Enums.LabOrderStatus
    orderDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationId?: string | null
  }

  export type LabOrderTestCreateManyTenantInput = {
    id?: string
    orderId: string
    testId: string
    status?: $Enums.LabTestStatus
    result?: string | null
    resultDate?: Date | string | null
    referenceRange?: string | null
    notes?: string | null
  }

  export type LabTestCreateManyTenantInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    category: string
    price?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalRecordCreateManyTenantInput = {
    id?: string
    patientId: string
    recordType: string
    title: string
    description?: string | null
    date?: Date | string
    doctorId?: string | null
    updatedById?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationCreateManyTenantInput = {
    id?: string
    name: string
    genericName?: string | null
    description?: string | null
    strength?: string | null
    unit?: string | null
    dosageForm?: string | null
    route?: string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyTenantInput = {
    id?: string
    paymentNumber: string
    invoiceId: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    referenceNumber?: string | null
    notes?: string | null
    status?: $Enums.PaymentStatus
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PharmacyOrderCreateManyTenantInput = {
    id?: string
    orderNumber: string
    patientId: string
    doctorId?: string | null
    status?: $Enums.PharmacyOrderStatus
    orderDate?: Date | string
    dispensedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type PharmacyOrderItemCreateManyTenantInput = {
    id?: string
    orderId: string
    medicationId: string
    quantity?: number
    dosage?: string | null
    frequency?: string | null
    duration?: string | null
    instructions?: string | null
    status?: $Enums.PharmacyItemStatus
  }

  export type PrescriptionCreateManyTenantInput = {
    id?: string
    patientId: string
    doctorId: string
    diagnosis?: string | null
    notes?: string | null
    status?: $Enums.PrescriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrescriptionItemCreateManyTenantInput = {
    id?: string
    prescriptionId: string
    medicationId: string
    patientId: string
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    isDispensed?: boolean
  }

  export type RefreshTokenCreateManyTenantInput = {
    id?: string
    jti: string
    token: string
    userId: string
    revoked?: boolean
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialtyCreateManyTenantInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffCreateManyTenantInput = {
    id?: string
    userId: string
    employeeId?: string | null
    designation?: string | null
    departmentId?: string | null
    joiningDate?: Date | string | null
    qualification?: string | null
    experience?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyTenantInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.Role
    specialization?: string | null
    experience?: number | null
    licenseNumber?: string | null
    signature?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientCreateManyTenantInput = {
    id?: string
    medicalRecordNumber: string
    registrationNumber?: string | null
    externalId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    bloodType?: $Enums.BloodType | null
    maritalStatus?: $Enums.MaritalStatus | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    pincode?: string | null
    phoneVerified?: boolean
    emailVerified?: boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: string | null
    insuranceId?: string | null
    insuranceGroup?: string | null
    insuranceValidUntil?: Date | string | null
    insuranceType?: $Enums.InsuranceType | null
    createdBy?: string | null
    updatedBy?: string | null
    isActive?: boolean
    isVerified?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type StudyCreateManyTenantInput = {
    id?: string
    studyId: string
    patientId: string
    patientName: string
    modalityId: string
    status?: $Enums.StudyStatus
    studyDate?: Date | string
    priority?: $Enums.Priority | null
    description?: string | null
    notes?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadReportCreateManyTenantInput = {
    id?: string
    reportId: string
    studyId: string
    reportTemplateId?: string | null
    status?: $Enums.ReportStatus
    findings?: string | null
    impression?: string | null
    conclusion?: string | null
    reportDateTime?: Date | string
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportTemplateCreateManyTenantInput = {
    id?: string
    name: string
    description?: string | null
    template: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelemedicineConsultationCreateManyTenantInput = {
    id?: string
    patientId: string
    doctorId?: string | null
    status?: $Enums.TelemedicineStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    consultationType?: $Enums.ConsultationType
    reason?: string | null
    notes?: string | null
    prescription?: string | null
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    isEmergency?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoRoomCreateManyTenantInput = {
    id?: string
    consultationId: string
    roomId: string
    status?: $Enums.VideoRoomStatus
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    maxParticipants?: number
    recordingEnabled?: boolean
    recordingUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoParticipantCreateManyTenantInput = {
    id?: string
    roomId: string
    userId: string
    participantType: $Enums.ParticipantType
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoRecordingCreateManyTenantInput = {
    id?: string
    roomId: string
    fileName: string
    filePath: string
    fileSize: number
    duration?: number | null
    status?: $Enums.RecordingStatus
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoMessageCreateManyTenantInput = {
    id?: string
    roomId: string
    senderId: string
    message: string
    messageType?: $Enums.MessageType
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiologyOrderCreateManyTenantInput = {
    id?: string
    consultationId: string
    patientId: string
    doctorId: string
    modalityId: string
    studyType: string
    priority?: $Enums.Priority
    reason?: string | null
    clinicalHistory?: string | null
    status?: $Enums.RadiologyOrderStatus
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studyId?: string | null
  }

  export type AppointmentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutAppointmentsNestedInput
    doctor?: UserUpdateOneRequiredWithoutDoctorAppointmentsNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutDepartmentNestedInput
    staff?: StaffUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDepartmentNestedInput
    staff?: StaffUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    pharmacyOrder?: PharmacyOrderUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    pharmacyOrder?: PharmacyOrderUncheckedUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceItemUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    invoice?: InvoiceUpdateOneRequiredWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
  }

  export type InvoiceItemUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
  }

  export type LabOrderUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: UserUpdateOneWithoutDoctorLabOrdersNestedInput
    patient?: PatientUpdateOneRequiredWithoutLabOrdersNestedInput
    tests?: LabOrderTestUpdateManyWithoutOrderNestedInput
    consultation?: TelemedicineConsultationUpdateOneWithoutLabOrdersNestedInput
  }

  export type LabOrderUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    tests?: LabOrderTestUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabOrderTestUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLabTestStatusFieldUpdateOperationsInput | $Enums.LabTestStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    test?: LabTestUpdateOneRequiredWithoutLabOrdersNestedInput
    order?: LabOrderUpdateOneRequiredWithoutTestsNestedInput
  }

  export type LabOrderTestUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumLabTestStatusFieldUpdateOperationsInput | $Enums.LabTestStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabOrderTestUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumLabTestStatusFieldUpdateOperationsInput | $Enums.LabTestStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabTestUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labOrders?: LabOrderTestUpdateManyWithoutTestNestedInput
  }

  export type LabTestUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labOrders?: LabOrderTestUncheckedUpdateManyWithoutTestNestedInput
  }

  export type LabTestUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutMedicalRecordsNestedInput
    doctor?: UserUpdateOneWithoutCreatedMedicalRecordsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedMedicalRecordsNestedInput
  }

  export type MedicalRecordUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pharmacyOrderItems?: PharmacyOrderItemUpdateManyWithoutMedicationNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutMedicationNestedInput
  }

  export type MedicationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pharmacyOrderItems?: PharmacyOrderItemUncheckedUpdateManyWithoutMedicationNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutMedicationNestedInput
  }

  export type MedicationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genericName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    strength?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    dosageForm?: NullableStringFieldUpdateOperationsInput | string | null
    route?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PharmacyOrderUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumPharmacyOrderStatusFieldUpdateOperationsInput | $Enums.PharmacyOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dispensedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    doctor?: UserUpdateOneWithoutDoctorPrescriptionsNestedInput
    patient?: PatientUpdateOneRequiredWithoutPharmacyOrdersNestedInput
    invoice?: InvoiceUpdateOneWithoutPharmacyOrderNestedInput
    items?: PharmacyOrderItemUpdateManyWithoutOrderNestedInput
  }

  export type PharmacyOrderUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPharmacyOrderStatusFieldUpdateOperationsInput | $Enums.PharmacyOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dispensedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    items?: PharmacyOrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type PharmacyOrderUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPharmacyOrderStatusFieldUpdateOperationsInput | $Enums.PharmacyOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dispensedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PharmacyOrderItemUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPharmacyItemStatusFieldUpdateOperationsInput | $Enums.PharmacyItemStatus
    medication?: MedicationUpdateOneRequiredWithoutPharmacyOrderItemsNestedInput
    order?: PharmacyOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PharmacyOrderItemUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPharmacyItemStatusFieldUpdateOperationsInput | $Enums.PharmacyItemStatus
  }

  export type PharmacyOrderItemUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPharmacyItemStatusFieldUpdateOperationsInput | $Enums.PharmacyItemStatus
  }

  export type PrescriptionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: UserUpdateOneRequiredWithoutPrescriptionsNestedInput
    patient?: PatientUpdateOneRequiredWithoutPrescriptionsNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionItemUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUpdateOneRequiredWithoutPrescriptionItemsNestedInput
    medication?: MedicationUpdateOneRequiredWithoutPrescriptionItemsNestedInput
    prescription?: PrescriptionUpdateOneRequiredWithoutPrescriptionItemsNestedInput
  }

  export type PrescriptionItemUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrescriptionItemUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RefreshTokenUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialtyUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialtyUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialtyUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    user?: UserUpdateOneRequiredWithoutStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    staff?: StaffUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorAppointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    doctorLabOrders?: LabOrderUncheckedUpdateManyWithoutDoctorNestedInput
    doctorPrescriptions?: PharmacyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    doctorTelemedicine?: TelemedicineConsultationUncheckedUpdateManyWithoutDoctorNestedInput
    doctorRadiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutDoctorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    staff?: StaffUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    createdMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutDoctorNestedInput
    updatedMedicalRecords?: MedicalRecordUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutPatientNestedInput
    studies?: StudyUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutPatientNestedInput
    medicalRecords?: MedicalRecordUncheckedUpdateManyWithoutPatientNestedInput
    pharmacyOrders?: PharmacyOrderUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutPatientNestedInput
    studies?: StudyUncheckedUpdateManyWithoutPatientNestedInput
    telemedicineConsultations?: TelemedicineConsultationUncheckedUpdateManyWithoutPatientNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalRecordNumber?: StringFieldUpdateOperationsInput | string
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    bloodType?: NullableEnumBloodTypeFieldUpdateOperationsInput | $Enums.BloodType | null
    maritalStatus?: NullableEnumMaritalStatusFieldUpdateOperationsInput | $Enums.MaritalStatus | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    allergies?: NullableJsonNullValueInput | InputJsonValue
    chronicConditions?: NullableJsonNullValueInput | InputJsonValue
    currentMedications?: NullableJsonNullValueInput | InputJsonValue
    knownAllergies?: NullableJsonNullValueInput | InputJsonValue
    familyHistory?: NullableJsonNullValueInput | InputJsonValue
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceGroup?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceType?: NullableEnumInsuranceTypeFieldUpdateOperationsInput | $Enums.InsuranceType | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StudyUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    patientName?: StringFieldUpdateOperationsInput | string
    status?: EnumStudyStatusFieldUpdateOperationsInput | $Enums.StudyStatus
    studyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modality?: ModalityUpdateOneRequiredWithoutStudiesNestedInput
    patient?: PatientUpdateOneRequiredWithoutStudiesNestedInput
    series?: SeriesUpdateManyWithoutStudyNestedInput
    radReports?: RadReportUpdateManyWithoutStudyNestedInput
    radiationDoses?: RadiationDoseUpdateManyWithoutStudyNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutStudyNestedInput
  }

  export type StudyUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientName?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    status?: EnumStudyStatusFieldUpdateOperationsInput | $Enums.StudyStatus
    studyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: SeriesUncheckedUpdateManyWithoutStudyNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutStudyNestedInput
    radiationDoses?: RadiationDoseUncheckedUpdateManyWithoutStudyNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutStudyNestedInput
  }

  export type StudyUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientName?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    status?: EnumStudyStatusFieldUpdateOperationsInput | $Enums.StudyStatus
    studyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadReportUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conclusion?: NullableStringFieldUpdateOperationsInput | string | null
    reportDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    study?: StudyUpdateOneRequiredWithoutRadReportsNestedInput
    reportTemplate?: ReportTemplateUpdateOneWithoutRadReportsNestedInput
  }

  export type RadReportUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    reportTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conclusion?: NullableStringFieldUpdateOperationsInput | string | null
    reportDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadReportUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    reportTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conclusion?: NullableStringFieldUpdateOperationsInput | string | null
    reportDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportTemplateUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    template?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    radReports?: RadReportUpdateManyWithoutReportTemplateNestedInput
  }

  export type ReportTemplateUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    template?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    radReports?: RadReportUncheckedUpdateManyWithoutReportTemplateNestedInput
  }

  export type ReportTemplateUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    template?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelemedicineConsultationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTelemedicineStatusFieldUpdateOperationsInput | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    consultationType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutTelemedicineConsultationsNestedInput
    doctor?: UserUpdateOneWithoutDoctorTelemedicineNestedInput
    videoRoom?: VideoRoomUpdateOneWithoutConsultationNestedInput
    labOrders?: LabOrderUpdateManyWithoutConsultationNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutConsultationNestedInput
  }

  export type TelemedicineConsultationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTelemedicineStatusFieldUpdateOperationsInput | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    consultationType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoRoom?: VideoRoomUncheckedUpdateOneWithoutConsultationNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutConsultationNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type TelemedicineConsultationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTelemedicineStatusFieldUpdateOperationsInput | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    consultationType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoRoomUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    status?: EnumVideoRoomStatusFieldUpdateOperationsInput | $Enums.VideoRoomStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultation?: TelemedicineConsultationUpdateOneRequiredWithoutVideoRoomNestedInput
    participants?: VideoParticipantUpdateManyWithoutRoomNestedInput
    recordings?: VideoRecordingUpdateManyWithoutRoomNestedInput
  }

  export type VideoRoomUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    status?: EnumVideoRoomStatusFieldUpdateOperationsInput | $Enums.VideoRoomStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: VideoParticipantUncheckedUpdateManyWithoutRoomNestedInput
    recordings?: VideoRecordingUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type VideoRoomUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    status?: EnumVideoRoomStatusFieldUpdateOperationsInput | $Enums.VideoRoomStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: IntFieldUpdateOperationsInput | number
    recordingEnabled?: BoolFieldUpdateOperationsInput | boolean
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoParticipantUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: VideoRoomUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type VideoParticipantUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoParticipantUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoRecordingUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: VideoRoomUpdateOneRequiredWithoutRecordingsNestedInput
  }

  export type VideoRecordingUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoRecordingUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoMessageUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoMessageUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoMessageUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiologyOrderUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultation?: TelemedicineConsultationUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    patient?: PatientUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    doctor?: UserUpdateOneRequiredWithoutDoctorRadiologyOrdersNestedInput
    modality?: ModalityUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    study?: StudyUpdateOneWithoutRadiologyOrdersNestedInput
  }

  export type RadiologyOrderUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RadiologyOrderUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppointmentCreateManyDoctorInput = {
    id?: string
    patientId: string
    departmentId?: string | null
    startTime: Date | string
    endTime: Date | string
    status: $Enums.AppointmentStatus
    reason?: string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabOrderCreateManyDoctorInput = {
    id?: string
    orderNumber: string
    patientId: string
    status?: $Enums.LabOrderStatus
    orderDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationId?: string | null
  }

  export type PharmacyOrderCreateManyDoctorInput = {
    id?: string
    orderNumber: string
    patientId: string
    status?: $Enums.PharmacyOrderStatus
    orderDate?: Date | string
    dispensedDate?: Date | string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type PrescriptionCreateManyDoctorInput = {
    id?: string
    patientId: string
    diagnosis?: string | null
    notes?: string | null
    status?: $Enums.PrescriptionStatus
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelemedicineConsultationCreateManyDoctorInput = {
    id?: string
    patientId: string
    status?: $Enums.TelemedicineStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    consultationType?: $Enums.ConsultationType
    reason?: string | null
    notes?: string | null
    prescription?: string | null
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    isEmergency?: boolean
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiologyOrderCreateManyDoctorInput = {
    id?: string
    consultationId: string
    patientId: string
    modalityId: string
    studyType: string
    priority?: $Enums.Priority
    reason?: string | null
    clinicalHistory?: string | null
    status?: $Enums.RadiologyOrderStatus
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studyId?: string | null
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    jti: string
    token: string
    revoked?: boolean
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entityType?: string | null
    entityId?: string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    tenantId: string
    createdAt?: Date | string
  }

  export type MedicalRecordCreateManyDoctorInput = {
    id?: string
    patientId: string
    recordType: string
    title: string
    description?: string | null
    date?: Date | string
    updatedById?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalRecordCreateManyUpdatedByInput = {
    id?: string
    patientId: string
    recordType: string
    title: string
    description?: string | null
    date?: Date | string
    doctorId?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAppointmentsNestedInput
    department?: DepartmentUpdateOneWithoutAppointmentsNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabOrderUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutLabOrdersNestedInput
    patient?: PatientUpdateOneRequiredWithoutLabOrdersNestedInput
    tests?: LabOrderTestUpdateManyWithoutOrderNestedInput
    consultation?: TelemedicineConsultationUpdateOneWithoutLabOrdersNestedInput
  }

  export type LabOrderUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    tests?: LabOrderTestUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PharmacyOrderUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumPharmacyOrderStatusFieldUpdateOperationsInput | $Enums.PharmacyOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dispensedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutPharmacyOrdersNestedInput
    patient?: PatientUpdateOneRequiredWithoutPharmacyOrdersNestedInput
    invoice?: InvoiceUpdateOneWithoutPharmacyOrderNestedInput
    items?: PharmacyOrderItemUpdateManyWithoutOrderNestedInput
  }

  export type PharmacyOrderUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    status?: EnumPharmacyOrderStatusFieldUpdateOperationsInput | $Enums.PharmacyOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dispensedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    items?: PharmacyOrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type PharmacyOrderUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    status?: EnumPharmacyOrderStatusFieldUpdateOperationsInput | $Enums.PharmacyOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dispensedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPrescriptionsNestedInput
    patient?: PatientUpdateOneRequiredWithoutPrescriptionsNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelemedicineConsultationUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTelemedicineStatusFieldUpdateOperationsInput | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    consultationType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutTelemedicineConsultationsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTelemedicineConsultationsNestedInput
    videoRoom?: VideoRoomUpdateOneWithoutConsultationNestedInput
    labOrders?: LabOrderUpdateManyWithoutConsultationNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutConsultationNestedInput
  }

  export type TelemedicineConsultationUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    status?: EnumTelemedicineStatusFieldUpdateOperationsInput | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    consultationType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoRoom?: VideoRoomUncheckedUpdateOneWithoutConsultationNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutConsultationNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type TelemedicineConsultationUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    status?: EnumTelemedicineStatusFieldUpdateOperationsInput | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    consultationType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiologyOrderUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultation?: TelemedicineConsultationUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    patient?: PatientUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    modality?: ModalityUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    tenant?: TenantUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    study?: StudyUpdateOneWithoutRadiologyOrdersNestedInput
  }

  export type RadiologyOrderUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RadiologyOrderUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    jti?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMedicalRecordsNestedInput
    patient?: PatientUpdateOneRequiredWithoutMedicalRecordsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedMedicalRecordsNestedInput
  }

  export type MedicalRecordUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMedicalRecordsNestedInput
    patient?: PatientUpdateOneRequiredWithoutMedicalRecordsNestedInput
    doctor?: UserUpdateOneWithoutCreatedMedicalRecordsNestedInput
  }

  export type MedicalRecordUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyPatientInput = {
    id?: string
    doctorId: string
    departmentId?: string | null
    startTime: Date | string
    endTime: Date | string
    status: $Enums.AppointmentStatus
    reason?: string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyPatientInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    subTotal?: number
    taxAmount?: number
    discountAmount?: number
    totalAmount?: number
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type LabOrderCreateManyPatientInput = {
    id?: string
    orderNumber: string
    doctorId?: string | null
    status?: $Enums.LabOrderStatus
    orderDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultationId?: string | null
  }

  export type MedicalRecordCreateManyPatientInput = {
    id?: string
    recordType: string
    title: string
    description?: string | null
    date?: Date | string
    doctorId?: string | null
    updatedById?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PharmacyOrderCreateManyPatientInput = {
    id?: string
    orderNumber: string
    doctorId?: string | null
    status?: $Enums.PharmacyOrderStatus
    orderDate?: Date | string
    dispensedDate?: Date | string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    createdBy?: string | null
    updatedBy?: string | null
  }

  export type PrescriptionCreateManyPatientInput = {
    id?: string
    doctorId: string
    diagnosis?: string | null
    notes?: string | null
    status?: $Enums.PrescriptionStatus
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrescriptionItemCreateManyPatientInput = {
    id?: string
    prescriptionId: string
    medicationId: string
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    isDispensed?: boolean
    tenantId: string
  }

  export type StudyCreateManyPatientInput = {
    id?: string
    studyId: string
    patientName: string
    modalityId: string
    status?: $Enums.StudyStatus
    studyDate?: Date | string
    priority?: $Enums.Priority | null
    description?: string | null
    notes?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelemedicineConsultationCreateManyPatientInput = {
    id?: string
    doctorId?: string | null
    status?: $Enums.TelemedicineStatus
    scheduledAt: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    duration?: number | null
    consultationType?: $Enums.ConsultationType
    reason?: string | null
    notes?: string | null
    prescription?: string | null
    followUpRequired?: boolean
    followUpDate?: Date | string | null
    isEmergency?: boolean
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiologyOrderCreateManyPatientInput = {
    id?: string
    consultationId: string
    doctorId: string
    modalityId: string
    studyType: string
    priority?: $Enums.Priority
    reason?: string | null
    clinicalHistory?: string | null
    status?: $Enums.RadiologyOrderStatus
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studyId?: string | null
  }

  export type AppointmentUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAppointmentsNestedInput
    department?: DepartmentUpdateOneWithoutAppointmentsNestedInput
    doctor?: UserUpdateOneRequiredWithoutDoctorAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
    pharmacyOrder?: PharmacyOrderUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
    pharmacyOrder?: PharmacyOrderUncheckedUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    subTotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabOrderUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutLabOrdersNestedInput
    doctor?: UserUpdateOneWithoutDoctorLabOrdersNestedInput
    tests?: LabOrderTestUpdateManyWithoutOrderNestedInput
    consultation?: TelemedicineConsultationUpdateOneWithoutLabOrdersNestedInput
  }

  export type LabOrderUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
    tests?: LabOrderTestUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalRecordUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMedicalRecordsNestedInput
    doctor?: UserUpdateOneWithoutCreatedMedicalRecordsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedMedicalRecordsNestedInput
  }

  export type MedicalRecordUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalRecordUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PharmacyOrderUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumPharmacyOrderStatusFieldUpdateOperationsInput | $Enums.PharmacyOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dispensedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutPharmacyOrdersNestedInput
    doctor?: UserUpdateOneWithoutDoctorPrescriptionsNestedInput
    invoice?: InvoiceUpdateOneWithoutPharmacyOrderNestedInput
    items?: PharmacyOrderItemUpdateManyWithoutOrderNestedInput
  }

  export type PharmacyOrderUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPharmacyOrderStatusFieldUpdateOperationsInput | $Enums.PharmacyOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dispensedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    items?: PharmacyOrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type PharmacyOrderUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPharmacyOrderStatusFieldUpdateOperationsInput | $Enums.PharmacyOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dispensedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPrescriptionsNestedInput
    doctor?: UserUpdateOneRequiredWithoutPrescriptionsNestedInput
    prescriptionItems?: PrescriptionItemUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPrescriptionStatusFieldUpdateOperationsInput | $Enums.PrescriptionStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionItemUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    tenant?: TenantUpdateOneRequiredWithoutPrescriptionItemsNestedInput
    medication?: MedicationUpdateOneRequiredWithoutPrescriptionItemsNestedInput
    prescription?: PrescriptionUpdateOneRequiredWithoutPrescriptionItemsNestedInput
  }

  export type PrescriptionItemUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionItemUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type StudyUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    patientName?: StringFieldUpdateOperationsInput | string
    status?: EnumStudyStatusFieldUpdateOperationsInput | $Enums.StudyStatus
    studyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modality?: ModalityUpdateOneRequiredWithoutStudiesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutStudiesNestedInput
    series?: SeriesUpdateManyWithoutStudyNestedInput
    radReports?: RadReportUpdateManyWithoutStudyNestedInput
    radiationDoses?: RadiationDoseUpdateManyWithoutStudyNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutStudyNestedInput
  }

  export type StudyUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    patientName?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    status?: EnumStudyStatusFieldUpdateOperationsInput | $Enums.StudyStatus
    studyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: SeriesUncheckedUpdateManyWithoutStudyNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutStudyNestedInput
    radiationDoses?: RadiationDoseUncheckedUpdateManyWithoutStudyNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutStudyNestedInput
  }

  export type StudyUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    patientName?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    status?: EnumStudyStatusFieldUpdateOperationsInput | $Enums.StudyStatus
    studyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelemedicineConsultationUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTelemedicineStatusFieldUpdateOperationsInput | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    consultationType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: UserUpdateOneWithoutDoctorTelemedicineNestedInput
    tenant?: TenantUpdateOneRequiredWithoutTelemedicineConsultationsNestedInput
    videoRoom?: VideoRoomUpdateOneWithoutConsultationNestedInput
    labOrders?: LabOrderUpdateManyWithoutConsultationNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutConsultationNestedInput
  }

  export type TelemedicineConsultationUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTelemedicineStatusFieldUpdateOperationsInput | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    consultationType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videoRoom?: VideoRoomUncheckedUpdateOneWithoutConsultationNestedInput
    labOrders?: LabOrderUncheckedUpdateManyWithoutConsultationNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type TelemedicineConsultationUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTelemedicineStatusFieldUpdateOperationsInput | $Enums.TelemedicineStatus
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    consultationType?: EnumConsultationTypeFieldUpdateOperationsInput | $Enums.ConsultationType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isEmergency?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiologyOrderUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultation?: TelemedicineConsultationUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    doctor?: UserUpdateOneRequiredWithoutDoctorRadiologyOrdersNestedInput
    modality?: ModalityUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    tenant?: TenantUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    study?: StudyUpdateOneWithoutRadiologyOrdersNestedInput
  }

  export type RadiologyOrderUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RadiologyOrderUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionItemCreateManyPrescriptionInput = {
    id?: string
    medicationId: string
    patientId: string
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    isDispensed?: boolean
    tenantId: string
  }

  export type PrescriptionItemUpdateWithoutPrescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    tenant?: TenantUpdateOneRequiredWithoutPrescriptionItemsNestedInput
    patient?: PatientUpdateOneRequiredWithoutPrescriptionItemsNestedInput
    medication?: MedicationUpdateOneRequiredWithoutPrescriptionItemsNestedInput
  }

  export type PrescriptionItemUncheckedUpdateWithoutPrescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionItemUncheckedUpdateManyWithoutPrescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: string
    itemType: string
    itemId: string
    description: string
    quantity?: number
    unitPrice: number
    discount?: number
    taxRate?: number
    totalAmount: number
    tenantId: string
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: string
    paymentNumber: string
    amount: number
    paymentDate?: Date | string
    paymentMethod: $Enums.PaymentMethod
    referenceNumber?: string | null
    notes?: string | null
    status?: $Enums.PaymentStatus
    tenantId: string
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    tenant?: TenantUpdateOneRequiredWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemType?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabOrderTestCreateManyTestInput = {
    id?: string
    orderId: string
    status?: $Enums.LabTestStatus
    result?: string | null
    resultDate?: Date | string | null
    referenceRange?: string | null
    notes?: string | null
    tenantId: string
  }

  export type LabOrderTestUpdateWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLabTestStatusFieldUpdateOperationsInput | $Enums.LabTestStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutLabOrderTestsNestedInput
    order?: LabOrderUpdateOneRequiredWithoutTestsNestedInput
  }

  export type LabOrderTestUncheckedUpdateWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    status?: EnumLabTestStatusFieldUpdateOperationsInput | $Enums.LabTestStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type LabOrderTestUncheckedUpdateManyWithoutTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    status?: EnumLabTestStatusFieldUpdateOperationsInput | $Enums.LabTestStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type LabOrderTestCreateManyOrderInput = {
    id?: string
    testId: string
    status?: $Enums.LabTestStatus
    result?: string | null
    resultDate?: Date | string | null
    referenceRange?: string | null
    notes?: string | null
    tenantId: string
  }

  export type LabOrderTestUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLabTestStatusFieldUpdateOperationsInput | $Enums.LabTestStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenant?: TenantUpdateOneRequiredWithoutLabOrderTestsNestedInput
    test?: LabTestUpdateOneRequiredWithoutLabOrdersNestedInput
  }

  export type LabOrderTestUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumLabTestStatusFieldUpdateOperationsInput | $Enums.LabTestStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type LabOrderTestUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    testId?: StringFieldUpdateOperationsInput | string
    status?: EnumLabTestStatusFieldUpdateOperationsInput | $Enums.LabTestStatus
    result?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type PharmacyOrderItemCreateManyMedicationInput = {
    id?: string
    orderId: string
    quantity?: number
    dosage?: string | null
    frequency?: string | null
    duration?: string | null
    instructions?: string | null
    status?: $Enums.PharmacyItemStatus
    tenantId: string
  }

  export type PrescriptionItemCreateManyMedicationInput = {
    id?: string
    prescriptionId: string
    patientId: string
    dosage: string
    frequency: string
    duration: string
    instructions?: string | null
    isDispensed?: boolean
    tenantId: string
  }

  export type PharmacyOrderItemUpdateWithoutMedicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPharmacyItemStatusFieldUpdateOperationsInput | $Enums.PharmacyItemStatus
    tenant?: TenantUpdateOneRequiredWithoutPharmacyOrderItemsNestedInput
    order?: PharmacyOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PharmacyOrderItemUncheckedUpdateWithoutMedicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPharmacyItemStatusFieldUpdateOperationsInput | $Enums.PharmacyItemStatus
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type PharmacyOrderItemUncheckedUpdateManyWithoutMedicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPharmacyItemStatusFieldUpdateOperationsInput | $Enums.PharmacyItemStatus
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionItemUpdateWithoutMedicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    tenant?: TenantUpdateOneRequiredWithoutPrescriptionItemsNestedInput
    patient?: PatientUpdateOneRequiredWithoutPrescriptionItemsNestedInput
    prescription?: PrescriptionUpdateOneRequiredWithoutPrescriptionItemsNestedInput
  }

  export type PrescriptionItemUncheckedUpdateWithoutMedicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type PrescriptionItemUncheckedUpdateManyWithoutMedicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    isDispensed?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type PharmacyOrderItemCreateManyOrderInput = {
    id?: string
    medicationId: string
    quantity?: number
    dosage?: string | null
    frequency?: string | null
    duration?: string | null
    instructions?: string | null
    status?: $Enums.PharmacyItemStatus
    tenantId: string
  }

  export type PharmacyOrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPharmacyItemStatusFieldUpdateOperationsInput | $Enums.PharmacyItemStatus
    tenant?: TenantUpdateOneRequiredWithoutPharmacyOrderItemsNestedInput
    medication?: MedicationUpdateOneRequiredWithoutPharmacyOrderItemsNestedInput
  }

  export type PharmacyOrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPharmacyItemStatusFieldUpdateOperationsInput | $Enums.PharmacyItemStatus
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type PharmacyOrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPharmacyItemStatusFieldUpdateOperationsInput | $Enums.PharmacyItemStatus
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type StudyCreateManyModalityInput = {
    id?: string
    studyId: string
    patientId: string
    patientName: string
    status?: $Enums.StudyStatus
    studyDate?: Date | string
    priority?: $Enums.Priority | null
    description?: string | null
    notes?: string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiologyOrderCreateManyModalityInput = {
    id?: string
    consultationId: string
    patientId: string
    doctorId: string
    studyType: string
    priority?: $Enums.Priority
    reason?: string | null
    clinicalHistory?: string | null
    status?: $Enums.RadiologyOrderStatus
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studyId?: string | null
  }

  export type StudyUpdateWithoutModalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    patientName?: StringFieldUpdateOperationsInput | string
    status?: EnumStudyStatusFieldUpdateOperationsInput | $Enums.StudyStatus
    studyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutStudiesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutStudiesNestedInput
    series?: SeriesUpdateManyWithoutStudyNestedInput
    radReports?: RadReportUpdateManyWithoutStudyNestedInput
    radiationDoses?: RadiationDoseUpdateManyWithoutStudyNestedInput
    radiologyOrders?: RadiologyOrderUpdateManyWithoutStudyNestedInput
  }

  export type StudyUncheckedUpdateWithoutModalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientName?: StringFieldUpdateOperationsInput | string
    status?: EnumStudyStatusFieldUpdateOperationsInput | $Enums.StudyStatus
    studyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: SeriesUncheckedUpdateManyWithoutStudyNestedInput
    radReports?: RadReportUncheckedUpdateManyWithoutStudyNestedInput
    radiationDoses?: RadiationDoseUncheckedUpdateManyWithoutStudyNestedInput
    radiologyOrders?: RadiologyOrderUncheckedUpdateManyWithoutStudyNestedInput
  }

  export type StudyUncheckedUpdateManyWithoutModalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    patientName?: StringFieldUpdateOperationsInput | string
    status?: EnumStudyStatusFieldUpdateOperationsInput | $Enums.StudyStatus
    studyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: NullableEnumPriorityFieldUpdateOperationsInput | $Enums.Priority | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiologyOrderUpdateWithoutModalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultation?: TelemedicineConsultationUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    patient?: PatientUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    doctor?: UserUpdateOneRequiredWithoutDoctorRadiologyOrdersNestedInput
    tenant?: TenantUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    study?: StudyUpdateOneWithoutRadiologyOrdersNestedInput
  }

  export type RadiologyOrderUncheckedUpdateWithoutModalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RadiologyOrderUncheckedUpdateManyWithoutModalityInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeriesCreateManyStudyInput = {
    id?: string
    seriesUid: string
    number: number
    description?: string | null
    modality: string
    bodyPart?: string | null
    count?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadReportCreateManyStudyInput = {
    id?: string
    reportId: string
    reportTemplateId?: string | null
    status?: $Enums.ReportStatus
    findings?: string | null
    impression?: string | null
    conclusion?: string | null
    reportDateTime?: Date | string
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiationDoseCreateManyStudyInput = {
    id?: string
    deviceName?: string | null
    deviceType?: string | null
    exposureTime?: number | null
    kvp?: number | null
    ma?: number | null
    doseAreaProduct?: number | null
    doseLengthProduct?: number | null
    ctdiVol?: number | null
    dlp?: number | null
    effectiveDose?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiologyOrderCreateManyStudyInput = {
    id?: string
    consultationId: string
    patientId: string
    doctorId: string
    modalityId: string
    studyType: string
    priority?: $Enums.Priority
    reason?: string | null
    clinicalHistory?: string | null
    status?: $Enums.RadiologyOrderStatus
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeriesUpdateWithoutStudyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesUid?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    modality?: StringFieldUpdateOperationsInput | string
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    count?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateWithoutStudyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesUid?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    modality?: StringFieldUpdateOperationsInput | string
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    count?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateManyWithoutStudyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesUid?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    modality?: StringFieldUpdateOperationsInput | string
    bodyPart?: NullableStringFieldUpdateOperationsInput | string | null
    count?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadReportUpdateWithoutStudyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conclusion?: NullableStringFieldUpdateOperationsInput | string | null
    reportDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutRadReportsNestedInput
    reportTemplate?: ReportTemplateUpdateOneWithoutRadReportsNestedInput
  }

  export type RadReportUncheckedUpdateWithoutStudyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    reportTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conclusion?: NullableStringFieldUpdateOperationsInput | string | null
    reportDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadReportUncheckedUpdateManyWithoutStudyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    reportTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conclusion?: NullableStringFieldUpdateOperationsInput | string | null
    reportDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiationDoseUpdateWithoutStudyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    exposureTime?: NullableFloatFieldUpdateOperationsInput | number | null
    kvp?: NullableFloatFieldUpdateOperationsInput | number | null
    ma?: NullableFloatFieldUpdateOperationsInput | number | null
    doseAreaProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    doseLengthProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    ctdiVol?: NullableFloatFieldUpdateOperationsInput | number | null
    dlp?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveDose?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiationDoseUncheckedUpdateWithoutStudyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    exposureTime?: NullableFloatFieldUpdateOperationsInput | number | null
    kvp?: NullableFloatFieldUpdateOperationsInput | number | null
    ma?: NullableFloatFieldUpdateOperationsInput | number | null
    doseAreaProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    doseLengthProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    ctdiVol?: NullableFloatFieldUpdateOperationsInput | number | null
    dlp?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveDose?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiationDoseUncheckedUpdateManyWithoutStudyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    exposureTime?: NullableFloatFieldUpdateOperationsInput | number | null
    kvp?: NullableFloatFieldUpdateOperationsInput | number | null
    ma?: NullableFloatFieldUpdateOperationsInput | number | null
    doseAreaProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    doseLengthProduct?: NullableFloatFieldUpdateOperationsInput | number | null
    ctdiVol?: NullableFloatFieldUpdateOperationsInput | number | null
    dlp?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveDose?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiologyOrderUpdateWithoutStudyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultation?: TelemedicineConsultationUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    patient?: PatientUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    doctor?: UserUpdateOneRequiredWithoutDoctorRadiologyOrdersNestedInput
    modality?: ModalityUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    tenant?: TenantUpdateOneRequiredWithoutRadiologyOrdersNestedInput
  }

  export type RadiologyOrderUncheckedUpdateWithoutStudyInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiologyOrderUncheckedUpdateManyWithoutStudyInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageCreateManySeriesInput = {
    id?: string
    sopInstanceUid: string
    number: number
    path: string
    size: number
    contentType: string
    width: number
    height: number
    windowCenter?: number | null
    windowWidth?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sopInstanceUid?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentType?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    windowCenter?: NullableFloatFieldUpdateOperationsInput | number | null
    windowWidth?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUncheckedUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sopInstanceUid?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentType?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    windowCenter?: NullableFloatFieldUpdateOperationsInput | number | null
    windowWidth?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUncheckedUpdateManyWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sopInstanceUid?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    path?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentType?: StringFieldUpdateOperationsInput | string
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    windowCenter?: NullableFloatFieldUpdateOperationsInput | number | null
    windowWidth?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadReportCreateManyReportTemplateInput = {
    id?: string
    reportId: string
    studyId: string
    status?: $Enums.ReportStatus
    findings?: string | null
    impression?: string | null
    conclusion?: string | null
    reportDateTime?: Date | string
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadReportUpdateWithoutReportTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conclusion?: NullableStringFieldUpdateOperationsInput | string | null
    reportDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    study?: StudyUpdateOneRequiredWithoutRadReportsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutRadReportsNestedInput
  }

  export type RadReportUncheckedUpdateWithoutReportTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conclusion?: NullableStringFieldUpdateOperationsInput | string | null
    reportDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadReportUncheckedUpdateManyWithoutReportTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    studyId?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    findings?: NullableStringFieldUpdateOperationsInput | string | null
    impression?: NullableStringFieldUpdateOperationsInput | string | null
    conclusion?: NullableStringFieldUpdateOperationsInput | string | null
    reportDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabOrderCreateManyConsultationInput = {
    id?: string
    orderNumber: string
    patientId: string
    doctorId?: string | null
    status?: $Enums.LabOrderStatus
    orderDate?: Date | string
    completedDate?: Date | string | null
    notes?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RadiologyOrderCreateManyConsultationInput = {
    id?: string
    patientId: string
    doctorId: string
    modalityId: string
    studyType: string
    priority?: $Enums.Priority
    reason?: string | null
    clinicalHistory?: string | null
    status?: $Enums.RadiologyOrderStatus
    scheduledAt?: Date | string | null
    completedAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studyId?: string | null
  }

  export type LabOrderUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutLabOrdersNestedInput
    doctor?: UserUpdateOneWithoutDoctorLabOrdersNestedInput
    patient?: PatientUpdateOneRequiredWithoutLabOrdersNestedInput
    tests?: LabOrderTestUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tests?: LabOrderTestUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type LabOrderUncheckedUpdateManyWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLabOrderStatusFieldUpdateOperationsInput | $Enums.LabOrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RadiologyOrderUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    doctor?: UserUpdateOneRequiredWithoutDoctorRadiologyOrdersNestedInput
    modality?: ModalityUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    tenant?: TenantUpdateOneRequiredWithoutRadiologyOrdersNestedInput
    study?: StudyUpdateOneWithoutRadiologyOrdersNestedInput
  }

  export type RadiologyOrderUncheckedUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RadiologyOrderUncheckedUpdateManyWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    modalityId?: StringFieldUpdateOperationsInput | string
    studyType?: StringFieldUpdateOperationsInput | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    clinicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRadiologyOrderStatusFieldUpdateOperationsInput | $Enums.RadiologyOrderStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VideoParticipantCreateManyRoomInput = {
    id?: string
    userId: string
    participantType: $Enums.ParticipantType
    joinedAt?: Date | string | null
    leftAt?: Date | string | null
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoRecordingCreateManyRoomInput = {
    id?: string
    fileName: string
    filePath: string
    fileSize: number
    duration?: number | null
    status?: $Enums.RecordingStatus
    isActive?: boolean
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VideoParticipantUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVideoParticipantsNestedInput
  }

  export type VideoParticipantUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoParticipantUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    participantType?: EnumParticipantTypeFieldUpdateOperationsInput | $Enums.ParticipantType
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoRecordingUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutVideoRecordingsNestedInput
  }

  export type VideoRecordingUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoRecordingUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}